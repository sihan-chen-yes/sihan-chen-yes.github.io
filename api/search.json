[{"id":"331a202dba2c0a92d7a5610826376ac5","title":"Welcome to Sihan's Blog!","content":"\nHello, welcome to my website!\nI’m Sihan Chen, a senior from Beihang University majoring in Computer Science.\nIf you like this, we’d be good friends\ncoding, curious about fancy technologies both in software and hardware\n\ngames, including all platforms (PS, Xbox, NS, PC), but except mobile!\n\nanime, addictive anime fans\n\nsports, especially badminton and basketball\n\n\nWhat you can do in my Blog?\nAbout: here’s my detailed information, you can check it here to know me if you want\n\nResearch: here you can have a look at my recent research progress\n\nProjects: most the projects I’ve done will be listed here\n\nIntern: here I’m glad to share my intern experience including the advanced skill I learned in industry and the preparation process\n\nMessage Board: If you have any words to talk with me,  feel free to leave them here\n\n\nIn the future I’ll expand my life and games modules in my Blog, and I’ll keep write blogs in above modules and I look forward to your visit.😃\n","slug":"welcome","date":"2022-11-02T13:36:43.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"},{"id":"f68465535d0d54d5f349f18e96ad6c70","title":"PROJECTS","content":"Institue of Artificial Intelligence, Beihang UniversityMultifunctional Movie Website Sept. 2021 – Dec. 2021\nDeveloped a website for watching movies, deployed it on my private cloud server already\nClick here to visit, Account:123, Password:123 for tourist\nUsed Vue and Django frame to build the front and back end respectively, and chose MySQL as database\nBuilt E-R Diagram to design tables which met the requirement of 3NF for a trade-off between stability and efficiency\nImproved the security of website via anti-injection of database and ciphertext of password storage\n\nSysY-based Compiler Sept. 2021 – Dec. 2021\nBuilt a compiler using Java, which can transform SysY (a subset of C) from source code to MIPS assembly code\nIncluded modules of Lexical Analysis (Automata Theory-based), Syntax Analysis (Recursive Descent-based), Semantic Analysis (Abstract Syntax Tree-based), Middle Code Generation (Quaternary Formula-based), Target Code Generation (MIPS-based)\nOptimized the compiler via Inline Function, Loop Optimization, Register Allocation Optimization, among others; ranked 24 &#x2F; 250 finally\n\nARC-based Page Replacement May. 2021 – June. 2021\nSimulated the page replacement of cache in operating system, and used Adaptive Replacement Cache (ARC) algorithm to decrease miss rate, which considered both recency and frequency, with adaptivity to the current memory access mode by adjusting capacity of cache for both dynamically\nBuilt data structure with specific function and low memory usage from scratch rather than using STL container\nRanked 1&#x2F;250 (according to the weighted result of perf instruction on Linux operating system)\n\nMIPS-based Operating System Kernel Mar. 2021 – June. 2021\nBuilt a MIPS-based operating system kernel via Linux platform, using C programming language\nSupported memory management, virtual address, interruption handling, inter-process switch and communication, disk management, file system and IO operation of device\n\nElevator System Simulator Mar. 2021 – Apr. 2021\nUsed multithreading of Java to simulate the elevator system to deliver people to their target floor with the least time\nConsidered the load and number of elevators, used the LOOK scheduling algorithm for each individual elevator, and global transfer strategy to arrange all elevators to reach the least total of waiting time\n\nSocial Relationship System Mar. 2021 – Apr. 2021\nDeveloped a simple social relation simulator, supporting making groups, sending red envelopes and messages between users, querying the real-time status of the system, and managing kinds of exceptions\n\nBuilt a debugging program to assure the correctness and real-time via black-box and white-box testing, and stress testing, respectively\n\n\nMIPS-based CPU Oct. 2020 – Jan. 2021\nImplemented a CPU supporting five-stage pipelines (IF,ID,EX,MEM,WB) and interruption and exception handling\nSupported 53 instructions totally in MIPS instruction set, where assembly instructions of C programs can be run\n\nCOVID-19 Reporter Feb. 2022 – March. 2022\nBuilt a auto reporter via Python\nUsed Charles to grasp the http package, then generated a fake one and sent it to the school server\nConsidered the accident, if report failed, an email sent by the reporter to my phone\n\nFire Alarm and Emergency Response System Sept. 2021 – Dec. 2021\nImplemented a IoT system with functions of sensing the ambient information (temperature and humidity),  presenting the history curve of it, controlling the alarm and threshold of alarm remotely, warning with LED flashing and buzzer working\nUsed Vue and Django to build the front and back end, MySQL to record the history information\n\nWeb Crawler Sept. 2020 – Dec. 2020\nUsed Python to collect the movie information on Douban Top 250 Rank\n\nUsed IP proxy, random UA and referrer to make fake request_headers, carried out sleep to simulate real humans\n\nUsed PyQt5 lib to design the UI, separated the UI frame code and the logic code for better maintenance\n\nUsed B+ tree to accelerate the search process at local\n\n\n","slug":"projects","date":"2022-11-02T13:25:13.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"},{"id":"27379ee9b4cc0fae3c3b580e4d316922","title":"RESEARCH","content":"I’ve done some research in CV, Robotics and Visual-language Navigation (VLN) field.\nI’m going to further explore CV, NLP and ML field in the future.\nInstitue of Artificial Intelligence, Beihang University\n\n\n\n\n\n\n\n\nUnder the supervision of  Prof. Si Liu in  CoLab\nVLN Model Optimization (May. 2022 – Present)\nProposed the Structured state-Evolution (SEvol) module to solve the flaw of over-compression of object-level spatial-temporal information in NvEM, and enhanced the performance of it on R2R, R4R and REVERIE datasets\nBased on A2C algorithm, used Reinforced Layout clues Miner (RLM) module to select objects appropriately\nEmployed Dynamic Graph Neural Network (DGNN) to aggregate the spatial-temporal information of objects\nBased on GRU model, proposed mGRU model (matrix version), accomplished the renewal of weight in DGNN at every time step\n\nInteractive Robotic Dog (Oct. 2021 – May. 2022)\nBuilt a robotic dog with the function of voice interaction and guiding the blind\nImplemented object detection and speech recognition module based on YOLOv5 and CMUSphinx respectively\nImplemented main control module based on SDK of motion and information generated by two modules mentioned\n\n","slug":"research","date":"2022-11-02T13:22:11.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"},{"id":"bcbd58ac5f0b48fdbd3c6d1a1cb9f5d7","title":"GoLearning","content":"GoLearning记录一下Go的学习 (主要是ByteDance实习用)，方便以后复习，如果能帮到其他人就更好了\n\nGo modgo mod init\ngo mod tidy\ngo mod download\ngo get XXX@branch_name  XX@commit-id\n\n\n\n数据类型值类型 引用类型\n布尔型：默认为false\n数字类型:默认为0\n\n(u)int(8&#x2F;16&#x2F;32&#x2F;64)\nByte\n\n字符串类型：默认为””\n派生类型：默认为nil\n\n(a) 指针类型（Pointer）:*type\n(b) 数组类型:[]type\n(c) 结构化类型(struct):\n(d) Channel 类型:chan int\n(e) 函数类型 func(type) type\n(f) 切片类型\n(g) 接口类型（interface）\n(h) Map 类型:map[type] type\n\n类型转换\nvar sum int = 17\n//sum := 17也可\nfloat32(sum)\n\n类型断言（只用于空接口 interafce{}）\n接口都包括两个属性 一个是值一个是类型\nfunc ManageInterface(i interface&#123;&#125;) &#123;\n  //会返回一个新的变量 带有新的指定类型 v 与 i不同 i的类型不发生变化\n\tv, ok := i.(string)\n\tif ok &#123;\n\t\tfmt.Println(v)\n\t&#125; else &#123;\n\t\tfmt.Println(ok)\n\t&#125;\n&#125;\n//对i空接口的的类型（一个属性）进行判断 不改变i接口的类型 如果需要改变 需要使用类型断言 改变空接口的类型属性 然后返回一个新的变量\n\tswitch i.(type) &#123;\n\tcase int:\n\t\tfmt.Println(i)\n\tcase string:\n\t\tfmt.Println(\"is int\")\n\tdefault:\n\t\tfmt.Println(\"other\")\n\t&#125;\n\n\n\n变量和常量//未进行初始化 有默认值\nvar name1,name2 type\n//自动推理 并行赋值\nvar name1,name2 = 1,2 \n//赋值\nname1 = value\n//声明变量并进行初始化\nname1,name2 := 1,2\n//声明变量并进行初始化\nvar (\n  name1 int\n  name2 bool\n)\n//全局变量声明并初始化 注意全局变量不能用:=\nvar name1,name2 = 1,2\nvar name1,name2\n//go中必须使用所有声明的变量 _表示只写 和Python不一样\nval,err = Func1(var1)\nval,_ = Func1(var1)\n\n//常量声明 初始化\nconst name1 = 1\n//常量用作枚举\nconsto (\n  a = 0\n  b = 1\n  c = 2\n)\n//iota是可以被编译器修改的常量\nconst (\n    a = iota\n    b = iota\n    c = iota\n)\nconst (\n    a = iota\n    b\n    c\n)\n\n作用域全局 局部 形参\n运算符有自增&#x2F;减运算符\n异或:^\n取地址:&amp;\n取值:*\n控制流条件//if\n//注意如果只有一个cond 不要用() 后面接 &#123;&#125;\nif a == 1 &#123;\n  \n&#125; else &#123;\n  \n&#125;\n//switch var1可以是任何类型 val1,val2,val3类型必须相同\nswitch var1 &#123;\n\tcase val1:\n  ...\n  case val2,val3:\n  \tfallthrough //强制执行后面的分支\n  //不需要break\n\tdefault:\n&#125;\n//select \nselect &#123;\n  case i1 \n&#125;\n\n/*如果任意某个通信可以进行，它就执行，其他被忽略。\n如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。\n否则：\n如果有 default 子句，则执行该语句。\n如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。*/\n\n循环貌似没有while 用for代替while\nfor i := 0;i &lt;= 10 ;i++ &#123;\n  ftm.Println(i)\n&#125;\nfor k,v := range map1 &#123;\n  \n&#125;\nfor k := range map1 &#123;\n  \n&#125;\nfor _,v := range map1 &#123;\n  \n&#125;\n\n函数值传参 引用传参\nfunc max(num1,num2 int) int &#123;\n  return res\n  //可以返回多个值\n&#125;\nfunc main() &#123;\n  var res = max(a,b)\n&#125;\n\n闭包\nfunc getSequence() func() int &#123;\n   i:=0\n   return func() int &#123;\n      i+=1\n     return i  \n   &#125;\n&#125;\n\nfunc main()&#123;\n   /* nextNumber 为一个函数，函数 i 为 0 */\n   nextNumber := getSequence()  \n\n   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */\n   fmt.Println(nextNumber())\n   fmt.Println(nextNumber())\n   fmt.Println(nextNumber())\n   \n   /* 创建新的函数 nextNumber1，并查看结果 */\n   nextNumber1 := getSequence()  \n   fmt.Println(nextNumber1())\n   fmt.Println(nextNumber1())\n&#125;\n\n数组注意go中数组作为拷贝传递 \n切片(slice)作为引用传递 \nchan func map\n//自动初始化为0\nvar list [10]int\nlist := [5]int&#123;1,2,3,4,5&#125;\nvar list [MAX]*int\n//可以省略长度 type[5]int\nlist := [...]int&#123;1,2,3,4,5&#125;\n//用index初始化\nlist := [5]float32&#123;1:2.0,3:7.0&#125;\nlist[i]\n//二维数组\nlist := [2][3]int &#123;\n  &#123;1,2,3&#125;,\n  &#123;4,5,6&#125;,\n&#125;\nlist = append(list,element)\ncopye(new_list,list)\n//返回切片类型\nlist[:5]\n\nGO指针var ptr *int\nptr = &amp;name\n(param *int,param []int)\n\n结构体type Name struct &#123;\n  radius float64\n  name1 int\n  name2 float32\n&#125;\nfunc (n Name) getArea() float64 &#123;\n  //c.radius 即为 Circle 类型对象中的属性 访问属性\n  return 3.14 * n.radius * n.radius\n&#125;\nfunc main() &#123;\n  //对象初始化\n  var b1 = Books &#123;\n    radius:1.1,\n    name1:1,\n    name2:2\n  &#125;\n  //对象指针\n  var b *Book\n  b = &amp;b1\n&#125;\n\n接口注意go和java的interface完全不一样 java是侵入式 显式实现\n//注意任何类型都可以看作是interface&#123;&#125; 作为泛型理解\nvar a interface&#123;&#125;\n//interface&#123;&#125; 是可以由任意类型转换过来 但是[]string 不能转化为[]interface&#123;&#125;\n//甚至[]interface&#123;&#125;可以转化为interface&#123;&#125;\nfunc PrintAll(vals []interface&#123;&#125;) &#123;\n    for _, val := range vals &#123;\n        fmt.Println(val)\n    &#125;\n&#125;\n \nfunc main() &#123;\n    names := []string&#123;\"stanley\", \"david\", \"oscar\"&#125;\n    vals := make([]interface&#123;&#125;, len(names))\n    for i, v := range names &#123;\n        vals[i] = v\n    &#125;\n    PrintAll(vals)\n&#125;\n//interface&#123;&#125;可以进行强转\nv.(float64)\n//非interface&#123;&#125;只能\nfloat64(v)\n\n切片(slice)//len为初始长度 cap为最大长度\ns := make([]type,len,cap)\ns1 := s[:]\ns2 := s[start:end]\ns3 := s[:end]\ns4 := s[start:]\ns5 := []type&#123;&#125;\n\nrange用来进行遍历\n//遍历list\nfor i,v := range list &#123;\n  \n&#125;\nfor k,v := range map1 &#123;\n  \n&#125;\n//可以省略v k/i必须使用占位符_\n\nmaphashmap\n//声明\nvar map1 map[key_type]value_type\n//初始化 \nmap1 = make(map[key_type]value_type)\n//语法糖\nmap1 := make(map[key_type]value_type)\n//delete\ndelete(map1,key)\n//add\nmap1[key] = value\n//查看是否存在\n_,exist = map1[key]\n\n错误处理类似C语言向上return error值\n没有java python catch那套\n并发//开启新线程\ngo func_name()\n\n字符串![image-20220706112021775](..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Users&#x2F;bytedance&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220706112021775.png)\ndefer defer修饰的函数的参数在声明时确定\n在函数返回时执行\npackage main\n\nimport \"fmt\"\n\nfunc main() &#123;\n\tvar a int = 5\n\tdefer fmt.Println(a)\n\ta = a + 1\n//5\n\n用defer修饰的call会等到周围的函数都执行完之后才执行，但是此call的参数会提前压入\nchan主要用于goroutine之间的交互通讯，管道(队列)\n//创建int类型的管道 设置容量为100 单位为元素的个数\nch := make(chan int，100)\n//将v放入管道\nch &lt;- v\n//从chan中接收数据 并赋给x,ok表示执行情况\nx，ok := &lt;- ch\n//for range可以遍历chan\nfor i := range c &#123;\n  fmt.Println(i)\n&#125;\n//select 伪随机的执行操作\nfunc fibonacci(c, quit chan int) &#123;\n    x, y := 0, 1\n    for &#123;\n        select &#123;\n        case c &lt;- x:\n            x, y = y, x+y\n        case &lt;-quit:\n            fmt.Println(\"quit\")\n            return\n        &#125;\n    &#125;\n&#125;\nfunc main() &#123;\n    c := make(chan int)\n    quit := make(chan int)\n    go func() &#123;\n        for i := 0; i &lt; 10; i++ &#123;\n            fmt.Println(&lt;-c)\n        &#125;\n        quit &lt;- 0\n    &#125;()\n    fibonacci(c, quit)\n&#125;\n//加上for可以无限循环\nfor &#123;\n  \n&#125;\n//timeout 如果超时 就把当前时间放进chan\ncase &lt;- time.After(time.Second * 1):\n//Timer\ntimer := time.NewTimer(time.Second * 2)\n&lt;-timer1.C\nstop := timer.Stop()\n//Ticker\nticker := time.NewTicker(time.Millisecond * 500)\ngo func() &#123;\n    for t := range ticker.C &#123;\n        fmt.Println(\"Tick at\", t)\n    &#125;\n&#125;()\n//关闭管道 关闭之后不能写入 可以读出（已发送数据、零值）\nclose(c)\n//用range遍历 会跳出\nfor i := range c &#123;\n    fmt.Println(i)\n&#125;\n//查看chan状态\ni, ok := &lt;-c\n//可以利用chan进行同步\nfunc worker(done chan bool) &#123;\n    time.Sleep(time.Second)\n    // 通知任务已完成\n    done &lt;- true\n&#125;\nfunc main() &#123;\n    done := make(chan bool, 1)\n    go worker(done)\n    // 等待任务完成 chan中出现元素 开始执行下面的代码\n    &lt;-done\n&#125;\n\n匿名函数 //返回匿名函数\n//func(i, j string) string为函数类型 返回一个函数\n func GFG() func(i, j string) string&#123; \n\t\t//创建一个函数\n     myf := func(i, j string)string&#123; \n          return i + j + \"nhooo\"\n     &#125; \n   //返回创建的函数\n    return myf \n &#125; \n    \nfunc main() &#123; \n    value := GFG() \n    fmt.Println(value(\"Welcome \", \"to \")) \n&#125;\n//创建匿名函数并执行\nfunc(i int) &#123;\n\t\tfmt.Println(i)\n\t&#125;(2)\nfmt.Println(func(c celsius) celsius &#123; return 5 &#125;(c))\n\n\ntype//重命名类型\ntype sensor func(c celsius) kelvin\n\n\n\n\n\n多线程同步注意不像java有守护线程 main不管其他线程 \n利用sync.WaitGroup 进行同步 main等其他线程执行完之后 再推出\n注意Golang与Java不一样 Javamain执行完之后线程不会结束，Golang中main执行完协程自动结束\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"sync\"\n)\n\ntype WaitGroupWrapper struct &#123;\n\tsync.WaitGroup\n&#125;\n\ntype Consumer struct &#123;\n\tdedupMap     map[string]int\n\tconsumerName string\n&#125;\n\nfunc (c Consumer) getName() string &#123;\n\treturn c.consumerName\n&#125;\n\nfunc (c Consumer) count() &#123;\n\tfor i := 0; i &lt; 10; i++ &#123;\n\t\tc.dedupMap[c.getName()] += 1\n\t\tfmt.Println(c.getName() + \":\" + strconv.Itoa(c.dedupMap[c.getName()]))\n\t&#125;\n&#125;\n\nfunc (c Consumer) getVal() int &#123;\n\treturn c.dedupMap[c.getName()]\n&#125;\n\nfunc (c Consumer) setVal(val int) &#123;\n\tc.dedupMap[c.getName()] = val\n&#125;\n\nfunc (c Consumer) consumerMain() &#123;\n\t//wg.Add(1)\n\tc.count()\n\tdefer wg.Done()\n&#125;\n\nvar wg sync.WaitGroup\n\nfunc main() &#123;\n\tc1 := Consumer&#123;make(map[string]int), \"c1\"&#125;\n\tc2 := Consumer&#123;make(map[string]int), \"c2\"&#125;\n  //注意要在main中先加\n  wg.Add(2)\n\tgo c1.consumerMain()\n\tgo c2.consumerMain()\n  //所有协程结束main才能结束\n\twg.Wait()\n\tfmt.Println(\"123\")\n&#125;\n\n\n通道//默认没有缓冲区\nch := make(chan int)\n//设置缓冲区\nch := make(chan int, 100)\n//可以用for进行遍历 本质上是while 可以阻塞\nfor i := range ch &#123;\n  \n&#125;\n\n// Write Data\nfunc write(intChan chan int) &#123;\n\tfor i := 1; i &lt;= 50; i++ &#123;\n\t\t// 放入数据\n\t\tintChan &lt;- i\n\t\tfmt.Println(\"Write Data\", i)\n\t&#125;\n  //写完之后就可以关闭channel了 关闭之后还可以读channel\n\tclose(intChan)\n&#125;\n\n// Read data\nfunc readData(intChan chan int, exitChan chan bool) &#123;\n\n\tfor  &#123;\n\t\tv, ok :=&lt;- intChan\n\t\tif !ok&#123;\n\t\t\tbreak\n\t\t&#125;\n\t\t//time.Sleep(time.Second)\n\t\tfmt.Println(\"读到数据\",v)\n\t&#125;\n\n\t// 读取完数据后，即任务完成\n    // exitChan 是一个标志，当读完数据后，向exit中存放一个true，主线程除非取出这个true，否则不停止\n\texitChan &lt;- true\n\tclose(exitChan)\n&#125;\n\nfunc main() &#123;\n\tintChan := make(chan int, 50)\n\texitChan := make(chan bool, 1)\n\n\tgo write(intChan)\n\n\tgo readData(intChan,exitChan)\n\n\tfor  &#123;\n\t\t_, ok := &lt;-exitChan\n\t\tif !ok &#123;\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n作者：TNT\n链接：https://juejin.cn/post/6996948366378680356\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n锁// 定义一个map\nvar (\n    myMap = make(map[int]int,10)\n    // 声明一个全局变量互斥锁\n    // lock 是一个全局互斥锁\n    // sync 是包：sychorinized\n    // Mutex : 互斥\n    lock sync.Mutex\n    )\n\n// 定义一个函数计算n！\nfunc factorial(num int) &#123;\n    res :=1\n    for i := 1; i &lt;= num; i++&#123;\n        res += i\n    &#125;\n    // 将计算出的结果存入map中\n    // 访问 myMap 前，加锁\n    lock.Lock()\n    myMap[num] = res\n    // 访问完，释放所\n    lock.Unlock()\n&#125;\n\n\n\n\n反射//判断类型是否相等\nreflect.TypeOf(a).Kind() == reflect.TypeOf(b).Kind()\n//判断类型和值是否相等\nreflect.DeepEqual(a, b interface&#123;&#125;)\n//直接获得类型名\nreflect.TypeOf(a).Name()\n\n\n\n判断运行时变量类型var t interface&#123;&#125;\nt = &amp;Test&#123;\n\ta: 1,\n&#125;\np := &amp;t\nswitch t.(type) &#123;\ncase int:\n\tfmt.Println(\"int\")\ncase string:\n\tfmt.Println(\"string\")\ncase *Test:\n\tfmt.Println(\"Test\")\ndefault:\n\tfmt.Println(\"other\")\n&#125;\n\nmysqlgorm进行mysql操作\nhttps://bytedance.feishu.cn/wiki/wikcnEr2E3YXst20lmQvW0EAGUe\n//按照数据库进行定义 struct字段可以是数据库的一部分 即智能选择字段\ntype WkTenantInit struct &#123;\n\tgorm.Model\n\tTenantID string `gorm:\"column:tenant_id\"`\n&#125;\n//query 不能声明为指针类型\nvar tenantIDs []WkTenantInit\nresult := db.Model(&amp;WkTenantInit&#123;&#125;).Find(&amp;tenantIDs)\n//insert\nresult := db.Create(&amp;WkTenantInit&#123;\n\tTenantID: id,\n&#125;)\n//select\n//智能选择字段\ndb.Select([]string&#123;\"name\", \"age\"&#125;).Find(&amp;users)\ndb.Model(&amp;WkTenantInit&#123;&#125;).Find(&amp;tenantIDs)\n//where or not condition\ndb.Where(\"name = ?\", \"jinzhu\").First(&amp;user)\ndb.Where(\"name in (?)\", []string&#123;\"jinzhu\", \"jinzhu 2\"&#125;).Find(&amp;users)\ndb.Not(\"name = ?\", \"jinzhu\").First(&amp;user)\ndb.Where(\"role = ?\", \"admin\").Or(\"role = ?\", \"super_admin\").Find(&amp;users)\n//update\nresult := db.Model(User&#123;&#125;).Where(\"role = ?\", \"admin\").Updates(User&#123;Name: \"hello\", Age: 18&#125;)\n//delete\ndb.Where(\"name = ?\", \"jinzhu\").Delete(&amp;email)\n\n\nMQ//handler\ntype handler struct &#123;\n&#125;\n//注册Batchhandler\nfunc (h *Handler) HandleMessages(msgs []*types.CtxMessageExt)\n//注册handler\nfunc (h *handler) HandleMessage(ctx context.Context, msg *pb.ConsumeMessage)\n\n//生成consumer\ncfg := config.NewDefaultConsumerConfig(cc.ConsumerGroup, cc.Topic, cc.ClusterName)\n\t//有序消费\n\tcfg.Orderly = true\n\t//设置协程数\n\tcfg.WorkerNum = cc.WorkerNum\n\t//tag过滤\n\tcfg.SubExpr = cc.SubExpr\n\t//从上次的offset开始消费 可能重复\n\tcfg.ConsumeFromWhere = config.ConsumeFromWhere_CONSUME_FROM_LATEST\n\t//batch size\n\tcfg.ConsumeMessageBatchMaxSize = cc.ConsumeMessageBatchMaxSize\n\t//batch wait time\n\tcfg.ConsumeMessageBatchMaxLingerTime = cc.ConsumeMessageBatchMaxLingerTime\n\n\tr, err := consumer.NewConsumer(cfg)\n\n\tif err != nil &#123;\n\t\tlogs.Fatalf(\"%v\", err)\n\t\tpanic(err)\n\t&#125;\n\n\thandler := &amp;Handler&#123;\n\t\tuhandler,\n\t&#125;\n\n\tr.RegisterBatchHandler(handler)\n\t//start consumer here\n\t//r.Start() blocks here\n\t//if you don't want to block, perhaps call `go r.Start()`\n\tlogs.Error(\"%v\", r.Start())\n\n\tsig := make(chan os.Signal)\n\tsignal.Notify(sig, syscall.SIGTERM, syscall.SIGINT)\n\t&lt;-sig\n\tlogs.Error(\"%v\", r.Close())\n\n\n\n\n\n常用函数marshal &amp; unmarshal类似序列化\njsonData := []byte(`&#123;\n\t\"name\":\"迪丽热巴\",\n\t\"birthday\":\"1992-06-03\",\n\t\"birthPlace\":\"新疆乌鲁木齐市\",\n\t\"opus\":[\n\t\t\"《阿娜尔罕》\",\n\t\t\"《逆光之恋》\",\n\t\t\"《克拉恋人》\"\n\t]\n\t\"opus\": &#123;\n     \"Date\":\"2013\",\n     \"Title\":\"《阿娜尔罕》\"\n    &#125;\n&#125;`)\n\nvar actress Actress\n//unmarshal 之后变成了struct 里面有map和slice\nerr := json.Unmarshal(jsonData, &amp;actress)\njsonData,err := json.Marshal(actress)\nfmt.Printf(%s\", actress.Opus.Date)\n \n            \n        \n\nsorttype Person struct &#123;\n\tage  int\n\tname string\n&#125;\n\nfunc main() &#123;\n\tvar persons []Person\n\tpersons = append(persons, Person&#123;age: 1, name: \"a\"&#125;)\n\tpersons = append(persons, Person&#123;age: 1, name: \"ab\"&#125;)\n\tsort.SliceStable(persons, func(i, j int) bool &#123;\n\t\tif persons[i].age != persons[j].age &#123;\n\t\t\treturn persons[i].age &lt; persons[j].age\n\t\t&#125; else &#123;\n\t\t\treturn persons[i].name &lt; persons[j].name\n\t\t&#125;\n\t&#125;)\n\tfor _, person := range persons &#123;\n\t\tfmt.Println(person.age, person.name)\n\t&#125;\n&#125;\n\n文件读取写入package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc main() &#123;\n\tfileName := \"myfile.txt\"\n\tf, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, 0600)\n\tif err != nil &#123;\n\t\tf, err = os.Create(fileName)\n\t\tif err != nil &#123;\n\t\t\tfmt.Println(\"create failed\")\n\t\t&#125;\n\t&#125;\n\tdefer f.Close()\n\n\tif _, err = f.WriteString(\"new data that wasn't there originally\\n\"); err != nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\tdata, err := ioutil.ReadFile(fileName)\n\tif err != nil &#123;\n\t\tfmt.Println(err)\n\t&#125;\n\n\tfmt.Print(string(data))\n\n&#125;\n\n\n\n\n\n大坑//注意到底是声明指针还是结构体变量\nfunc UnmarshalJobDataMapJsonBiz(jobDataMapJson map[string][]string) (map[string][]*biz_model.JobData, error) &#123;\n\tjobDataMap := make(map[string][]*biz_model.JobData)\n\tfor jobDataID, jobDataListJson := range jobDataMapJson &#123;\n\t\tvar jobDataList []*biz_model.JobData\n\t\tfor _, jobDataJson := range jobDataListJson &#123;\n\t\t\tvar jobData biz_model.JobData\n\t\t\terr := json.Unmarshal([]byte(jobDataJson), &amp;jobData)\n\t\t\tif err != nil &#123;\n\t\t\t\treturn nil, err\n\t\t\t&#125;\n\t\t\tjobDataList = append(jobDataList, &amp;jobData)\n\t\t&#125;\n\t\tjobDataMap[jobDataID] = jobDataList\n\t&#125;\n\treturn jobDataMap, nil\n&#125;\n//注意返回的值不能直接取&amp;\n&amp;func()\n\n","slug":"GoLearning","date":"2022-11-03T03:18:12.000Z","categories_index":"learning","tags_index":"Go","author_index":"Sihan Chen"},{"id":"16dddd2808895ffe203f5dab69ce83b4","title":"PythonLearning","content":"PythonLearning记录一下Python的学习，方便以后复习，如果能帮到其他人就更好了\n\nIOinputleft,right = map(int,input().split(\" \"))\n#以list的形式存储\nl = list(map(int,input().split(\" \")))\n\noutput#python中没有类似c和java的%s %d\n#想要输出的都包括再括号中\nprint(\"&#123;&#125;,&#123;&#125;\".format(1,[1,2]))\n#保留两位小数\nprint(\"&#123;:.2f&#125;\".format(3.1415))\n#表示带符号\nprint(\"&#123;:+.2f&#125;\".format(3.1415))\n#科学计数法\nprint(\"&#123;:.2e&#125;\".format(3.1415))\n#不空行\nprint(1,end=\"\")\n\n运算符~:取反\n^:异或\nstr&#x2F;chr1.lower() upper() 方法对字符&#x2F;字符串可以直接使用 如果是字母自动生效 否则不起作用\n2.count统计字符串中字符出现次数\ns = \"123\"\ns.count(\"1\")\n#1\n\nListunhashable! 不能做dict 的key\n1.list.index得到下标如果有多个相同元素 优先第一个\n2.list.insert(index,obj)list.insert(index,obj)在原列表上进行插入，直接更改原列表，无有意义的返回值，默认返回None\nhint:replace字符串不同，由于字符串的不可变性，replace需要进行构造新的字符串，所以有有意义的返回值，返回新的字符串\n3.join split‘char’.join(seq) 将char作为分隔符将seq里面的元素连接成新的字符串\n注意seq里的元素必须是字符数组\n#互逆\n#注意seq必须是由字符(串)组成的\n&#39;,&#39;.join(seq)\ns.split(&#39;,&#39;)\n\n4.sort &amp;&amp; sorted(key&#x3D;排序方式,reverse&#x3D;是否反转 默认升序)s &#x3D; [1,5,3]\ns.sort() # s &#x3D; sorted(s) 两种方法都可以 前一种是方法，与list这种结构捆绑，在原有的list上操作，不生成新的list,后一种是库函数，返回新的list\ns &#x3D; &quot;ba&quot;\ns &#x3D; &#39;&#39;.join(sorted(s))\nl &#x3D; sorted(int(t[:2]) * 60 + int(t[-2:]) for t in timePoints)\nl.sort()\nsorted(l)\n#key可以传一个cmp函数进去（需要进行封装）\nfrom functools import cmp_to_key\ndef cmp(a,b):\n    return a - b\nl.sort(key&#x3D;cmp_to_key(cmp))\n#key 当然也可以是lambda表达式\nl.sort(key&#x3D;lambda x:x)\n\n默认升序 reverse&#x3D;True 表示逆序排列\n5.切片注意[a:b]:表示左闭右开，右边取不到，左边能取到\n6.list.count(obj)统计某个元素出现的次数\n7.list.extend(seq)seq为可迭代对象\n向右端迭代加入seq中的所有元素\n8.list.pop()默认index &#x3D; -1 即最后一个 \n注意pop里面的参数是index\n9.list.remove(obj)移除第一个默认的匹配项 \n注意remove里面的参数是element！\n10.切片s1 &#x3D; [1,2,3]\n#深拷贝!\ns2 &#x3D; s1[:]\n#可以用来反转列表！\ns3 &#x3D; s1[::-1]\n\n11.列表推导式return [1 if x &gt;&#x3D; 0.5 else 0 for x in probability]\n\n每当申请的内存用完了 如果还在加元素 就寻找一个更大的内存 并完成复制\n如果不断减少元素，就找一个更小的内存 并完成复制 以节省内存\ndict1、if xxx in dic判断的是key在不在dic里，而不是value\n2.字典相关操作dict.items() 返回turple的可迭代对象\ndict.keys()\ndict.values()\ndict.pop(key)#这里和list有区别！pop 在字典里是pop key 返回的是value 在list里是pop index 返回的是element\n\ntuplehashbale \n可以作为dict的 key 可以由list转过来\nRandom1.intrandom.randint(a,b)\n包含[a,b]\n2.charrandom.choice(string)\n实际上是选一个元素\n3.string''.join(random.sample(seq,num))\n\n队列队列插入弹出操作都是O(1)\npeek时间复杂度为O(1)\n队列完全可以用链表实现\n只需要用deque和priorityqueue\ndequefrom collections import deque\n\ndeque是python中的双端队列，既可以当作单向队列queue使用，又可以当作stack使用(stack也能用list实现)\n两端操作的时间复杂度都是O(1) 但是不能随机访问 (list可以随机访问 但是对左端操作的时间复杂度为O(n))\n感觉deque更像是链表\ndq &#x3D; deque()&#x2F;&#x2F;构造器 第一个参数为初始的元素，第二个为maxlen 默认无穷大\ndeque.append(obj)\ndeque.appendleft(obj)\ndeque.popleft()\ndeque.pop()\n#队列长度\nlen(dq)\ndq[0]\ndq[-1]\n\nPriorityQueue优先队列 默认递增队列 先出来的数value更小\n不推荐使用（没办法peek)\nimport queue\nqueue.PriorityQueue()\n#第一个参数为优先级，第二个参数是obj 需要合并成一个turple\nq.put((1,2))\n#优先get出低优先级的turple\nq.get()\n#优先队列的容量\nq.qsize()\n\n堆Python默认小顶堆! 如果需要大顶堆可以将元素取相反数 最后再取相反数回来\n插入弹出操作为O(logn):为了维护堆的性质 \n插入需要经过logn次上浮\n删除需要经过logn次下沉\n建堆O(n)\npeek时间复杂度为O(1)\n注意海量数据求TOPk(维护容量为k的堆 遍历元素 每次操作插入删除复杂度为O(logk)建堆O(k)  总共O(nlogk))\nimport heapq\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    h &#x3D; []\n    #先创建堆\n    heapq.heapify(h)\n    heapq.heappush(h,1)\n    heapq.heappush(h,4)\n    heapq.heappush(h,5)\n    print(heapq.heappop(h))\n    print(heapq.heappop(h))\n    print(heapq.heappop(h))\n    #可迭代 堆顶元素\n    print(h[0])\n\nDFS BFSDFS路径类问题 排列组合问题\n生成器和迭代器迭代器class Fib:\n    def __init__(self, n):\n        self.prev &#x3D; 0\n        self.cur &#x3D; 1\n        self.n &#x3D; n\n    def __iter__(self):\n    \treturn self\n    def __next__(self):\n        if self.n &gt; 0:\n            value &#x3D; self.cur\n            self.cur &#x3D; self.cur + self.prev\n            self.prev &#x3D; value\n            self.n -&#x3D; 1\n            return value\n    \telse:\n            raise StopIteration()\n    # 兼容python2\n    def __next__(self):\n        return self.next()\nf &#x3D; Fib(10)\nprint([i for i in f])\n    #[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\t\n\n\n生成器本质是迭代器\n在 Python 中还有一种函数，用关键字 yield 来返回值，这种函数叫生成器函数 ，函数被调用时会返回一 个生成器对象，生成器本质上还是一个迭代器(iterable)，也是用在迭代操作中，因此它有和迭代器一样的特性，唯 一的区别在于实现方式上不一样，后者更加简洁\ndef fib(n):\n    prev, curr &#x3D; 0, 1\n    while n &gt; 0:\n        n -&#x3D; 1\n        yield curr\n        prev, curr &#x3D; curr, curr + prev\nprint([i for i in fib(10)])\n\n类class heap(object):\n    #括号里可以填写要继承的父类 python语法上支持多继承\n    #python类属性的引用都需要带上self\n    &#39;&#39;&#39;mode &#x3D;&#x3D; 0 means little heap mode &#x3D;&#x3D; 1 means big heap&#39;&#39;&#39;\n    def __init__(self,heap,mode):\n        self.__heap &#x3D; []\n        self.__mode &#x3D; mode\n        for element in heap:\n            self.push(element)\n\n    def get_size(self):\n        return len(self.__heap)\n\n    def get_top(self):\n        if not heap:\n            raise IndexError()\n        return self.__heap[0]\n\n    def push(self,element):\n        p &#x3D; self.get_size()\n        self.__heap.append(element)\n        if self.__mode &#x3D;&#x3D; 0:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &gt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        else:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &lt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        ##up\n\n    def pop(self):\n        p &#x3D; self.get_size() - 1\n        self.__heap[0],self.__heap[p] &#x3D; self.__heap[p],self.__heap[0]\n        top &#x3D; self.__heap.pop()\n        p &#x3D; 0\n        size &#x3D; self.get_size()\n        if self.__mode &#x3D;&#x3D; 0:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &lt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &gt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                ##down handle index out of range\n        else:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &gt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &lt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                #down handle index out of range\n        return top\n\n和**arg代表位置参数 实质上是turple\n**arg代表关键词参数 实质上是dict\n并行赋值(多变量赋值) 、连续赋值并行赋值（多变量赋值）千万别用 超级容易错 并且错了都没法de的那种 如果光是两个int这种不可变类型勉强可用 一旦涉及指针千万别用！\ndef reverseList(self, head):\n    prev &#x3D; None\n    while head:\n        head.next, prev, head &#x3D; prev, head, head.next\n    return prev\n\n具体的过程是这样的。先执行&#x3D;右边表达式(None, head, head.next)，然后第一步把head.next=None，此时head变成了1-&gt;None；第二步，执行prev=head，这里为什么head的值时1-&gt;None而不是1-&gt;2-3-&gt;None呢，因为虽然等式先执行的右边，拿到了head，但是上一步的操作是将head修改了，由于head是一个可变对象，prev的值是1-&gt;None，最后再把head=head.next，这里为什么head.next的值又是2-&gt;3-&gt;None了呢，因为，执行右侧的表达式之后，head.next这个对象再前两步中没有被修改，一直都是2-&gt;3-&gt;None，这正是和第二步不同的地方，所以这两个写法是等同的。\n连续赋值a &#x3D; a.next &#x3D; ListNode(1)\n#等价于\n_ &#x3D; ListNode(1)  \na &#x3D; _\na.next &#x3D; _\n\nfoo &#x3D; [0]\nbar &#x3D; foo\nfoo[0] &#x3D; foo &#x3D; [1]\n\nprint(foo) #[1]\nprint(bar) #[[1]]\n\n遇到指针就别用这些东西了！\n下划线_foo\n#表示private 方法&#x2F;属性\n__foo\n#表示final 不允许进行重写\n__foo__\n#表示特殊的方法 一般会对其进行重写\nfoo_\n#表示避免和python内置关键词重复\n_\n#约定表示占位符\n\n特殊方法1.getitem:\n重写后实例变为subscriptable 支持通过实例直接当字典和list用 eg.f[1]\nOOP@注解@property\ndef foo():\n    pass\n\n之后可以将方法当作属性调用\n文件操作相对路径.&#x2F; ..&#x2F; ..&#x2F;..&#x2F; \n常用函数1.sums &#x3D; sum(x for x in l)\n\n2.json&lt;-&gt;dictj = json.dumps(d)\ntype(j)\n#已经转化为json字符串\nd = json.loads(j)\ntype(d1)\n\n3.arg注意python中有positional argument,keyword argument两种参数 规定前者在前\n传参的时候依次赋值，如果存在有默认值的参数也需要赋值，一旦出现后者，后面的赋值必须都要是keyword argument型\n4.bisectprint(bisect.bisect_left([1,2,3,4,5,6],3,1,3))\n源码\ndef bisect_left(a, x, lo&#x3D;0, hi&#x3D;None):\n    &quot;&quot;&quot;Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that \n    \n    all e in a[:i] have e &lt; x, and all e in\n    a[i:] have e &gt;&#x3D; x.  \n    \n    So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    &quot;&quot;&quot;\n\n    if lo &lt; 0:\n        raise ValueError(&#39;lo must be non-negative&#39;)\n    if hi is None:\n        hi &#x3D; len(a)\n    while lo &lt; hi:\n        mid &#x3D; (lo+hi)&#x2F;&#x2F;2\n        if a[mid] &lt; x: lo &#x3D; mid+1\n        else: hi &#x3D; mid\n    return lo\n\n如果所有数都比x小 则返回的index为len(a)！所以如果hi要写最好写len(a) 否则会与假定情况相悖\n例如\nbisect.bisect_left([0,1,3,6,10,15],25,5,5) 返回5 但是15并不大于等于25 导致出错 \nbisect.bisect_left([0,1,3,6,10,15],25,5,6) 6 &#x3D; len(a) 返回的是6 意思是整个数组中没有大于25的数 全都小于25 综上hi一定要用len(a) 或者不写hi\n\n5.ord chrx &#x3D; &#39;a&#39;\nprint(ord(x)) #61h\nprint(chr(97)) #&#39;a&#39;\n\n6.&#x3D;&#x3D;注意python&#x3D;&#x3D;如果用于对象是判断地址是否相同 需要改写__eq__\n如果用于list可以直接判断list对应元素相不相等\n如果用于dict也可以判断对应kv是否完全相同\nAnacondaconda create -n name python = 3.7\n#创建新环境\n\nconda env list\n#查看环境\n\nconda activate name\n#激活环境\n\nconda deactivate\n#退出环境\n\nconda remove --name test --all\n#删除环境\n\nconda install req \npip install req\n#安装包\n\nconda remove req\npip uninstall req\n#卸载包\n\nconda list\n#查看环境\n\n常见问题基本操作pip install pipreqs\npipreqs .&#x2F;\n#导出依赖包\npip install -r requirements.txt\n#导入依赖包\npip list --format&#x3D;freeze &gt; requirements.txt\n#导出依赖\n\n数组初始化#尽量不要用 第二重循环的意思是对列表进行浅拷贝 第一重循环对element操作 直接复制\n[[0] * l] * l\n\n#改成\n[[0 for _ in range(l)] for _ in range(l)]\n\n\n\n","slug":"PythonLearning","date":"2022-11-03T02:57:00.000Z","categories_index":"learning","tags_index":"Python","author_index":"Sihan Chen"},{"id":"9b79bd1397114c7816318b0d6a9c055c","title":"JavaLearning","content":"JavaLearning记录一下Java的学习，方便以后复习，如果能帮到其他人就更好了\n\ndetail匿名类：没有class关键词 只能实例化一个对象\n内部类\n类变量\n实例变量\n局部变量:循环体中的变量作用域仅限于该循环体\n可变参数:\n类中没有初始化的成员变量自动初始化为0，引用为null\ndouble... numbers\n\n字符可以相减\n&#39;b&#39; - &#39;a&#39; &#x3D;&#x3D; 1\n\njava未初始化数组元素有默认值！\n字符和字符串竟然可以相加！\n&quot;123&quot; + &#39;1&#39;\n\n异或^\n算数&gt;&gt;\n逻辑&gt;&gt;&gt;\n\n\n\nIOpublic class ScannerDemo &#123;\n    public static void main(String[] args) &#123;\n        Scanner scan &#x3D; new Scanner(System.in);\n        &#x2F;&#x2F; 判断是否还有输入\n        if (scan.hasNext()) &#123;\n            String str1 &#x3D; scan.next();\n            String str2 &#x3D; scan.nextLine();\n            System.out.println(&quot;输入的数据为：&quot; + str1);\n        &#125;\n        scan.close();\n        &#x2F;&#x2F;next去掉空白符 nextline读取一整行 没有回车\n\t\t&#x2F;&#x2F;不推荐用 速度太慢\n        \n        &#x2F;&#x2F;BufferedReader是Reader的子类\n        &#x2F;&#x2F;InputStreamReader读取的是字符流\n        &#x2F;&#x2F;InputStream 读取的是字节流\n        &#x2F;&#x2F;注意一个字符可能由多个字节构成\n        BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter out &#x3D; new BufferedWriter(new OutputStreamWriter(System.out));\n        String s &#x3D; in.readLine();\n        &#x2F;&#x2F;null表示没有输入了\n        out.write();\n        &#x2F;&#x2F;需要flush才能输出\n        out.flush();\n        &#x2F;&#x2F;不要忘记关通道\n        out.close();\n        &#x2F;&#x2F;速度最快 推荐使用\n    &#125;\n&#125;\n\n\n//char占用的是2个字节16位，所以一个char类型的可以存储一个汉字\nchar s = \"好\";\n\n\n\n数据类型引用\n内置 byte short int long char float double boolean\n对应的bit 8 16 32 64 16 32 64 1\n装箱&#x2F;拆箱将基本类型封&#x2F;拆成对象\n\n字符串StringBuffer线程安全 速度慢\nStringBuilder速度更快 线程不安全\nString[] array &#x3D; sentence.split(&quot; &quot;);\n        StringBuilder ans &#x3D; new StringBuilder();\n        for (String s:array) &#123;\n            String cur &#x3D; rootNode.getRoot(s);\n            if (cur !&#x3D; null) &#123;\n                ans.append(cur);\n            &#125; else &#123;\n                ans.append(s);\n                &#x2F;&#x2F;不替换\n            &#125;\n            &#x2F;&#x2F;注意空格\n            ans.append(&quot; &quot;);\n        &#125;\n        &#x2F;&#x2F;删去最后一个空格\n        ans.deleteCharAt(ans.length() - 1);\n        return ans.toString();\nString s &#x3D; &quot;123&quot;;\ns.indexOf(&quot;1&quot;);&#x2F;&#x2F;返回开始的下标 如果为0 说明是prefix\n\n控制流&#x2F;&#x2F;while\npublic class Test &#123;\n   public static void main(String[] args) &#123;\n      int x &#x3D; 10;\n      while( x &lt; 20 ) &#123;\n         System.out.print(&quot;value of x : &quot; + x );\n         x++;\n         System.out.print(&quot;\\n&quot;);\n      &#125;\n   &#125;\n&#125;\n&#x2F;&#x2F;do while\npublic class Test &#123;\n   public static void main(String[] args)&#123;\n      int x &#x3D; 10;\n \n      do&#123;\n         System.out.print(&quot;value of x : &quot; + x );\n         x++;\n         System.out.print(&quot;\\n&quot;);\n      &#125;while( x &lt; 20 );\n   &#125;\n&#125;\n&#x2F;&#x2F;for \npublic class Test &#123;\n   public static void main(String[] args) &#123;\n \n      for(int x &#x3D; 10; x &lt; 20; x &#x3D; x+1) &#123;\n         System.out.print(&quot;value of x : &quot; + x );\n         System.out.print(&quot;\\n&quot;);\n      &#125;\n   &#125;\n&#125;\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        int[] foo &#x3D; &#123;1,2,3&#125;;\n        for (int f : foo) &#123;\n            System.out.println(f);\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;switch 没有break一直往下执行 注意一定要有break\npublic class Test &#123;\n   public static void main(String args[])&#123;\n      &#x2F;&#x2F;char grade &#x3D; args[0].charAt(0);\n      char grade &#x3D; &#39;C&#39;;\n      switch(grade)\n      &#123;\n         case &#39;A&#39; :\n            System.out.println(&quot;优秀&quot;); \n            break;\n         case &#39;B&#39; :\n         case &#39;C&#39; :\n            System.out.println(&quot;良好&quot;);\n            break;\n         default :\n            System.out.println(&quot;未知等级&quot;);\n      &#125;\n      System.out.println(&quot;你的等级是 &quot; + grade);\n   &#125;\n&#125;\n\n\n数组int[] name &#x3D; &#123;&#125;;\nint[] name &#x3D; new int[5];\n\n容器List Map Array遍历可用foreach\nint[] nums &#x3D; &#123;1,2&#125;;\nArrays.stream(nums).forEach(System.out::println);\n&#x2F;&#x2F;IntStream\n&#x2F;&#x2F;函数式编程 函数接口\n\n统一遍历\nfor (int num:nums) &#123;\n    \n&#125;\n\nfor (Entry&lt;String,String&gt; entry : hashMap.entrySet()) &#123;\n    \n&#125;\n\n\ncomparator是一个interface 这里不是new接口 而是new一个实现了该接口的匿名类 {} 里是对该interface的实现\nprivate PriorityQueue&lt;int[]&gt; heap &#x3D; new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123;\n        public int compare(int[] m, int[] n) &#123;\n            return m[1] - n[1];\n        &#125;\n    &#x2F;&#x2F;\n    &#125;);\n\n\n\n\n1.Queue&#x2F;PriorityQueuejava默认小顶堆\n        Queue&lt;String&gt; foo &#x3D; new LinkedList&lt;&gt;();\n        foo.offer(&quot;123&quot;);\n\t\tfoo.poll();\n\t\tfoo.peek();\n\t\t&#x2F;&#x2F;无异常\n\t\tfoo.add(&quot;123&quot;);\n\t\tfoo.remove();\n\t\tfoo.element();\n\t\t&#x2F;&#x2F;可能有异常\n        foo.offer(&quot;4444&quot;);\n        System.out.println(foo.poll());\n        System.out.println(foo.poll());\n        System.out.println(foo.remove());\n&#x2F;&#x2F;      foo.add(“123”);如果容量满了则会报异常\n&#x2F;&#x2F;尽量用offer poll\n\n2.ArrayList&#x2F;LinkedListArrayList&lt;type&gt; l &#x3D; new ArrayList();\nl.add();\nl.addAll();\nl.contains();\nl.containsAll();\nl.get();\nl.indexOf();\nl.clone();\nl.size();\nl.remove();\nl.removeAll();\nl.removeIf(e -&gt; e &#x3D;&#x3D; 8);\n\nif (!emaillist.isEmpty()) &#123;\n            Collections.sort(emaillist, new Comparator&lt;Email&gt;() &#123;\n                @Override\n                public int compare(Email o1, Email o2) &#123;\n                    return o1.getUsername().toLowerCase().compareTo(o2.getUsername().toLowerCase());\n                &#125;\n            &#125;);\n        &#125;\nCollections.sort(sites);  &#x2F;&#x2F; 字母排序\n&#x2F;&#x2F;深copy\nArrayList&lt;Integer&gt; num &#x3D; (ArrayList&lt;Integer&gt;) myNumbers.clone();&#x2F;&#x2F;clone\nArrayList&lt;Integer&gt; n &#x3D; new ArrayList&lt;&gt;(num);&#x2F;&#x2F;clone\n\n\n\n3.HashMap&#x2F;HashSet&#x2F;LinkedHashmap&#x2F;TreeMap无序 非线程安全\nHashMap和LinkedHashMap使用接口完全一样TreeMap\nm.put(k,v);\nm.get(k);\nm.remove(k);\nm.clear();\nm.size();\nm.keySet();\nm.values();\nm.entrySet();\nm.containsKey();\nm.containsValue();\n\nHashSet&#x2F;TreeSet\ns.add();\ns.addAll();\ns.remove();\ns.size();\n\nTreeSet&#x2F;TreeMap\nTreeSet&lt;String&gt; s &#x3D; new TreeSet&lt;&gt;();\ns.floor();\ns.ceiling();\nTreeMap&lt;String,String&gt; m &#x3D; new TreeMap&lt;&gt;();\nm.floorEntry();\nm.ceilingEntry();\n\n\n\n4.HashSet&#x2F;TreeSets.add();\ns.addAll();\ns.remove();\ns.size();\n\n5.stackStack&lt;type&gt; s &#x3D; new Stack&lt;&gt;();\ns.push();\ns.pop();\n\n\n\n迭代器        Iterator&lt;String&gt; ite&#x3D;list.iterator();\n        while(ite.hasNext())&#x2F;&#x2F;判断下一个元素之后有值\n        &#123;\n            System.out.println(ite.next());\n        &#125;\n\nIterator&lt;Map.Entry&lt;String, String&gt;&gt; it &#x3D; map.entrySet().iterator();\n        while (it.hasNext()) &#123;\n            Map.Entry&lt;String, String&gt; entry &#x3D; it.next();\n            System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());\n        &#125;\nite.next();\nite.hasNext();\nite.remove();\n\n去重ArrayList collect &#x3D;(ArrayList)Stream.of(a,b).flatMap(Collection::stream).distinct().collect(Collectors.toList());\n\n排序   @Override\n   public int compareTo(Object o) &#123;\n       Error error &#x3D; (Error) o;\n       if (this.getLine() &lt; error.getLine()) &#123;\n           return -1;\n       &#125; else if (this.getLine() &#x3D;&#x3D; error.getLine()) &#123;\n           return 0;\n       &#125; else &#123;\n           return 1;\n       &#125;\n   &#125;&#x2F;&#x2F;重写方法\nCollections.sort(errorList);\n   Collections.sort(list, new Comparator&lt;Integer&gt;() &#123;\n         @Override\n         public int compare(Integer o1, Integer o2) &#123;\n             return 0;\n         &#125;\n     &#125;);\nArrays.sort(a,new Comparator&lt;int[]&gt;() &#123;\n       &#x2F;&#x2F;Comparator里的类型为要排序的对象的类型\n           public int compare(int[] o1,int[] o2) &#123;\n               if (o1[0] - o2[0] !&#x3D; 0) &#123;\n                   return o1[0] - o2[0];\n               &#125; else &#123;\n                   return o1[1] - o2[1];\n               &#125;\n           &#125;\n       &#125;);\n\n泛型\n通配符 ？不能超过上层类型\n   public static &lt; E &gt; void printArray( E[] inputArray )\n   &#123;\n      &#x2F;&#x2F; 输出数组元素            \n         for ( E element : inputArray )&#123;        \n            System.out.printf( &quot;%s &quot;, element );\n         &#125;\n         System.out.println();\n    &#125;\n\n   public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z)\n   &#123;                     \n      T max &#x3D; x; &#x2F;&#x2F; 假设x是初始最大值\n      if ( y.compareTo( max ) &gt; 0 )&#123;\n         max &#x3D; y; &#x2F;&#x2F;y 更大\n      &#125;\n      if ( z.compareTo( max ) &gt; 0 )&#123;\n         max &#x3D; z; &#x2F;&#x2F; 现在 z 更大           \n      &#125;\n      return max; &#x2F;&#x2F; 返回最大对象\n   &#125;\n\nclass Box&lt;T&gt; &#123;\n   \n  private T t;\n \n  public void add(T t) &#123;\n    this.t &#x3D; t;\n  &#125;\n \n  public T get() &#123;\n    return t;\n  &#125;\n \n  public static void main(String[] args) &#123;\n    Box&lt;Integer&gt; integerBox &#x3D; new Box&lt;Integer&gt;();\n    Box&lt;String&gt; stringBox &#x3D; new Box&lt;String&gt;();\n \n    integerBox.add(new Integer(10));\n    stringBox.add(new String(&quot;菜鸟教程&quot;));\n \n    System.out.printf(&quot;整型值为 :%d\\n\\n&quot;, integerBox.get());\n    System.out.printf(&quot;字符串为 :%s\\n&quot;, stringBox.get());\n  &#125;\n&#125;\n\n   public static void getData(List&lt;?&gt; data) &#123;\n      System.out.println(&quot;data :&quot; + data.get(0));\n   &#125;\n\n\n\n序列化Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。\n将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。\n反序列化的时候，必须能够找到对应字节码的类\ntransient 反序列初始为0\n多线程\n\n等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。\n同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。\n其他阻塞（虽然阻塞但是没有获得锁）：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。\n\n守护线程：其他所有线程结束后 JVM退出 不关心守护线程的运行情况 JVM退出后守护线程会自动关闭 用来执行后台任务\n优先级不保证执行顺序\n只需要自己执行start（）,run能隐式执行\nstart会创建线程 run不会 只是一个普通方法\n创建线程的方式(都需要实现run方法 calllable是call方法):\n\nimplements runnable\nextends Thread\nimplements callable （可以有返回值 可以抛异常）\n\n修饰符限定范围\ndefault (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\nprivate : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\npublic : 对所有类可见。使用对象：类、接口、变量、方法\nprotected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\n\n\n字符串&#x2F;字符string不可修改\ns.charAt(num);\ns.length();\ns.equals();\ns.toLowerCase();\n&#x2F;&#x2F;+ 拼接\ns.compareTo();\ns.indexOf(String str,int index)\nString replace(char oldChar, char newChar)\nString substring(int beginIndex, int endIndex)\nString toString()\ncontains(CharSequence chars)\n&#x2F;&#x2F;格式化字符串输出\nString.format(&quot;XX&quot; + &quot;YY&quot; + &quot;%d&quot;,v);\nString a &#x3D; &quot;123&quot;;&#x2F;&#x2F;常量池\nString b &#x3D; new String(&quot;123&quot;);&#x2F;&#x2F;堆\n\n\n常用库Math.floor;\nMath.round;\nMath.ceil;\n\n正则表达式        String s &#x3D; &quot;W10&quot;;\n        String pattern &#x3D; &quot;(A|W|D|S)(?&lt;num&gt;\\\\d&#123;2&#125;)&quot;;\n        Pattern p &#x3D; Pattern.compile(pattern);\n        Matcher m &#x3D; p.matcher(s);\n        if (m.find()) &#123;\n&#x2F;&#x2F;            Integer n &#x3D; m.group(2);\n            System.out.println(m.group(2));\n        &#125;\n        String a &#x3D; &quot;aaabbaaaa&quot;;\n        String pattern &#x3D; &quot;.*(...).*\\\\1.*&quot;;\n&#x2F;&#x2F;\\\\1表示第一个group 要和第一个group相同\n        Pattern p &#x3D; Pattern.compile(pattern);\n        Matcher m &#x3D; p.matcher(a);\n        System.out.println(m.find());\n\n随机数private Random random &#x3D; new Random();\n&#x2F;&#x2F;[0,total)\nint x &#x3D; (int) random.nextInt(total - 1) * total + 1;\n\nArrayint[] a &#x3D; new int[] &#123;1,2&#125;;\nSystem.out.println(Arrays.stream(a).max().getAsInt());\n&#x2F;&#x2F;串行流没有for循环快 并行流比for快\nint[][] a &#x3D; &#123;&#123;1,2&#125;,&#123;4,3&#125;,&#123;1,3&#125;&#125;;\n        Arrays.sort(a,new Comparator&lt;int[]&gt;() &#123;\n            public int compare(int[] o1,int[] o2) &#123;\n                if (o1[0] - o2[0] !&#x3D; 0) &#123;\n                    return o1[0] - o2[0];\n                &#125; else &#123;\n                    return o1[1] - o2[1];\n                &#125;\n            &#125;\n        &#125;);\n&#x2F;&#x2F;排序\n        List&lt;int[]&gt; b &#x3D; Arrays.asList(a);\n        a &#x3D; b.toArray(new int[b.size()][]);\n\n\n\n文件IOtry (BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(\"output.txt\"))) &#123;\n            Iterator iterator = wordAnalysisList.iterator();\n            while (iterator.hasNext()) &#123;\n                symbol = (HashMap&lt;String, String>) iterator.next();\n                if (symbol.get(\"class\").equals(\"ANNO\")) &#123;\n                    continue;\n                &#125;\n                bufferedOutputStream.write((String.format(\"%s %s\\n\",symbol.get(\"class\"),symbol.get(\"word\"))).getBytes());\n            &#125;\n            bufferedOutputStream.flush();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\ntry &#123;\n            FileWriter writer = new FileWriter(writeFile);\n            Iterator iterator = wordAnalysisList.iterator();\n            while (iterator.hasNext()) &#123;\n                symbol = (HashMap&lt;String, String>) iterator.next();\n                if (symbol.get(\"class\").equals(\"ANNO\")) &#123;\n                    continue;\n                &#125;\n                writer.write(String.format(\"%s %s\\n\",symbol.get(\"class\"),symbol.get(\"word\")));\n            &#125;\n            writer.flush();\n            writer.close();\n        &#125; catch (IOException e) &#123;\n            e.pintStackTrace();\n        &#125;\n\n\n异常\ntry &#123;\n    file &#x3D; new FileInputStream(fileName);\n    x &#x3D; (byte) file.read();\n&#125; catch(FileNotFoundException f) &#123; &#x2F;&#x2F; Not valid!\n    f.printStackTrace();\n    return -1;\n&#125; catch(IOException i) &#123;\n    i.printStackTrace();\n    return -1;\n&#125;\n\nException又分为两种：\n\nJVM(Java**虚拟机)** 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。\n程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。\n\n函数式编程{}里面是匿名函数\nmap.forEach((key,value) -&gt; &#123;\n            if (heap.size() &lt; k) &#123;\n                heap.offer(new int[] &#123;key,value&#125;);\n            &#125; else if (value &gt; heap.peek()[1]) &#123;\n                heap.poll();\n                heap.offer(new int[] &#123;key,value&#125;);\n            &#125;\n            &#x2F;&#x2F;匿名函数\n        &#125;);\n\nPriorityQueue&lt;int[]&gt; heap &#x3D; new PriorityQueue&lt;&gt;(new &lt;int[]&gt;() &#123;\n            public int compare(int[] m, int[] n) &#123;\n                return m[1] - n[1];\n            &#125;\n        &#125;);\n表示实现Comparator接口的匿名类\n\nlambda表达式PriorityQueue&lt;int[]&gt; pq &#x3D; new PriorityQueue&lt;int[]&gt;((a,b)-&gt;nums1[a[0]]+nums2[a[1]]-nums1[b[0]]-nums2[b[1]]);\n&#x2F;&#x2F;() -&gt; 返回值 括号为传入参数\n\n\n\nOO相关继承extends 默认继承object\nsuper this\npublic class Animal &#123; \n    private String name;  \n    private int id; \n    public Animal(String myName, int myid) &#123; \n        name &#x3D; myName; \n        id &#x3D; myid;\n    &#125; \n    public void eat()&#123; \n        System.out.println(name+&quot;正在吃&quot;); \n    &#125;\n&#125;\npublic class Penguin extends Animal &#123; \n    public Penguin(String myName, int myid) &#123; \n        super(myName, myid); \n    &#125; \n&#125;\n\n\n\n\n接口implements\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n抽象类&#x2F;方法abstract \n抽象方法无方法体\n必须被继承才能使用 必须重写抽象类的抽象方法 否则也必须是抽象类\npublic abstract class Employee\n&#123;\n   private String name;\n   private String address;\n   private int number;\n   \n   public abstract double computePay();\n   \n   &#x2F;&#x2F;其余代码\n&#125;\n\n\n\n重载和重写重载（overload）：必须拥有不同的参数列表（名字还是相同）返回类型可以不同 方法体当然可以不同 即函数签名需不一样\n\n重写(override):只改变方法体 函数签名需要完全相同\n\n","slug":"JavaLearning","date":"2022-11-03T02:56:52.000Z","categories_index":"learning","tags_index":"Java","author_index":"Sihan Chen"},{"id":"043ea5846f4ce7e1aaad5107c0f5a6a3","title":"CppLearning","content":"C++Learning记录一下Cpp的学习，方便以后复习，如果能帮到其他人就更好了\n\n1.基本语法1.命名空间在C&#x2F;C++中，变量、函数和类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染。\n定义：namespace name1 &#123;\n  int a &#x3D; 5;\n  int add(int b, int c)&#123;\n    return b + c;\n  &#125;\n  namespace name2 &#123;\n    int a &#x3D; 3;\n    int sub(int b,int c) &#123;\n      return b - c;\n    &#125;\n  &#125;\n    &#x2F;&#x2F;函数\n&#125;\n\n可嵌套定义，如果有多个同名的命名空间会自动合并\n使用：using namespace name1;\n&#x2F;&#x2F;命名空间全部导入\nusing name1::a;\n&#x2F;&#x2F;此种声明下命名空间name1下的变量a就能直接使用\nusing name1::name2::b;\nint main() &#123;\n  printf(&quot;%d\\n&quot;,a);\n  return 0;\n&#125;\n\n当导入的命名空间中有重复的变量或者函数时会报错\nusing namespace std;\n&#x2F;&#x2F;之后写cout cin都可以直接写而不用 std::cin std::cout\n&#x2F;&#x2F;不提前导入的话之后每次使用都得带上命名空间名字和双冒号\n&#x2F;&#x2F;告诉编辑器使用命名空间\n\n范围解析运算符:::\n2.关键词volatile：提醒编译器该变量所在内存可能会因为其他因素改变，每次使用需要从内存中重新取值\nexplicit： 禁止隐式转换\nmutable：对象中的const函数不能改变对象成员，但是对于mutable声明的成员变量可以在const函数里面改变\n2.基本数据类型\n\n\n类型\n关键字\n\n\n\n布尔型\nbool\n\n\n字符型\nchar\n\n\n整型\nint\n\n\n浮点型\nfloat\n\n\n双浮点型\ndouble\n\n\n无类型\nvoid\n\n\n宽字符型\nwchar_t\n\n\ntypedef short int wchar_t;\n&#x2F;&#x2F;2B\n\n修饰类型：\n\nsigned\nunsigned\nlong\n\nlong int &#x3D;&#x3D; 4B short int &#x3D;&#x3D; 2B double &#x3D; 8B long double &#x3D; 16B\n\nshort\n\nConst:不可更改\nVolatile:不要优化 每次使用时从内存上拿取最新的值\nrestrict:？？？？？\n3.typedef用法：\ntypedef type newname\n&#x2F;&#x2F;将已有的type名定义为新的name\n\n4.枚举enum 枚举名&#123; \n     标识符[&#x3D;整型常数], \n     标识符[&#x3D;整型常数], \n... \n    标识符[&#x3D;整型常数]\n&#125; 枚举变量;\n\n如果枚举变量在定义的时候没有赋值，默认从0开始\n使用\ncolor c1,c2;\nc1 &#x3D; blue;\n\n5.声明和初始化只有声明了编译过程才能进行\n初始化与否不影响编译\n（函数和变量）\n当局部变量和全局变量名字相同时，优先使用局部变量（具有更高的优先级）\n全局变量会自动初始化\n变量：\n\n静态变量：\n\n静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。\n静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。\nclass foo &#123;\n    static void foo() &#123;\n        &#x2F;&#x2F;body\n    &#125;\n&#125;;\nint main() &#123;\n    foo::foo();\n&#125;\n\n\n实例变量\n全局变量\n局部变量\n\n6.define const#define a 1\ncont int b &#x3D; 1;\n\n7.存储类\nregister：意味着变量可能存储在寄存器中，多用于计数器，可大大加速\n\nstatic：存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁\n1.在函数中对修饰局部变量可以在函数调用之间保持局部变量的值\n2.修饰类的静态属性\n3.修饰全局变量，作用域限制在声明他的文件里\n\nextern：使一个文件中定义的变量或者函数可以在另一个文件中使用\n\nmutable：\n\nThread_local:\n\n\n8.运算符\n算数运算符\n关系运算符\n逻辑运算符\n位运算符\n赋值运算符（含有等号的运算符）\n杂项运算符\n\n9.函数1.函数传参\n传值调用\n指针调用\n引用调用\n\n2.参数默认值类似python\n3.lambda函数与表达式[capture](parameters)-&gt;return-type&#123;body&#125;\n\n10.库函数1.随机数srand(2);\n&#x2F;&#x2F;随机数种子\nint a &#x3D; rand();\n\n2.timesrand(time(NULL));\n&#x2F;&#x2F;随机数种子\n\n3.setwsetw(n)函数只对紧接着的输出产生作用 n表示宽度\n4.setfillsetfill(char c)\n&#x2F;&#x2F;用字符来填充空白\n\n5.字符串函数strcpy(s1,s2)\n&#x2F;&#x2F;s2复制到s1中 不管原来s1是什么内容直接覆盖\nstrlen(s1)\n&#x2F;&#x2F;返回s1长度 这里的长度不包括&#39;\\0&#39;\nstrcmp(s1,s2)\n&#x2F;&#x2F;若s1 &gt; s2则返回正数 相等则返回0 反之则返回负数 对于string类型的字符串不能使用\nstrchr(s1,ch);\n&#x2F;&#x2F;返回指针指向s1中ch第一次出现的位置 从左开始\nstrcat(s1,s2)\n&#x2F;&#x2F;将s2接在s1后面 注意只能对char name[]的字符数组使用 对于string类型的字符串（C++新增）可以直接使用 &#39;+&#39;连接\nstrstr(s1,s2)\n&#x2F;&#x2F;返回一个指针表示s2在s1中的匹配 如果没有匹配则返回\n\nchar s1[] &#x3D; &quot;abc&quot;;\ncout &lt;&lt; s1 &lt;&lt; endl;\n&#x2F;&#x2F;打印字符串指针 就是从该位置开始打印字符串\ns1 &#x3D; s2;\n&#x2F;&#x2F;不管是string还是char s[]都可以直接改变指针引用 \n\n11.指针数组是常量指针\n12.引用类型引用很容易与指针混淆，它们之间有三个主要的不同：\n\n不存在空引用。引用必须连接到一块合法的内存。\n一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n引用必须在创建时被初始化。指针可以在任何时间被初始化。\n\n试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签\nint a &#x3D; 5;\nint &amp;b &#x3D; a;\ncout &lt;&lt; a &lt;&lt;endl;\n&#x2F;&#x2F;5\ncout &lt;&lt; b &lt;&lt; endl;\n&#x2F;&#x2F;5\na &#x3D;&#x3D; b;\n\n13.字符流C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。\n\n\n\n头文件\n函数和描述\n\n\n\n\n该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。\n\n\n\n该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I&#x2F;O 有用的服务。\n\n\n\n该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。\n\n\n流提取运算符 &gt;&gt; 在一个语句中可以多次使用\nstring name;\ncin &gt;&gt; name;&#x2F;&#x2F;标准输入流\ncout &lt;&lt; name &lt;&lt; endl;&#x2F;&#x2F;标准输出流\ncerr &lt;&lt; &quot;wrong&quot;;&#x2F;&#x2F;标准错误流\nclog &lt;&lt; &quot;done&quot;;&#x2F;&#x2F;标准日志流\n\n预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。\n clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。\n14.结构struct type_name &#123;\n    member_type1 member_name1;\n    member_type2 member_name2;\n    member_type3 member_name3;\n&#125;;\n&#x2F;*or\ntypedef struct type_name &#123;\n    member_type1 member_name1;\n    member_type2 member_name2;\n    member_type3 member_name3;\n&#125;object_names;*&#x2F;\ntype_name name1,name2;\ncout &lt;&lt; name1.member_name1 &lt;&lt; endl;\ntype_name *ptrname;\nptrname &#x3D; &amp;name2;\ncout &lt;&lt; name2-&gt;member_name1 &lt;&lt; endl;\n\ntypedef long int *pint32;\n \npint32 x, y, z;\n\n15.类与对象class name &#123;\n  modifier:\n    type name1;\n    type name2;\n  modifier:\n    returntype func(type para);\n  &#x2F;&#x2F; func signature\n  modifier:\n  \treturntype func(type para) &#123;\n      &#x2F;&#x2F;body also ok!\n    &#125;\n&#125;;\ntype name::func(type para) &#123;\n  &#x2F;&#x2F;func body\n&#125;\n\n注意与java的区别与联系\n\n相同的修饰符可以只写一次\n方法在class域里只写头也行 带上方法体也行\n当参数名和属性成员名相同时，成员名加上this以达到区分\n没有任何修饰符时默认private\n\n成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。\n注意C++里面类的实例化有两种方法：\nclass foo &#123;\n    &#x2F;&#x2F;class\n&#125;;\nint main() &#123;\n    foo foo1;&#x2F;&#x2F;类似结构体\n    &#x2F;&#x2F;这种实例化方法把对象建立在栈上 自动调用构造函数和析构函数\n    foo *foo1 &#x3D; new foo;&#x2F;&#x2F;类似结构体指针\n    &#x2F;&#x2F;这种实例化方式是类指针 建立在堆上 不会自动回收 要手动delete 否则发生内存泄漏\n&#125;\n\n注意this指针和类指针的区别\n构造函数：默认public\n使用初始化列表来初始化字段：\nC::C( double a, double b, double c): X(a), Y(b), Z(c)\n&#123;  .... &#125;;\n\n\n\n析构函数：析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。\nclass foo &#123;\n    public:\n\t\tfoo() &#123;\n            &#x2F;&#x2F;body\n        &#125;\n    \t~foo() &#123;\n            &#x2F;&#x2F;body\n        &#125;\n&#125;;\n\n拷贝构造函数：拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：\n\n通过使用另一个同类型的对象来初始化新创建的对象。\n复制对象把它作为参数传递给函数。\n复制对象，并从函数返回这个对象。\n\n16.友元函数\nC++中引入友元函数，是为在该类中提供一个对外（除了他自己意外）访问的窗口;\n这个友元函数他不属于该类的成员函数，他是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员。\n将数据和处理数据的函数封装在一起，构成类，实现了数据的隐藏，无疑是面向对象程序设计的一大优点。但是有时候封装不是绝对的。\n友元函数提供了不同类或对象的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通俗的说，友元关系就是一个类主动声明哪些类或函数是它的朋友，进而给它们提供对本类的访问特性。也就是说，通过友元关系，一个普通函数或者类的成员函数可以访问封装于另外一个类中的数据。\n从一定程度上讲，友元是对数据隐藏和封装的破坏，但是为了数据共享，提高程序的效率和可读性，很多情况下这种小的破坏是必要的。\n在一个类中，利用关键字friend将其它函数或类声明为友元。如果友元是一般函数或类的成员函数，称为友元函数。如果友元是一个类，则称为友元类。友元类的所有成员函数都自动称为友元函数。\n成员函数有this指针，而友元函数没有this指针。\n友元函数是不能被继承的，就像父亲的朋友未必是儿子的朋友。\n\n1.类中通过使用关键字friend 来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。\n2.一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。\n3.友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。\n4.友元函数在调用上同一般函数一样，不必通过对对象进行引用。\n17.内联函数C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。\n对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。\n如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。\n在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。\n18.继承三种继承：\n\n1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private\n2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private\n3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private\n\n我们几乎不使用 protected 或 private 继承，通常使用 public 继承\n\n\n\n访问\npublic\nprotected\nprivate\n\n\n\n同一个类\nyes\nyes\nyes\n\n\n派生类\nyes\nyes\nno\n\n\n外部的类\nyes\nno\nno\n\n\nC++支持多继承，具体使用方法是：\nclass foo1:access-specifier classname....&lt;list&gt;\n\n19.重载函数重载C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。\n重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。\n当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。\n函数的签名是由函数的参数和函数的名字决定的与返回值无关\n运算符重载class Box &#123;\n    public:\n    \tBox operator+(const Box&amp;b) &#123;\n             Box box;\n             box.length &#x3D; this-&gt;length + b.length;\n             box.breadth &#x3D; this-&gt;breadth + b.breadth;\n             box.height &#x3D; this-&gt;height + b.height;\n             return box;\n        &#125;\n&#125;\n\n\n\n可重载运算符\n\n\n双目算术运算符\n+ (加)，-(减)，*(乘)，&#x2F;(除)，% (取模)\n\n\n\n关系运算符\n&#x3D;&#x3D;(等于)，!&#x3D; (不等于)，&lt; (小于)，&gt; (大于)，&lt;&#x3D;(小于等于)，&gt;&#x3D;(大于等于)\n\n\n逻辑运算符\n||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)\n\n\n单目运算符\n+ (正)，-(负)，*(指针)，&amp;(取地址)\n\n\n自增自减运算符\n++(自增)，–(自减)\n\n\n位运算符\n| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)\n\n\n赋值运算符\n&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; , % &#x3D; , &amp;&#x3D;, |&#x3D;, ^&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D;\n\n\n空间申请与释放\nnew, delete, new[ ] , delete[]\n\n\n其他运算符\n()(函数调用)，**-&gt;(成员访问)，,(逗号)，[]**(下标)\n\n\n不可重载运算符\n**.**：成员访问运算符\n.*, **-&gt;***：成员指针访问运算符\n**::**：域运算符\nsizeof：长度运算符\n**?:**：条件运算符\n**#**： 预处理符号\n\n虚函数：导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。\n虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。\n纯虚函数要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。\n如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的.\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。\n因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类。\nvirtual int area() &#x3D; 0;\n\n20.文件和流\n\n\n模式标志\n描述\n\n\n\nios::app\n追加模式。所有写入都追加到文件末尾。\n\n\nios::ate\n文件打开后定位到文件末尾。\n\n\nios::in\n打开文件用于读取。\n\n\nios::out\n打开文件用于写入。\n\n\nios::trunc\n如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。\n\n\n打开文件void open(const char *filename, ios::openmode mode);\n\n关闭文件void close();\n\n写入文件在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。\n读取文件在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。\nhint：\nint main() &#123;\n    ofstream file;\n    file.open(&quot;file.txt&quot;,ios::app);\n    file &lt;&lt; &quot;fuck&quot;;\n    fstream infile;\n    infile.open(&quot;file.txt&quot;,ios::in);\n    string s &#x3D; &quot;&quot;;\n    infile &gt;&gt; s;\n    cout &lt;&lt; s;\n    file.close();\n&#125;\n&#x2F;&#x2F;需要重新以读模式打开文件\n\n文件位置指针istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。\nseekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。\n文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。\nint main() &#123;\n    fstream outFile;\n    outFile.open(&quot;file.txt&quot;,ios::trunc);\n    outFile.seekp(4);\n    cout &lt;&lt; outFile.tellp() &lt;&lt; endl;\n    outFile &lt;&lt; &quot;foofoofoo&quot;;\n    outFile.close();\n    ifstream inFile;\n    inFile.open(&quot;file.txt&quot;,ios::in);\n    string s;\n    inFile.seekg(-1,ios::end);\n    cout &lt;&lt; inFile.tellg() &lt;&lt; endl;\n    inFile &gt;&gt; s;\n    cout &lt;&lt; s &lt;&lt; endl;\n    inFile.close();\n    return 0;\n&#125;\n&#x2F;&#x2F;C++读写指针是分开的\n&#x2F;&#x2F;输出：\n-1\n12\no\n  foofoofoo\n  &#x2F;&#x2F;tellp tellg\n  &#x2F;&#x2F;seekp seekg\n  &#x2F;&#x2F;ios::beg ios::cur ios::end\n\n21.异常处理\n\n\n异常\n描述\n\n\n\nstd::exception\n该异常是所有标准 C++ 异常的父类。\n\n\nstd::bad_alloc\n该异常可以通过 new 抛出。\n\n\nstd::bad_cast\n该异常可以通过 dynamic_cast 抛出。\n\n\nstd::bad_exception\n这在处理 C++ 程序中无法预期的异常时非常有用。\n\n\nstd::bad_typeid\n该异常可以通过 typeid 抛出。\n\n\nstd::logic_error\n理论上可以通过读取代码来检测到的异常。\n\n\nstd::domain_error\n当使用了一个无效的数学域时，会抛出该异常。\n\n\nstd::invalid_argument\n当使用了无效的参数时，会抛出该异常。\n\n\nstd::length_error\n当创建了太长的 std::string 时，会抛出该异常。\n\n\nstd::out_of_range\n该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。\n\n\nstd::runtime_error\n理论上不可以通过读取代码来检测到的异常。\n\n\nstd::overflow_error\n当发生数学上溢时，会抛出该异常。\n\n\nstd::range_error\n当尝试存储超出范围的值时，会抛出该异常。\n\n\nstd::underflow_error\n当发生数学下溢时，会抛出该异常。\n\n\n在这里，what() 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因\n例子：\nstruct MyException : public exception\n&#123;\n  const char * what () const throw ()\n  &#123;\n    return &quot;C++ Exception&quot;;\n  &#125;\n&#125;;\n \nint main()\n&#123;\n  try\n  &#123;\n    throw MyException();\n  &#125;\n  catch(MyException&amp; e)\n  &#123;\n    std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n  &#125;\n  catch(std::exception&amp; e)\n  &#123;\n    &#x2F;&#x2F;其他的错误\n  &#125;\n\n22.动态内存\n栈：在函数内部声明的所有变量都将占用栈内存。\n堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。\n\nnewnew data-type;\n\ndouble *ptr;\nptr &#x3D; new double;\n*ptr &#x3D; 1.2;\ncout &lt;&lt; *ptr;\n\ndeletedelete ptr;\n\n数组申请和释放的例子：\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main()\n&#123;   \n    int i,j,k;   &#x2F;&#x2F; p[2][3][4]\n    \n    int ***p;\n    p &#x3D; new int **[2]; \n    for(i&#x3D;0; i&lt;2; i++) \n    &#123; \n        p[i]&#x3D;new int *[3]; \n        for(j&#x3D;0; j&lt;3; j++) \n            p[i][j]&#x3D;new int[4]; \n    &#125;\n    \n    &#x2F;&#x2F;输出 p[i][j][k] 三维数据\n    for(i&#x3D;0; i&lt;2; i++)   \n    &#123;\n        for(j&#x3D;0; j&lt;3; j++)   \n        &#123; \n            for(k&#x3D;0;k&lt;4;k++)\n            &#123; \n                p[i][j][k]&#x3D;i+j+k;\n                cout&lt;&lt;p[i][j][k]&lt;&lt;&quot; &quot;;\n            &#125;\n            cout&lt;&lt;endl;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n    \n    &#x2F;&#x2F; 释放内存\n    for(i&#x3D;0; i&lt;2; i++) \n    &#123;\n        for(j&#x3D;0; j&lt;3; j++) \n        &#123;   \n            delete [] p[i][j];   \n        &#125;   \n    &#125;       \n    for(i&#x3D;0; i&lt;2; i++)   \n    &#123;       \n        delete [] p[i];   \n    &#125;   \n    delete [] p;  \n    return 0;\n&#125;\n\n23.模版函数模版template &lt;typename T&gt;\nT funcname (T a, T b) &#123;\n  &#x2F;&#x2F;body\n&#125;\n\n类模版template &lt;class T&gt;\nclass Stack &#123; \n  private: \n    vector&lt;T&gt; elems;     &#x2F;&#x2F; 元素 \n \n  public: \n    void push(T const&amp;);  &#x2F;&#x2F; 入栈\n    void pop();               &#x2F;&#x2F; 出栈\n    T top() const;            &#x2F;&#x2F; 返回栈顶元素\n    bool empty() const&#123;       &#x2F;&#x2F; 如果为空则返回真。\n        return elems.empty(); \n    &#125; \n&#125;; \n\n24.预处理器预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。\n所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。\ndefine\n宏常量\n\n宏函数\n\n\n条件编译#ifdef\n&#x2F;&#x2F;body\n#endif\n#if\n&#x2F;&#x2F;body\n#endif\n\n#和##运算符#define MKSTR( x ) #x\n&#x2F;&#x2F;用于转化为字符串\n#define concat(a, b) a ## b\n&#x2F;&#x2F;连接ab变量名成为新的变量名\n\n\n\n25.信号处理信号定义在csignal库中\n信号是由操作系统传给进程的中断，会提早终止一个程序。\n有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。\n信号\n\n\n信号\n描述\n\n\n\nSIGABRT\n程序的异常终止，如调用 abort。\n\n\nSIGFPE\n错误的算术运算，比如除以零或导致溢出的操作。\n\n\nSIGILL\n检测非法指令。\n\n\nSIGINT\n程序终止(interrupt)信号。\n\n\nSIGSEGV\n非法访问内存。\n\n\nSIGTERM\n发送到程序的终止请求。\n\n\nsignal将信号和相应需要执行的操作绑定，当出现对应信号时执行相应的操作\n#include &lt;csignal&gt;\nsignal(registered signal, signal handler)\n&#x2F;&#x2F;signal handler是自己写的函数\nint raise (signal sig);\n\nvoid signalHandler( int signum )\n&#123;\n    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\\n&quot;;\n \n    &#x2F;&#x2F; 清理并关闭\n    &#x2F;&#x2F; 终止程序  \n \n   exit(signum);  \n&#125;\nint main ()\n&#123;\n    &#x2F;&#x2F; 注册信号 SIGINT 和信号处理程序\n    signal(SIGINT, signalHandler);  \n \n    while(1)&#123;\n       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;\n       sleep(1);\n    &#125;\n \n    return 0;\n&#125;\n\nraise抛出对应的信号\n26.多线程先埋坑\n27.web编程先埋坑\n28.STL\n\n\n组件\n描述\n\n\n\n容器（Containers）\n容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。\n\n\n算法（Algorithms）\n算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。\n\n\n迭代器（iterators）\n迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。\n\n\nvecint main() &#123;\n  vector&lt;int&gt; vec;\n  vec.push_back();\n  &#x2F;&#x2F;类似于python append 从尾部加入\n  vector&lt;int&gt;::iterator iterator &#x3D; vec.begin();\n  &#x2F;&#x2F;返回指向开头的迭代器\n  while (iterator !&#x3D; vec.end()) &#123;\n    &#x2F;&#x2F;当指针还没到队尾\n    cout &lt;&lt; *iterator++ &lt;&lt; endl;\n  &#125;\n  &#x2F;&#x2F;迭代器指针访问 \n&#125;\n","slug":"CppLearning","date":"2022-11-03T02:55:58.000Z","categories_index":"learning","tags_index":"C++","author_index":"Sihan Chen"},{"id":"1cac424653694fd0abd1397c14df4e06","title":"leetcode","content":"leetcode本文主要用来记录自己刷lc的成长过程， 希望大家都能收获理想的offer 😊\n\n\n\n\n\ninput size\n时间复杂度\n常见算法\n\n\n\n1~10\nn!\n排列\n\n\n15~20\n2^n\n组合\n\n\n10~50\nn^4\n\n\n\n100~200\nn^3\n\n\n\n1000~2000\nn^2\nDP 图问题\n\n\n10^6\nnlogn\n贪心 堆 分治 排序\n\n\n10^7\nn\nDP 图问题\n\n\n2^31   10^9\nsqrt(n)\n数论问题\n\n\n2^31  10^9\nlogn\n二分查找 分治\n\n\n10^9\n1\n数学归纳\n\n\n一.基本数据结构熟悉（简单题）1.栈5.19\n1.括号匹配1.简单做法 操作栈\n注意stack为空的情况\n不匹配直接结束\nhint 可以进行奇偶判断\n2.两个stack实现queueinStack和outStack作用：倒腾\n如果连续两次入队(出队)，即连续两次操作相同，不用倒腾\n一旦产生变化需要换stack\ninStack &#x3D; [1,2]\nfor item in inStack:\n\toutStack.append(inStack.pop())\n#错误 loop1：item &#x3D; 1 pop出2 不会进行第二次loop\n\n5.20\n3.两个queue实现stack\n我的做法：注意flag的维护即可 定义主队列 ？？？\n\npush O(1)\npeek 与 pop复杂度相同 O(n)\nemptyO(1)\n\n1.单队列循环实现栈\n2.规定主队列辅助队列 辅助队列用来存最新入栈的元素 实现队列与栈同顺序\n\npop的时候换队列即可\n4.最小栈\n我的思路：维护最小元素的指针 × 连续pop找不到上一个最小的\n1.最小index栈 如果a下面有bcd a对应的minIndex为x看了题解才知道的trick 如果位于栈上面的元素不动 下面的性质则和之前一样因此每个元素可以对应一个最小的index 元素改变之后刚好对应index更新另外 len忘-1 导致bug\n\n辅助栈\n将每个地方对应的最小值存起来\n5.21\n\n5.比较退格字符串  5.26\n\n1.用stack实现 压栈出栈2.双指针法注意两个字符串都要遍历完，如果写的while条件是\nwhile i &gt;&#x3D; 0 and j &gt;&#x3D; 0:\n    pass\n# bb# bb 执行错误\n\n指针是-1 退格符过多已经把所有的前面的字符都清了\n如果两个都是 -1 说明相等（后面的字符串已经相等了）\n1021.删除最外层的括号单纯的入栈弹栈括号匹配，只是要去掉最外层的括号，如果只有一层就不能去，有些坑\npython没有找到比较好的直接替换两端括号的方法：\n1.str-&gt;list-&gt;str\n2.特判选对index\nhint：入栈出栈其实还可以用count来表示，入栈count++，出栈count–，以计数器来模拟栈的出入操作\n461. 汉明距离5.28\n\nhint：海明码\n朴素想法：化成二进制逐位判断\n正常想法：做异或，判断1的个数，有几个1就有多少位不同\n优化：Brian Kernighan 统计x中1的个数每次用x&amp;&#x3D;（x-1） 循环多少次就有多少个1 每次循环把最右端的1变为0\nBrian Kernighan应用：\n\n判断一个数是否是2的幂次方 用 return x &amp; (x-1) &#x3D;&#x3D; 0\n\n把某个区间的数全部&amp;起来，可以把右端的数不断去1，直到小于左端：如果去掉1还在范围内，说明此位位0（&amp;），如果不是，那么我只关心最新的在区间中存不存在这位是0的数，如果存在那么全部&amp;起来的结果就是这个数，显然是存在的。因为左端大于等于这个数，等于则显然，如果大于，那么此位一定是0\n比如如果最后的数是1000 那么区间中一定存在1100 左端一定小于1100 所以一定是10xx\n\n\n477.汉明距离总和暴力两遍循环TLE O（n^2）\ntrick：一个数组里面按位来统计，如果是1就统计其他元素对应位有多少个0，反之亦然。这样就只有一次循环O(n)\n另外还有位数的循环O(L)忽略\n另外10^3 &lt; 2^10 &#x3D;&gt; 10^9 &lt; 2&lt;^30\nhint:\n101\n101\n100\n100\n000 \n则第0位 一共贡献3 &#x3D; 2 * 3\nc = sum((val >> i) &amp; 1 for num in nums)\n\n\n\n2.堆  5.28\n\noffer 40.最小k的个数朴素算法，直接排序取最小k个\nhint：去最小k个可以直接切片 切片相比于朴素的重新构造数列直接快了一半，个人觉得因为切片只需要移动指针，但是重新构建list需要重新append &amp;&amp; pop（）一遍，特别是对于原数组pop（0）是对头进行操作，所有的元素都要进行移动\n堆 \npython的优先队列库：\nimport heapq\nhp &#x3D; []\nheapq.heapify(hp)\n#是具有堆的性质 pyhton默认是小顶堆\nheapq.heappush(hp)\n#加入到队列 头部hp[0]始终位堆顶\nheapq.heappop(hp)\n#pop出头部的元素\nheapq.heappushpop(hp,item)\n#将新元素加入队列 并pop出头部的元素\n\n\n5.30\n\n231.2的幂就是上周的trick数1\n要注意负数，负数直接返回False (和heap有什么关系？)\nnewTrick：\n如果是2的幂次：\nn &#x3D; n &amp;(-n)\n1046. 最后一块石头的重量简单的python堆 应用\n找个机会练下手写堆:\n5.31\n\nclass heap(object):\n    &#39;&#39;&#39;mode &#x3D;&#x3D; 0 means little heap mode &#x3D;&#x3D; 1 means big heap&#39;&#39;&#39;\n    def __init__(self,heap,mode):\n        self.__heap &#x3D; []\n        self.__mode &#x3D; mode\n        for element in heap:\n            self.push(element)\n\n    def get_size(self):\n        return len(self.__heap)\n\n    def get_top(self):\n        if not heap:\n            raise IndexError()\n        return self.__heap[0]\n\n    def push(self,element):\n        p &#x3D; self.get_size()\n        self.__heap.append(element)\n        if self.__mode &#x3D;&#x3D; 0:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &gt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        else:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &lt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        ##up\n\n    def pop(self):\n        p &#x3D; self.get_size() - 1\n        self.__heap[0],self.__heap[p] &#x3D; self.__heap[p],self.__heap[0]\n        top &#x3D; self.__heap.pop()\n        p &#x3D; 0\n        size &#x3D; self.get_size()\n        if self.__mode &#x3D;&#x3D; 0:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &lt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &gt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                ##down handle index out of range\n        else:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &gt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &lt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                #down handle index out of range\n        return top\n\n由于涉及到大小根堆的模式 多了很多冗余代码暂时没有想到怎么处理，只是单纯的copy了一下 毕竟原理相同\n写的时候要特别注意python类的语法 还有堆排序的要点（上浮下沉)\n3.队列6.1\n\n346. 数据流中的移动平均值题目意思看不懂\n朴素做法：\n直接用python的list&amp;&amp;自带的方法维护队列 相当于手动构造\n由于list是单向的 实际上就是一个数组 强行搞成双端 每次pop（0）都需要涉及到一堆元素的移动 \n不需要维护list\n记录最前面的数、size、sum就好了 O(1)\n1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？儿童节快乐！！！！！！\n怪的不得了\n自己手写的算法没有做记忆化 导致超时\n先求前缀和\n然后求范围， 看是否match\n9.4\n4.二叉树递归只涉及到三条语句 前中后序遍历只涉及到语句的不同位置\n递归实现public List&lt;Integer> preorderTraversal(TreeNode root) &#123;\n    ArrayList&lt;Integer> results = new ArrayList&lt;>();\n    if (root == null) &#123;\n        return results;\n    &#125;\n    results.add(root.val);\n    results.addAll(preorderTraversal(root.left));\n    results.addAll(preorderTraversal(root.right));\n    return results;\n&#125;\n\t\npublic List&lt;Integer> inorderTraversal(TreeNode root) &#123;\n    ArrayList&lt;Integer> results = new ArrayList&lt;>();\n    if (root == null) &#123;\n        return results;\n    &#125;\n    results.addAll(inorderTraversal(root.left));\n    results.add(root.val);\n    results.addAll(inorderTraversal(root.right));\n    return results;\n&#125;\n\npublic List&lt;Integer> postorderTraversal(TreeNode root) &#123;\n    ArrayList&lt;Integer> results = new ArrayList&lt;>();\n    if (root == null) &#123;\n        return results;\n    &#125;\n    results.addAll(postorderTraversal(root.left));\n    results.addAll(postorderTraversal(root.right));\n    results.add(root.val);\n    return results;\n&#125;\n\n迭代实现前中后序遍历的迭代实现\n迭代有考究：需要用到stack ，node非空是为了避免root为空的情况吗，都需要判断当前节点是否为空\n\n1.pre 如果stack和node非空，就一直找左子节点，不断访问信息 然后压栈，压栈是为了之后能够回去找到右子节点；如果节点为空，说明没有左子节点，开始访问右子节点，这时就要弹上次压入的节点，然后找到右子节点\n2.in 做法同pre 知识访问的地方在弹栈之后：如果stack和node非空,压入该节点然后找到左子节点；如果节点空，则弹栈，访问该节点信息，然后通过该节点找到右子节点\n3.post 做法和前两者不同：先判断当前是否为空，如果不空，则压入，如果左子节点不空则找到左子节点，反之找到右子节点；如果空，则弹栈（此时两子节点都空），访问信息，然后peek一下，看是否是这个节点的左子节点，如果是，那么则找到该peek节点的右子节点，如果不是，说明现在已经是右子节点了，已经访问完了，所以就直接令为None 以便下一次循环直接再pop一次\n\n  &#x2F;&#x2F;迭代中序\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n       List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();\n       Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n       TreeNode cur &#x3D; root;\n       while (cur !&#x3D; null || !stack.isEmpty()) &#123;\n           while (cur !&#x3D; null) &#123;\n               ans.add(cur.val);\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;\n           cur &#x3D; stack.pop();\n           cur &#x3D; cur.right;\n       &#125;\n       return ans;\n   &#125;\n\n   &#x2F;&#x2F;迭代中序\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n       List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();\n       Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n       TreeNode cur &#x3D; root;\n       while (cur !&#x3D; null || !stack.isEmpty()) &#123;\n           while (cur !&#x3D; null) &#123;\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;\n           cur &#x3D; stack.pop();\n           ans.add(cur.val);\n           cur &#x3D; cur.right;\n       &#125;\n       return ans;\n   &#125;\n\n   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n       TreeNode cur &#x3D; root;\n       Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n       List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();\n       while (cur !&#x3D; null || !stack.isEmpty()) &#123;\n           while (cur !&#x3D; null) &#123;\n               stack.push(cur);\n               if (cur.left !&#x3D; null) &#123;\n                   cur &#x3D; cur.left;\n               &#125; else &#123;\n                   cur &#x3D; cur.right;\n               &#125;\n           &#125;\n           cur &#x3D; stack.pop();\n           &#x2F;&#x2F;说明这个node的左右子节点都是null 直接visit\n           ans.add(cur.val);\n           &#x2F;&#x2F;该节点是上个节点的左节点\n           if (!stack.isEmpty() &amp;&amp; stack.peek().left &#x3D;&#x3D; cur) &#123;\n               &#x2F;&#x2F;说明当前节点是上一个节点的左子节点不能弹出\n               cur &#x3D; stack.peek().right;\n           &#125; else &#123;\n               &#x2F;&#x2F;这里其实可以直接pop上一个节点\n               &#x2F;&#x2F;赋null 也可以 就是多走一次循环\n               cur &#x3D; null;\n           &#125;\n       &#125;\n       return ans;\n   &#125;\n\n二、剑指offer3.17位运算除法最直观的思路就是用减法做循环 但是会超时 \n考虑位运算 每次用最接近的数做减法即可（二进制意义）\n注意唯一可能会出现的溢出情况：不存在小数 除法不会溢出 \n但是正负的最大值差1  除-1可能溢出 \n另外注意python倒序遍历的写法 最后两个写-1 \n二进制加法累加器：a b c \n当前bit : a ^ b ^ c 所有bit异或表示计算1的奇偶性 如果是奇数个 结果是1 反之是0\ncarry : (a &amp; b) | (a | b &amp; c) 或者 (a &amp; b) | (a ^ b &amp; c) \ncount 1\nBK &amp;算法：求x有多少个1 循环x &#x3D; x &amp; (x-1) 直到x &#x3D;&#x3D; 0 每做一次就末尾少一个1 （-1 减掉了末尾的1 原来1后面都是0 自然&amp;掉）\n最高有效位 动态规划 x &#x3D; y + z,bit[x] &#x3D; 1 + bit[z] y对应的二进制只有最高位为1 从1遍历到n 这个y为最接近x的以1开头的二进制数 需要不断更新\n最低设置位 可以看成最高有效位的变种 从低位开始 拿走1之后找关系\n最低有效位 考虑低位 只有两种可能要么有1要么无 bit[x] &#x3D; bit[x &gt;&gt; 2] + x &amp; 1 ，注意x&amp;1表示对2取余\n\n总的来说后三种都是动态规划,考虑当前x和之前的数的关系,要么从头拿走1 要么从尾拿走1\nO(n)说明了只能走一遍循环\n注意位运算优先级\n3.18只出现一次的数字很简单的Hashmap法 时间复杂度O(n) 但是需要额外空间\n不用额外的空间复杂度对于32位的int，如果每个数字出现了3次，那么他的第i位二进制求和mod3余0，如果只出现一次那个该位就是mod3后的值，因此只需要对所有位求和然后mod3即可\n但是这样需要遍历32位，时间复杂度位O(nlogC) C为位数\n由于只可能出现0 1 2三种数 每次更新由下一个数的该位决定，本质上是一个状态机，由于二进制位只能表示2个状态所以需要2bit 用 a b两个数表示 ai bi共同表示当前第i位的状态\n\n\n\n最后的结果中不可能出现2这种情况 要么是0 要么是1 刚好和b相对应 return b\n单词长度的最大乘积首先想到的就是两两比较 二重循环 然后用hashset看是否包含\n实际上应该先排序 只要求最长乘积 应该先排序 再判断是否有交集（O(L^2)) 每次判断两个最多n次 加上排序的(O(nlogn)) \n改进 用int32 存储每个单词的信息 如果没有交集 那么两个int相交为0 算int32的时间复杂度为O(L) L为单词长度 这个优化是最厉害的 降到了一次\n按理说最后一种最快O(nL + nlogn)  总的来说两处优化 一个是交集的优化 一个是排序优化 都降幂了\n排序数组中两个数字的和暴力n^2 \n遍历+二分查找 O(nlogn) 这里自己动手实现了二分查找 \n用hashmap （num,index）但是题目有点问题 不好搞 XXXX\n双指针法 O(n)\n3.19数组中和为定值的若干个数初步思想为用hash表 但是很占内存 并且涉及到很多次去重 时间爆了\n没有想到用排序+双指针法 O(n^2)\nps：遇到数组多往排序想 还有双指针别忘记了 好好理解双指针！注意两个指针移动的条件！\n连续子数组的和满足某个条件由于必须是连续的 显然可以写成前缀和 注意本题前缀和数组的第一项需要从0开始 因为可能需要有整个数组的和才满足条件的情况 注意前缀和要求元素是正值\n屮 竟然不是用双指针 是二分查找 复杂度logn 总共nlogn 注意lo可以减少搜索范围 适当加快速度\n滑动窗口：两个指针同向移动 如果不够end右移 多了 start左移 \nend遍历 start每次从头开始缩保证遍历 正确性\n通过滑动窗口可以加速 O(n^2) -&gt; O(n)\n千万注意滑动窗口无法解决负例\n连续子数组乘积满足某个条件注意可能出现单个元素的值大于k的情况 这时可能出现i &gt; j 应该避免 最多只允许i &lt;&#x3D; j\n3.20连续数组和为k注意数组里是整数 可能为负数 滑动窗口肯定不好用 显然用前缀和（注意第一项从0开始）\n这样复杂度是O(n^2) 直接超时！\n观察发现题目只要求求出数量 并不要求具体组合 考虑优化\nHash表优化 直接查需要的值存不存在有几个 注意前缀和从0开始 Hash表中初始有0：1\n如果求完前缀和再建Hash表 再统计就必须要判断这个数对应的index是否合法\n因此考虑边求前缀和 边建表 边统计 这样每次看到的Hash表都是前面的前缀和了（index 一定在前面）\n连续子数组满足某个条件这好像和求和没有什么关系啊！\n麻了　把０转成－１再求和就变成上一题了\n注意这里要求的是最长的长度　不是求个数　因此hash_map中记录的是最小的index（这样能够使长度最长）　所以hash_map中初始为０：０\n注意hash_map中的项一旦填了就不用改了　因为不会出现更小的index了\n数组的中心下标 显然需要对两边求和 暴力法需要O(n^2)\n由于存在很多重复求和 选择前缀和 观察发现只需要满足某一项与前一项和与最后一项想等即可（由于必须使砍成两截 最后一个必须在末尾 前面和中间必须相邻） 不需要用hash_map \n注意考虑两端都是0 且两边都没有元素的情况\n二维子矩阵的和显然如果直接求很简单 很难想象使简单题 肯定需要优化 \n显然用前缀和 避免重复计算\n进阶版 用二维前缀和 实际上有点类似动态规划了 可证 递推式\n每次查询为O(1)\n这个脚标太难调了 真恶心\n3.21链表数组相加链表数相加，很多坑！（感觉我写的太复杂了）\n1.要注意carry进位处理需要循环 \n2.注意如果在原来链表上改的话 需要将短链接到长链上\n3.感觉新操作一条链表可能不容易出错些 （保持循环有三个条件 carry l1 l2 当前是否为空）\n？？ 为什么新开链内存更小了？ 不懂\n字符串变位词&#x2F;出现的index没思路\n仔细想变位的含意 意思是s1中的字符顺序无所谓 （反正可以自己随便调顺序） 那么转化位在s2中找连续字串 各字符个数和s1中相等\n由于是连续字串 考虑滑动窗口即可 注意考虑s1长度小于s2的情况\n正常思路是用两个hashmap 当对应kv相等时满足条件 \n差分优化 对应的值相见 用diff来统计不同的地方 这样每次就不用重新比较一遍\n同理可以利用双指针 注意双指针做差后需要+1\n不含重复字符的字串双指针 思路类似\n3.22含有所有字符的最短字符串变位词变种 需要注意的是现在是包含而不是相等关系 双指针破题即可 注意cnt中只用记录在变位字符串中出现的字符\n回文串&#x2F;允许删除n个字符的回文串&#x2F;回文子串双指针直接判断即可\n发现题解有用Python库函数的做法 虽然简单 但不好\n允许去掉一个字符 最直观的就是一个个试 O(n^2)\n还是用双指针 允许一次出错O(n) 注意到底是移左指针还是右指针 好像不知道？\n思路是对的 但我的实现怎么这么丑啊(原来没看题)\n回文字串这题完全没思路 ，只想到暴力法 O(n^3)\n1.定中心法 但是需要考虑奇数偶数 奇数单中心 偶数双中心 从左到右一次遍历 复杂度O(n^2)\n可以进行统一 观察发现对于n 有2n - 1个情况 对应的li ri 可以找规律 也可以分情况两次循环 manacher算法放弃\n删除链表倒数第n个不能随机访问 感觉只能扫一遍统计个数 再扫一遍找到那个删除 注意具体操作的时候在头上加一个根节点可以避免讨论 简称哨兵节点 O(n)\n前后双指针O(n)\n两个常数不一样\n链表环的入口可以染色吗？hash_map或者set记录即可  O(n)  需要空间复杂度\n快慢指针(可以计算出圈中剩下的距离就是从开始到入环点的距离) 可以通过公式推出巧妙地结果（完全考数学观察）\n双链表的交点set法 时间空间复杂度都是O(m+n)\n显然可以补环 然后转化成环找入口 快慢指针 最后要解环 空间复杂度O(1) 时间复杂度O(m+n)\n双指针法时间复杂度O(m+n) 空间复杂度O(1) \n3.23明显的取巧做法肯定就是用list存各个节点 然后分别操作\n反转链表可以使用递归 每次拆一个节点 然后接起来\n可以使用pre post存前后节点 然后迭代反转\n链表两数相加（需要反转型）压栈 每次弹栈（本质上还是 用了list）\n反转之后硬做 加完后再反转回来 时间复杂度常数巨高 ！\n重排链表快慢指针 拆分然后合并 注意如果是奇数节点一定要将中间的节点归在前面 否则很臭！\n3.24回文链表可以通过使用list 转化成回文字符串 时间空间复杂度为O(n)\n先正向统计val 顺便反转 然后再重新统计一遍 时间复杂度为O(n)（但是C很大 超时了） 空间复杂度为O(1)\n使用快慢指针 降常数 空间复杂度不变 注意将中间节点放在前面半段 使用guard节点！ 注意特殊处理只有一个节点的情况\n三叉链表扁平化利用dfs即可 注意断开处的处理 father涉及到child next  child 涉及到pre 注意将最后的节点返回 递归考察！\n注意看清楚属性名 为什么我属性名写错了他不报错啊！！！\n排序的循环链表注意None情况 跑一遍 维护int记录大小 注意非递减 时间O(n) 空间O(1)\n好多坑啊 其实就两种情况 一种是中间能插入 能被夹起来 一种是小于等于&#x2F;大于等于所有的值 只需要在判第一种的时候记下最大的节点就好 第二种情况一定是在这个节点后面 注意一定是从头开始判断（而不是head.next开始） 第二次再到头的时候表示走了一个轮回\n3.25插入 删除 随机访问都是O(1)的容器显然插入删除可以通过hashmap解决 （显然有浪费内存 但是hashset不能解决） 随机访问肯定用randint 但是hashmap不能随机访问 这样就是O(n) getrandom\n答案是要借助list进行随机访问！\n可以在map中存入kv &#x3D; (val,index) 每次pop的时候将元素移入末尾 在pop 这样是O(1) 注意pop数组的时候被交换的元素的index要发生相应改变\nLRU容器的构造map + list\nlist当作队列使用 一旦被get或者put（更改值或者生成新的kv对） 该kv对应的k要到list末尾 另注意容量问题 建议分开写！ 不要怕代码重复 不然很容易出 bug 优化是写完之后的事情！\nlist的remove key 复杂度是O(n) 字典remove O(1) listpop(0)O(n) 关键慢在queue删除元素上 \n考虑使用链表 map改为存储 key  ，node 删除queue节点 添加 移动都可以在O(1)内完成\npython 这个pre 和prev真的是有毒了! 多变量赋值 连续赋值遇到指针千万别用\n变位词的判断遍历一遍 在比较的同时 统计map 最后再比较map 时间复杂度O(n) 注意变位词的定义 需要至少有一个字符不一样\n貌似还有排序的做法 算了吧至少O(nlogn)了\n3.26变位词分组只出现小写字母 应该用hashmap来表示kv 每次比较时间复杂度O(C) 空间复杂度O(n)\n需要分组 还需要建立kv表组 一次遍历O(n) group中比较需要O(n) 共O(n^2) 很麻烦\n原因就是不能一把看出 两个词是不是变位词 可以考虑对单个str排序（这样可以一次看出） 或是 使用char次数作为键\n外星语言先把order搞成hash表 不要求输出答案 应该只用两两check O(n^2) （？？ 为什么要两两chekc 应该check一遍就够了 注意是验证是否有序！ 不是排序 验证怎么可能比排序时间复杂度还高？）\n 注意空集的优先级 比首字母还小\n最小时间差先排序O(nlogn) 然后O(n)遍历 计算最小的diff 注意最后可能会拼接起来注意首末 注意是个环 大于720 可以取另一半 （首元素到末尾可以避免讨论）\n优化 注意到只有1440个时间点 如果长度超过则返回0 将首元素再加到末尾 可以避免冗余代码\n3.27逆波兰表达式很简单的stack题 就是要注意是保留整数部分\n小行星相撞完全没有看出是单调栈 我的思路是从末尾开始处理 就很难看出是单调栈了 导致讨论很复杂很难做\n如果从左向右处理就是单调栈！看出来就结束了 注意给标记表示planet是否还需要append进去\n最多相撞O(n)次 循环O(n)时间复杂度是O(n)\n上升温度就是找当天之后最短距离几天温度会上升 用单调栈解决即可 每次拿到新的温度 如果更小那么就可以将栈顶弹掉 保持单调栈 此处为单调递减 小于等于就入栈 注意输出的时候需要找到对应的index 所以index和value要打包为turple入栈 \n3.28单调栈的题目 先确定是上升还是下降 什么情况下开始弹栈\n最大的矩阵面积隐约感到是单调栈了 没想通原理 注意本质是在遍历高度 然后找两边最远的index 每次出现更小的就是最远距离 左边靠着的就是左边的最远index 可以反证\n时空O(n)\n矩阵中最大的矩形和单调栈有关系？\n遍历行 统计高度 就可以看成矩阵面积最大值了\n时间复杂度O(n^2) 空间O(n)\n滑动窗口平均值显然用队列 感觉这题好像都不用用队列啊\n写java的时间是python的十几倍 坑也是 \n注意要转化成double\n最近请求次数简单 每次无脑offer 然后看首是否&lt; t - 3000循环poll\n二叉树添加节点简单 队列处理 每次offer两个节点 队首的节点poll出去 cnt 区分左右节点\n如果某节点已经有两个子节点那么可以poll 再peek下一个节点 否则只能不处理\n注意返回的是val 不是node\n也可以不用双队列 用l记录需要pop出的节点个数 Python可以直接len(l)记录下循环次数\ndfs：二叉树层数就是ans的个数 用depth记录深度 当来到该深度时就对ans[depth]进行更新最大值\n3.29二叉树先中后序遍历 取决于想知道的信息\n前中后序遍历递归很简单 可能考迭代\n注意使用stack前中 基本一样 遇到新节点就入栈 优先左边 区别在于访问的时间 前序在入栈前访问 中在出栈时访问 入栈是为了访问该节点的的右节点\n注意后续遍历弹栈弹根的时候有两种情况 1.右子树有但还没遍历 2.右子树没有或者已经遍历了 prev记录上一个节点即可\n最左最深的节点的val简单 bfs 或者 dfs 如果用bfs注意不能poll 由于题目要求最左最下 显然符合dfs特征\n每一层只有一一个答案 先dfs左边 一旦填了答案就不能改了 显然dfs的速度是要更快的（每层val出现的位置是确定的） bfs要操作很多队列 但是bfs 不用递归很多层 空间复杂度应该小\n二叉树剪枝感觉是后序遍历 下面的子树做标记 符合条件就扔掉\n1.注意flag的传递 （如果0藏在中间是不可以prune的）\n2.注意root的特殊处理\n序列化和反序列化每太弄懂题目  BFS比较简单 由题目知只有第一个None才序列化 不是完全二叉树\n可以只要编码解码顺序堆起来即可 一共有四种做法\n一个deque处理BFS ans放答案\n时空复杂度都是O(n)\n注意bfs dfs时空复杂度都是O(n)\n！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！Todo 前序遍历实现\n根节点到叶节点的和可以用dfs和bfs bfs要有暂存  要有双队列 或者用turple实现\n时空复杂度都是O(n)\n注意规定好累加值的求法！ 规定扔下去的累加值已经 乘10了 如果还需要进下一层需要自己再乘10  注意只要有一个子树 就不用加本身的value了 因为已经放到下一层计算了\n3.30展平二叉树思路一样老de不出来 关键需要讨论左孩子位考虑使用dummy（简单多了！保证了prev永不为null）\n中序遍历存列表 时空O(n)\n不用链表 但是有递归 空间复杂度也是O(n)\n二叉搜索树中序后继直接装ArrayList 时空复杂度O(n) 时间常数更大\n中序遍历找到p flag亮 然后直接返回 主函数返回null\n注意是二叉搜索树！\n如果当前cur.val &gt; p 就向左子树找 并且将res 指向当前节点 反之 向右子树找\n3.31连续子数组最大和dp 可以优化空间\n大于等于节点的值之和看懂了就很简单 是一种中序遍历 反转过的 注意每个节点不一定用list存 记录sum即可（时空都变好 量级没变）\n时空O(n) 涉及到递归 很难优化空间了(morris？) 直接用链表存得了 \n树迭代器（中序）应该用stack实现中序遍历 stack最多含O(h)个节点 从左子树走一直到最深 hasNext直接查stack是否空 next弹栈 注意弹完还需要继续走左子树\nnext均摊时间复杂度为O(1) hasNext为O(1)\n二叉搜索树两数之和最笨的做法扁平化(有序) 再遍历（可二分查找 也可hash 也可双指针） 双指针应该是最好的\n最快迭代中序遍历 维护hash （还是没有充分利用二叉搜索树的性质）\n值和index差小于limitation和树有关？只想到暴力法\n利用TreeSet 本质红黑树 动态维护min(n,k)空间大小的红黑树\n插入删除查找的时间复杂度都是logc c为容量\n一次遍历 总时间复杂度O(nlogc) c为容量\n桶 划分n个桶（区间） 注意桶大小应该是最大差+ 1 注意正负数的处理 正数直接用x &#x2F; w w为桶大小 负数为 (x - 1) &#x2F;w - 1\n每遇到一个数标记对应区间 再次遇到就说明满足条件 没再次遇到就检查左右两个桶 如果有一个被标记也满足条件\n空间复杂度也是O(c) c为容量\n时间复杂度为O(n)\n小心类型转换 按照顺序来 看每一步有无隐式转换\n4.3日程表区间怎么判重啊？ 没思路\n用TreeMap 包含KV的红黑树(与TreeSet的关系类似于HashMap 和 HashSet)\n单次时间复杂度O(logn) 空间复杂度O(n)\ntopK问题注意是最大流 需要一直更新\n优先队列解决\n频率最高的topK注意此题不会一直更新\n先统计HashMap 然后 堆排序复杂度O(nlogk) 空间O(n)\n堆里面怎么放Entry啊 用int[] {1,2,3} 进行模拟!\n注意排序的实现方式java\n还有一种方法是利用快排分治思想 时间复杂度为O(n) 最差O(n^2) 利用random取pivot \n和最小的K个数对二叉堆 简单做法 暴力 时间复杂度O(k^2logk) 堆容量为k\n但是nums1 nums2 有序！\n 如果(0,0)是最小的index对 那么(1,0) 或(0,1)一定是倒数第二小的 以此类推 可以利用 类似bfs的方式不断搜索 每轮poll一次 这个一定是该轮最小的 k轮结束 每轮不断扩散 本质是贪心\n可能有重复 有两种去重方式：\n1.hashset做标记 （速度太慢）\n2.规定加入顺序 先把一侧全部加入 后面index只增加另一部分\n时间复杂度O(klogk) \n注意由于规定了heap排序方式需要使用nums1 nums2 offer之前需要考虑index是否越界\n4.4只要涉及到给prefix 求出具体的相关单词的就需要用前缀树\n否则可以考虑hash 暴力\n前缀树字典树 26个字母节点 为了避免把某一单词的前缀认成单词 需要使用isEnd标记 字母节点可以用数组存\n时间复杂度 O(S) S为当次操作字符串长度\n空间复杂度O(T C) T为所有字符串的长度和 C为26 \n替换单词模板题\n字典树 注意设置isEnd 遇到isEnd就替换 没遇到节点就结束 不替换\n注意用StringBuilder 不要自己去拼接 可以快3倍\n神奇字典没思路 不知道hello hallo怎么处理\nDFS暴搜 记录flag 好难写啊 DFS这么搜 感觉复杂度好高啊 还没有暴力好O(nC) C为字符串长度 （DFS一个节点会被访问多次 暴力比较最多访问一次）\n暴力时用cnt统计不同的字符 cnt &#x3D;&#x3D; 1满足\n最短单词编码压缩空间 编码要最短\n注意返回的是编码长度 暴力hashset 时间O(\\sum wi^2) hash值计算考虑 C为字符串长度 空间O(\\sum wi)\n前缀树也可用 注意可能重复经过叶节点 要不断修改flag 最终统计叶节点长度 时间O(\\sum wi) 空间O(26 \\sum wi)\n根据前缀返回相关单词和暴力肯定能做 时间复杂度O(\\sum wi) 空间O(n)\n前缀树 接近O(\\sum wi) O(26 \\sum wi) 感觉时间上可能会快\n最大异或果然超时了hhh 多了一个数量级\n\n肯定最高位是1要好 利用前缀树遍历从高位到低位放进树中 如果该位是1 去找0 如果没有就只能去1 注意 如果存在路径 说明存在这个数 小心遍历方式 不要重复 本质是利用分支加速 贪心\n\n利用公式 a ^ b &#x3D; c &lt;–&gt; a ^ c &#x3D; b 假设答案中该位为1 看成不成立 贪心\n时间都是O(nlogC) logC &#x3D;&#x3D; 31\n空间hash为O(n) 前缀树为O(nlogC)\n\n\n二分查找如果一开始不知道问题的解是什么，但是知道解的范围是多少，则\t可以尝试在这个范围内应用二分查找；应用这种思路的关键在于两点：确定解的范围，即解的可能的最小值和最大值；在发现中间值不是解之后如何判断接下来应该在解的范围的前半部分还是后半部分查找。只有每次将查找范围减少一半时才能应用二分查找算法。\n必须要是有序的！！！！！！！\n边界有点恶心 注意区分区间定义情况[a,b) 注意if\n迭代法实现类似\n&#x2F;&#x2F;[a,b)闭区间法 官方推荐\n&#x2F;&#x2F;收缩上界 lowerbound 找target该插入的头部位置\nclass Solution &#123;\n    public int searchInsert(int[] nums, int target) &#123;\n        &#x2F;&#x2F;迭代法 [a,b) &amp;&amp; 收缩上界\n        int left &#x3D; 0;\n        int right &#x3D; nums.length;\n        while (left &lt; right) &#123;\n            int mid &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] &gt;&#x3D; target) &#123;\n                right &#x3D; mid;\n            &#125; else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;\n&#x2F;&#x2F;收缩下界\n&#x2F;&#x2F;1找第一个大于target的index\nclass Solution &#123;\n    public int searchInsert(int[] nums, int target) &#123;\n        &#x2F;&#x2F;迭代法 [a,b) &amp;&amp; 收缩下界\n        int left &#x3D; 0;\n        int right &#x3D; nums.length;\n        while (left &lt; right) &#123;\n            int mid &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] &gt; target) &#123;\n                right &#x3D; mid;\n            &#125; else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;\n&#x2F;&#x2F;2找target该插入的末尾位置\nclass Solution &#123;\n    public int searchInsert(int[] nums, int target) &#123;\n        &#x2F;&#x2F;迭代法 [a,b) &amp;&amp; 收缩下界\n        int left &#x3D; 0;\n        int right &#x3D; nums.length;\n        while (left &lt; right) &#123;\n            int mid &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] &gt; target) &#123;\n                right &#x3D; mid;\n            &#125; else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left - 1;\n    &#125;\n&#125;\n\n山峰数组O(n)遍历一遍\nO(logn)二分查找\n排序数组只出现一次的数字已经有序！ 二分check两边即可 分情况 隐隐感觉有关系 但没想到分奇偶…\ntrick:偶数和1异或为偶数+1 奇数和1异或为奇数-1\n加权随机index和二分查找有什么关系？\n划分区间 几何分布 随机出的x快速判定区间index可以利用二分法（区间可以用前缀和表示 前缀和有序）这个地方前缀和没有0\n初始化O(n) 二分O(logn)\n空间O(n)\n求平方根看复杂度是sqrt(n)?和二分查找有关？\n暴力法小心溢出\n数轴上二分查找 注意三套模板用哪个 （注意都需要将&#x3D;&#x3D;合并进去 即只有两个branch)\n吃香蕉肯定需要先排序 至少O(nlogn)\n注意left从1开始\n4.5排序10种排序方法\n排序区间按照start和end顺序排列 然后遍历合并 不断更换当前check的区间\n注意检查末尾是否超过cur末尾 排序 时间 O(nlogn) 排序空间递归用了O(logn)\n特殊condition排序暴力做即可 可以堆排序或者快排\nTopK堆排序即可\n单链表排序逃课就存节点 快排\n要空间感觉可以用冒泡\n合并有序链表归并\n回溯！！！！！！！！！！！！！！！！！！！！！\n数据量小的直接暴搜DFS\n可以剪枝优化\n可以记忆化搜索\n所有子集取或者不取 时间复杂度O(2^n)\n求组合数$$C_n^k$$型，对每一位进行遍历，注意记录已选数字个数\n可以进行剪枝（如果所有数字都选了还是不能到k个这种情况）\n允许重复选择元素用DFS回溯 暴力遍历\n去重？\n不允许重复选择元素注意idx的处理\n数组元素全排列(含重复元素&#x2F;不含重复元素)不含重复元素：注意flag做标记 注意每次进入dfs都是顺序选取元素如果被flag标记 就找下一个 直到找满\n含重复元素：set去重 效率很低（还要内部排序）\n对元素集合进行排序，相同元素会聚集在一起，对于这些相同元素每次保证如果前面的没选取 后面的就不选取 （如果选取会重复）即可去重\n生成匹配的括号按照左右括号的数量回溯 想不到…\nleft &lt; n,right &lt; left\n分割回文子串用一个函数判字符串是否为回文串 可以做记忆化搜索\n固定头部 移动尾部进行回溯即可 （答案不用去重）\n按条件分割字符串按index分割 注意剪枝\n4.17TopK问题1.大小为K的堆\n2.快速选择法 注意pivot的选取需要随机 每次选一个后和最后的那个元素交换 然后按照正常的partition做\n三、Top1001.两数之和暴力n^2 \n排序 二分查找 nlogn 但是index已经变了 不是很好搞\nhash表 O(n) S(n)\n2.链表求和开个新链表 以最长的为基准 求和进位即可\n3.无重复最长子串双指针+HashSet O(n) S(n)\n用滑动窗口 ：本质实在优化index的枚举 本来是n^2 -&gt; n\n注意可能进入不了else while循环外面要套一次更新\n4.两个正序数组中位数暴力合并O(m+n)\n中位数为 m+n+1 &#x2F;2  m+n+2&#x2F;2 对应的数的平均数\n设为K\n在两个数组里寻找第K个数 分别看第K&#x2F;2个 如果num1小于num2说明 第K个绝对不可能在num1的K&#x2F;2个里 可以删除 不断折半K 最终K为1的时候比较首元素即可 某个数组已经被剔完了 直接找另一个数组的第K个即可(为了统一 优雅可以直接另被剔完的数组对应的元素为无穷大)\n5.回文串动态规划\ndp[i,j] 记录的是能不能成为回文串 不能记录最大长度\n因为如果记录最大长度的话不能确定是否是子串（相邻）\n6.Z串直接模拟 注意不要越界 while秒\n7.整数反转用最大的MAX_VALUE的1&#x2F;10进行判断 (Integer.MAX_VALUE:2147483647)\n感觉只能暂存 然后特判\n51.52.N皇后bitmap状态压缩空间复杂度不过还是O(n）因为要递归\n105.106.二叉树重构已知前中 后中都能唯一确定二叉树\n但是已知前后不能 因为最后叶节点的时候不能确定到底是左孩子还是右孩子\n两种不同的关键是当作左子树还是右子树找根\n由于不会有重复元素 可以用hashmap加速\n注意：\n三种题都可以每次取一个元素 (L &lt; R) 终止条件L &#x3D;&#x3D; R \n如果相等说明没有子树节点了 该节点就是根节点 直接返回就好\n注意下标的变化\n四、Leetcode75205. 同构字符串Hashmap遍历 O(n) O(l) l:字符集的大小\n290. 单词规律与205完全相同 需要用空格分割t\n290. 单词规律II缺少了空格分隔 暴力\n暴力回溯 （自己划分空格） 1h\n很恶心:\n1.结束条件 必须同时结束 p 和 s\n2.注意区分两个map if else写详细 p-&gt;s是强制的 s-&gt;p s是可变的\n392. 判断子序列1.两个指针 O(n+m)  如果有k个就是O(k(n+m))\n2.DP 优化为O(kn + m) 空间O(m)\n21. 合并两个有序链表1.正常拼接就好 3个while 都要注意p的移动O(m+n)\n2.注意立哨兵 注意判断开始的情况\n206. 反转链表迭代：\n1.注意while条件cur !&#x3D; null 说明之后还有一个 进while再next\n递归：\n1.注意每次拆分一个节点 递归解法会天然用栈储存\n2.注意解环\n3.返回值就是最终答案\n876. 链表的中间结点快慢指针：这个题就不要用dummy 因为对于偶数点要靠后的Node\n142. 环形链表 II快慢指针：如果有环就在里面转 总能遇到\n求出入口节点:有个很巧的公式 注意环的性质\n121. 买卖股票的最佳时机注意记录遍历过的数中最大的实际上就是动态规划 \n实际上不用动态规划 时间复杂度O(n) 空间O(1)\n409. 最长回文串遍历 收集 再来一个最大的基数 O(n) O(L)\n注意字符可以不用完\n用数组可以加速\n589. N 叉树的前序遍历感觉iter做法比较麻烦 每个node都要打标记 (用hashmap帮忙打标记)\n注意弹出的时候要抹掉所有children的标记\n或者倒序入栈\nrecur有context帮忙打标记\n常用算法二分查找1.注意规定[l,r) 考虑每次lr的能否取到端点\n2.如果存在相同的值注意收缩上界\npublic class BinarySearch &#123;\n    //迭代递归的时间复杂度都是O(logn)\n    //递归的空间复杂度为O(logn) 迭代为O(1)\n    public static void main(String[] args) &#123;\n        int[] array = new int[]&#123;1, 2, 3, 4, 5, 5, 6&#125;;\n        class Search &#123;\n            //[l,r)\n            public int searchIndexIter(int[] array, int l, int r, int tar) &#123;\n                int mid;\n                while (l &lt; r) &#123;\n                    mid = l + ((r - l) >> 1);\n                    if (array[mid] >= tar) &#123;\n                        r = mid;\n                    &#125; else &#123;\n                        // arrya[mid] &lt; tar\n                        //at least mid + 1\n                        l = mid + 1;\n                    &#125;\n                &#125;\n                return l;\n            &#125;\n\n            public int searchIndexRec(int[] array, int l, int r, int tar) &#123;\n                if (l >= r) &#123;\n                    return l;\n                &#125;\n                int mid = l + ((r - l) >> 1);\n                if (array[mid] >= tar) &#123;\n                    return searchIndexRec(array, l, mid, tar);\n                &#125; else &#123;\n                    return searchIndexRec(array,mid + 1,r,tar);\n                &#125;\n            &#125;\n        &#125;\n        Search search = new Search();\n        int ans = search.searchIndexIter(array,0,array.length,5);\n        System.out.println(ans);\n        ans = search.searchIndexRec(array, 0, array.length, 4);\n        System.out.println(ans);\n    &#125;\n&#125;\n\n八大排序冒泡排序1.两重循环\n2.冒泡次数 n\n3.交换次数 n - 1 - i\n选择排序1.两重循环\n2.选择次数 n\n3.比较次数 n - i\n插入排序1.两重循环\n2.插入次数 n - 1\n3.前移注意break \n归并排序1.注意规定[l,r]\n2.先直接分割 然后再合并\n快速排序1.注意规定[l,r]\n2.双指针法:最后循环停的时候i &#x3D;&#x3D; j 填入pivot\n3.可以改成迭代 用stack辅助即可\n4.切割即可（注意切割过程中归类） 不用合\n深度是logn 空间复杂度是logn\n计数排序1.基于统计\n2.注意理解cnt的意义 包括本身前面还有多少个数\n3.注意倒序填写 因为每次填的是最后一个\n希尔排序1.希尔增量 n &#x2F;2 … 1 希尔增量序列 增量是多少就可以分成多少组\n2.每组组内采用插入排序\n3.shell增量一层while 插入排序实现起始点一层for 终点一层while\n堆排序优先队列\n二叉树上浮下潜 \n限定容量即可实现topk\n基数排序1.按照位数进行排序 本质是多轮排序\n桶排序1.使用映射将N个数分到K个有序桶中\n2.每个桶各自排序\n复杂度表冒泡 插入最好的情况就是本身已经有序了\n\n基数排序空间复杂度不是O(nk)?\ndp自底向上！\n线性dp经常考虑末尾元素！！！\n单数组（一维）和最大的子串(MCSP)dp[i]定义为包含a[i]的最大子串和 空间复杂度可优化为O(1) 时间复杂度O(n)\n双数组（二维）最长公共子序列(LCS)dp[i,j]定义为两个字符串中index分别以i，j结尾的情况，分别考虑最后x_i y_j是否相等\n注意相等时其实有三种情况 但是dp[i-1,j-1] + 1可包括另外两种情况\n时间复杂度O(mn) mn为字符串长度\n最长公共子串（LCSP)相比MCSP要求连续\ndp[i,j]定义为以两字符串中分别以i，j结尾的字符串的最长公共子串的长度 如果不等肯定为0 等则可由dp[i-1,j-1] + 1转移\n复杂度O(mn)\n编辑距离考虑删除 插入 替换操作\ndp[i,j] 表示从s_i 转换为 t_j需要的次数\n满足条件的最长子序列dp[i] 包含第i个字符且满足条件的最长子序列\n注意答案可能不是最后一个 需要遍历一次找到最大值\n背包dp01背包问题dp[i,c]考虑前i个物品 使用c容量总共的价格 \ndp[i,c] &#x3D; max(dp[i-1,c] ,dp[i-1,c-v[i]] + p[i])\n只与上一行 以及前面的dp值有关 可以考虑优化空间复杂度 倒着遍历空间容量\n完全背包物品可以取多次\ndp[i,j] &#x3D; max(dp[i-1,j],dp[i-1,j - k v[i]] + k p[i]) \nw从左到右遍历 这样就是可以取多次 （对于第i行 不断考察取不取i物品）\n区间dp钢条切割dp[i]表示切割长度为i的钢条能获得的最大收益\ndp[i] &#x3D; dp[i - j] +p[j] (j \\in [1,i])\n矩阵链乘法两个矩阵(pq,qr)相乘进行的乘法次数pqr\ndp[i,j]表示第i到第j个矩阵顺序运算需要的次数\ndp[i,j] &#x3D; min(dp[i,k] + dp[k + 1,j] + p_i-1p_kp_j)\ni &lt;&#x3D; k &lt; j\n树形dp一般是二叉树后序遍历\n状压dp状态压缩 一般用二进制表示 这就要求状态转移的选择尽量少\n图论DFS&#x2F;BFS注意染色color\nbfs需要使用队列\n时间复杂度都是O(V+E)\n环路检测利用DFS看是否会遇到队列里的节点（已经遍历过）\nO(V+E)\n拓扑排序BFS拿走入度为0的节点 拿走的同时注意修改邻接点的入度\nDFS 按照完成时刻逆序\nO(V+E)\n强连通分量点之间可达 注意一个点也是强连通分量\nkosaraju算法：\n\n反向\nDFS做拓扑排序 完成时间逆序 L\n按照L再进行一次DFS 每次得到的分量就是一个强连通分量\n\n时间复杂度O(V+E)\n最小生成树(MST)Prim优先队列,将节点带着边入队 不断取最小的边\n注意每次poll之后要更新\nO(ElogV + VlogV)\nKruscal并查集 union_set O(logV)\nfind_set O(logV)\ncreate O(1)\nO(ElogE + ElogV)\n单源最短路径(dijkstra)dijkstra指定顶点\n本质上是贪心 也用了优先队列 不断更新累计权值\n权值必须非负\nO（VlogV + ElogV) \n注意 dijkstra和prim注意区分\nbellman-ford指定顶点\n执行V轮松弛 每次检查E条边 顺序无所谓 （最多V - 1轮 可以全部松弛完）\n如果第n轮还能松弛 说明存在负环 否则求解完毕\nO(VE)\nFloyd所有顶点\n可以有负权\n$$dp[k,i,j] &#x3D; min {dp[k - 1,i,j],dp[k - 1,i,k] + dp[k - 1,k,j] }$$\n二分图技巧HashSet、HashMap去重&#x2F;判重 空间换时间 遇到需要时间复杂度位O(1)的操作即可用\n前缀和 （一维 二维）\n双指针1.对向双指针\n避免判断余数sum +&#x3D; (pile+speed-1)&#x2F;speed;\n&#x2F;&#x2F;如果pile % speed &#x3D;&#x3D; 0 那么 speed - 1 &#x2F; speed &#x3D; 0\n&#x2F;&#x2F;如果pile % speed !&#x3D; 0 那么 speed 再贡献一个speed 相当于商 +  1\n&#x2F;&#x2F;相比求余数快的离谱\n\n位运算\n去掉最右边的1 x &amp; (x-1)\n找出最右边的1 x &amp; (-x)\n","slug":"leetcode","date":"2022-11-03T02:41:45.000Z","categories_index":"learning","tags_index":"leetcode","author_index":"Sihan Chen"},{"id":"cc9917eea87f0911c627dfa9deeeca84","title":"INTERN","content":"ByteDance, Beijing\n\n\n\n\n\n\n\n\nBack-end Intern of Master Data Department of Lark SuiteResponsible for data management (query, storage and transfer) and participated in three important projects as below:\nMessage Deduplication of the ETL Module\nCombined the messages with same content in the Message Queue of ETL module, which reduced the pressure of query interfaces of Vault Service\nChose distribution architecture based on Partition Key of RocketMQ rather than centralized architecture based on Redis, to avoid complex and inefficient lock operation and consideration\nChanged the offset of RocketMQ to the one before fault for disaster recovery, which assured the consistency of data and no messages loss\n\nOptimization of Data Table Design\nChanged the manage_relations table which has been put into use into job_data table, because of the poor performance on both function and efficiency of the former one, due to the imperfect design before\nKept two tables working simultaneously using double-write strategy to avoid data loss and pollution\nWrote Go script to assure the correctness of combination and storage of data\nIncreased the rate of flow online slowly, which prevented huge online fault during the table-change process\n\nMultiGeo Function of Vault Service\nTransferred the sensitive information of Singapore employee from China to Singapore, due to the legal requirements\nUsed the strategy of soft deletion followed by a hard deletion, which avoided data loss in transfer process\nAdded the support for cross-region storage and cross-region query for Vault Service\n\n","slug":"intern","date":"2022-11-02T14:33:58.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"},{"id":"b39baedab164cf8277508d2f603d42e1","title":"MESSAGE BOARD","content":"Just a Message Board, feel free to talk with me in the comment area, if you want!","slug":"messageboard","date":"2022-11-02T13:25:43.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"}]