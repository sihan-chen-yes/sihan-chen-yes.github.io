[{"id":"331a202dba2c0a92d7a5610826376ac5","title":"Welcome to Sihan's Blog!","content":"\ndrifting with my friends\n\nHello, welcome to my website!\nI’m Sihan Chen, a senior from Beihang University majoring in Computer Science.\nIf you like this, we’d be good friends\ncoding, curious about fancy technologies both in software and hardware\n\ngames, including all platforms (PS, Xbox, NS, PC), but except mobile!\n\nanime, addictive anime fans\n\nsports, especially badminton and basketball\n\n\nWhat you can do in my Blog?\nAbout: here’s my detailed information, you can check it here to know me if you want\n\nResearch: here you can have a look at my recent research progress\n\nProjects: most the projects I’ve done will be listed here\n\nIntern: here I’m glad to share my intern experience including the advanced skill I learned in industry and the preparation process\n\nMessage Board: If you have any words to talk with me,  feel free to leave them here\n\n\nIn the future I’ll expand my life and games modules in my Blog, and I’ll keep write blogs in above modules and I look forward to your visit.😃\n","slug":"welcome","date":"2022-11-02T13:36:43.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"},{"id":"f68465535d0d54d5f349f18e96ad6c70","title":"PROJECTS","content":"School of Computer Science and Engineering Beihang UniversityMultifunctional Movie Website Sept. 2021 – Dec. 2021GitHub\n\nDeveloped a website for watching movies, deployed it on my private cloud server already\nClick here to visit, Account:123, Password:123 for tourist\nUsed Vue and Django frame to build the front and back end respectively, and chose MySQL as database\nBuilt E-R Diagram to design tables which met the requirement of 3NF for a trade-off between stability and efficiency\nImproved the security of website via anti-injection of database and ciphertext of password storage\n\nSysY-based Compiler Sept. 2021 – Dec. 2021GitHub\n\nBuilt a compiler using Java, which can transform SysY (a subset of C) from source code to MIPS assembly code\nIncluded modules of Lexical Analysis (Automata Theory-based), Syntax Analysis (Recursive Descent-based), Semantic Analysis (Abstract Syntax Tree-based), Middle Code Generation (Quaternary Formula-based), Target Code Generation (MIPS-based)\nOptimized the compiler via Inline Function, Loop Optimization, Register Allocation Optimization, among others; ranked 24 &#x2F; 250 finally\n\nARC-based Page Replacement May. 2021 – June. 2021GitHub\n\nSimulated the page replacement of cache in operating system, and used Adaptive Replacement Cache (ARC) algorithm to decrease miss rate, which considered both recency and frequency, with adaptivity to the current memory access mode by adjusting capacity of cache for both dynamically\nBuilt data structure with specific function and low memory usage from scratch rather than using STL container\nRanked 1&#x2F;250 (according to the weighted result of perf instruction on Linux operating system)\n\nMIPS-based Operating System Kernel Mar. 2021 – June. 2021\nBuilt a MIPS-based operating system kernel via Linux platform, using C programming language\nSupported memory management, virtual address, interruption handling, inter-process switch and communication, disk management, file system and IO operation of device\n\nElevator System Simulator Mar. 2021 – Apr. 2021GitHub\n\nUsed multithreading of Java to simulate the elevator system to deliver people to their target floor with the least time\nConsidered the load and number of elevators, used the LOOK scheduling algorithm for each individual elevator, and global transfer strategy to arrange all elevators to reach the least total of waiting time\n\nSocial Relationship System Mar. 2021 – Apr. 2021GitHub\n\nDeveloped a simple social relation simulator, supporting making groups, sending red envelopes and messages between users, querying the real-time status of the system, and managing kinds of exceptions\n\nBuilt a debugging program to assure the correctness and real-time via black-box and white-box testing, and stress testing, respectively\n\n\nMIPS-based CPU Oct. 2020 – Jan. 2021GitHub\n\nImplemented a CPU supporting five-stage pipelines (IF,ID,EX,MEM,WB) and interruption and exception handling\nSupported 53 instructions totally in MIPS instruction set, where assembly instructions of C programs can be run\n\nCOVID-19 Reporter Feb. 2022 – March. 2022GitHub\n\nBuilt a auto reporter via Python\nUsed Charles to grasp the http package, then generated a fake one and sent it to the school server\nConsidered the accident, if report failed, an email sent by the reporter to my phone\n\nFire Alarm and Emergency Response System Sept. 2021 – Dec. 2021GitHub\n\nImplemented a IoT system with functions of sensing the ambient information (temperature and humidity),  presenting the history curve of it, controlling the alarm and threshold of alarm remotely, warning with LED flashing and buzzer working\nUsed Vue and Django to build the front and back end, MySQL to record the history information\n\nWeb Crawler Sept. 2020 – Dec. 2020GitHub\n\nUsed Python to collect the movie information on Douban Top 250 Rank\n\nUsed IP proxy, random UA and referrer to make fake request_headers, carried out sleep to simulate real humans\n\nUsed PyQt5 lib to design the UI, separated the UI frame code and the logic code for better maintenance\n\nUsed B+ tree to accelerate the search process at local\n\n\n","slug":"projects","date":"2022-11-02T13:25:13.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"},{"id":"27379ee9b4cc0fae3c3b580e4d316922","title":"RESEARCH","content":"I’ve done some research in CV, Robotics and Vision-and-language Navigation (VLN) fields.\nI’m going to further explore CV, NLP and ML fields in the future.\nInstitue of Artificial Intelligence  Beihang University\n\n\n\n\n\n\n\n\nUnder the supervision of  Prof. Si Liu in  CoLab\nVLN Model Optimization (May. 2022 – Present)GitHub\n\nProposed the Structured state-Evolution (SEvol) module to solve the flaw of over-compression of object-level spatial-temporal information in NvEM, and enhanced the performance of it on R2R, R4R and REVERIE datasets\nBased on A2C algorithm, used Reinforced Layout clues Miner (RLM) module to select objects appropriately\nEmployed Dynamic Graph Neural Network (DGNN) to aggregate the spatial-temporal information of objects\nBased on GRU model, proposed mGRU model (matrix version), accomplished the renewal of weight in DGNN at every time step\n\nInteractive Robotic Dog (Oct. 2021 – May. 2022)GitHub\n\nBuilt a robotic dog with the function of voice interaction and guiding the blind\nImplemented object detection and speech recognition module based on YOLOv5 and CMUSphinx respectively\nImplemented main control module based on SDK of motion and information generated by two modules mentioned\n\n","slug":"research","date":"2022-11-02T13:22:11.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"},{"id":"d98f1fb29d1fa4ad9eb741861fb28e94","title":"DesignPattern","content":"Design Pattern22种设计模式的学习 以java为实现语言\nUMLclass\n关系依赖\n修改课程会导致教授发生变化\n关联\n教授总是能访问学生\n聚合\n院系作为容器装着教授\n组合\n大学由院系组成，院系不存在了 大学就不存在了\n\n模式SOLID原则\nSingle Responsibility Principle:单一职责，相关的功能封装在一起\nOpen&#x2F;Closed Principle:开闭原则,对新增开放，对修改封闭\nLiskov Substitution Principle：里氏替换原则, 子类能替代超类\nInterface Segregation Principle：接口隔离原则 拆分接口\nDependency Inversion Principle：依赖倒置原则\n\n创建型（5）提供创建对象的机制，增加已有代码的灵活性和可复用性\n工厂方法\n实际上不用区分AB工厂 将createA和createB放入工厂内部即可\n抽象工厂\n开始出现二维，例如风格，p1风格和p2风格都有createA和createB\n生成器\n当创建一个非常繁琐的嵌套类时，用director当主控逻辑，用不同的具体builder建造\n原型\n就是深拷贝 调用clone返回完全相同的实例\n单例\n\n实例必须是static final的\n构造器必须是private的 只能从内部调用\n\n结构型（7）介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效\n适配器\n本质上是对第三方接口进行包装，在里面将data转化成specialData 然后传入第三方接口\n桥接\n抽象由具体实现聚合而成，具体实现作为抽象的成员变量，抽象有对实现的引用，这个引用就是桥\n本来可以由继承解决 但是为了避免$$N\\times N $$类数量爆炸的问题，通过引用改成了$$N + N $$个类\n不要继承要组合\n组合\n此组合非彼组合：桥接模式的组合指的是 不要继承要组合；这里的组合指的是容器意义上的包含\n容器和元素都有execute方法\n装饰\ndecorator包含多个具体的组件嵌套，有点类似组合模式\n外观\nfacade暴露了一个调用API,内部子系统自行工作，将复杂的子系统包一层，然后暴露一个简单的输入输出API+简单的主控逻辑\n享元\n将共有的属性提出来称为一个单例类\nContext中flyweight是共享类 uniqueState是区别属性\n代理\n和外观模式很相似：代理对服务有引用\n行为（10）负责对象间的高效沟通和职责委派\n责任链\n每个handler都有对下一个handler的引用，将request传入第一个handler\n命令\n将具体请求封装成一个command，传入invoker，invoker自行execute，execute相关的信息已经包在command里了\n迭代器\nJava典型的Iterator\n中介者\n构建中枢，所有的component和中枢交流，避免component互相交流\n备忘录\nOriginator中的状态不想让外界知道(private)，将属性抽入Memento,Memento也不能让外界知道，但是Memento作为Originator的内部类，Originator可以随意访问\n观察者\n包含多个订阅对象的引用\n状态\ncontext含有state，do通过调用内部state实现，context可以改变state\n策略\n和状态模式基本一样，状态模式的状态之间有转化关系，策略模式的策略之间毫无关系\n模板方法\n将一件事抽象为步骤1234的模板类，具体实现类可以重写不同的步骤\n访问者\n不修改原来的代码，将待解析对象作为参数传入visitor\n为了区别不同的类，需要在visitor中判断具体的类\n为了避免visitor中频繁的if instance of，可以使用双分派技巧，让element传入visitor的时候就自动知道自己的类：将visitor传入element，再调用visitor，将this作为参数传入，就会自动选择对应的重载方法\n","slug":"DesignPattern","date":"2023-03-14T10:36:34.000Z","categories_index":"learning","tags_index":"Java,DesignPattern","author_index":"Sihan Chen"},{"id":"0ada6c4f5edc36649f58988ffaf9b8b2","title":"RedisLearning","content":"RedisLearningRedis是一个很重要非关系型数据库(NoSQL)，速度极快（KV型数据库），常用来做缓存或数据库\n环境配置\n直接下载windows版的redis\n通过docker拉取redis镜像，在容器中使用redis\n\n注意如果开着VPN，docker desktop不一定能启动, 提示WSL2出错，可以尝试重制网络\nnetsh winsock reset\n\n数据类型\nstring\nhash\nlist\nset\nzset\n\n对于没有返回值的指令，成功了返回1，失败了返回0\n注意理解key的含义，redis中key指的是不同数据类型的名字(实例的名字)\ndel k:删除k(实例)\nkey\nkeys pattern:找出所有符合模式的key，相比scan会阻塞主线程，因为redis是单线程的，只能一次返回所有的keys\nscan cursor pattern count：返回所有符合模式的key  可以和其他线程同步进行，可以多次分批返回\n\nstring\nset k v:设置kv\n\nget k:根据k获取v\n\nmget k1, k2...:一次性获得多个k对应的v\n\nsetex k seconds v:设置对应的kv和生效时间\n\nstrlen k:获取k对应的v的长度\n\nincr k:k对应的v++\n\nincrby k v:k对应的值+v\n\ndecr k:k对应的v–\n\ndecrby k v:k对应的值-v\n\nappend k v:k对应的值拼接v\n\n\nhash\nhset key k1 v1...:创建hash\n\nhmset key k1 v1 k2 v2:一次性设置多个kv\n\nhget key k:根据k获取v\n\nhmget key k1, k2...:一次性根据多个k获取v\n\nhgetall key：获取所有的kv对\n\nhkeys key:获取所有的k\n\nhvals key:获取所有的v\n\nhlen key:返回k的个数\n\nhdel key k1,k2,...:删除kv对\n\nhexists key k:检查k是否存在\n\nhincrby key k v:k对应的值+v\n\n\nlist\nlpush key v1 v2:在左边插入v\nlpop key:左边pop\nblpop key seconds:左边pop，最多阻塞seconds\nrpush key v1 v2:在右边插入v\nrpop key:右边pop\nbrpop key seconds:右边pop，最多阻塞seconds\nbrpoplpush l1 l2 seconds:从l1右边pop插入l2左边，最多阻塞seconds\nbrpoplpush l1 l2 seconds:从l1右边pop插入l2左边\nlrem key count v:移除与v相等的元素 count个 （count符号表示查找顺序 0表示所有）\nlindex l1 i:根据index返回元素\nlrange key start stop:返回范围内的元素\nlinsert key before/after pivot v:在pivot前&#x2F;后插入v\nllen key:返回元素个数\nlset key i v:根据index设置v\n\nset\nsadd key e:向集合中增加元素e\nscard key:返回集合元素个数\nsmembers key:返回所有元素\nsisemember key e:检查是否存在\nsrem key e1 e2:移除元素\nsdiff key1 key2:返回key1与key2的差集\nsdiffstore destination key1 key2:将差集存入destination\nsinter key1 key2:返回key1与key2的交集\nsinterstore destination key1 key2:将交集存入destination\nsunion key1 key2:返回key1与key2的并集\nsunionstore destination key1 key2:将并集存入destination\nsmembers key:返回所有成员\n\nzsetscore是数字\n\nzadd key score1 e1 score2 e2:向有序集合添加元素\n\nzcard key:返回元素个数\n\nzcount key min max:返回指定分数区间的成员个数\n\nzlexcount key min max:返回指定字典区间的成员个数 注意字符用[a表示\n\nzrange key start stop:返回指定索引区间的成员\n\nzrevrange key max min:返回指定索引区间的成员(倒序)\n\nzrevrangebyscore key max min:返回指定索引区间的成员(倒序)\n\nzrevrangebylex key max min:返回字典索引区间的成员(倒序)\n\nzrangebyscore key min max:返回指定分数区间的成员\n\nzrangebylex key min max:返回指定字典区间的成员\n\nzincrby key v e:e对应的score+v\n\nzrank key e:返回成员的索引\n\nzscore key e:返回成员的分数\n\nzrem key e1 e2:移除元素\n\nzremrangebylex key min max:移除指定字典区间的成员\n\nzremrangebyscore key min max:移除指定分数区间的成员\n\nzinterstore destination number key1 key2:将交集存入destination\n\nzunionstore destination number key1 key2:将并集存入destination\n\n\n用作缓存\n缓存穿透：总是查询缓存中不存在的key 就可以绕过缓存直接打后端\n将不存在的key对应的空值也缓存\n布隆过滤器：将key映射到多个index，查询是否存在的时候看对应的index是否为1，若全为1说明可能存在；若不全为1，则一定不存在\n\n\n缓存击穿：某个key失效导致后端接口压力增大\n加分布式锁\n\n\n缓存雪崩：大量的缓存同时失效 \n加分布式锁\n多级缓存\n随机过期\n\n\n\n数据一致性redis作为缓存，MySQL作为数据库\n现在要更新数据，如何保证缓存和数据库的一致性？\n\n先删除缓存，再更新数据库；但是可能还没更新之前就有线程要读，从数据库中读出脏数据\n先更新数据库，再删除缓存：更新数据库的过程中如果有线程读数据会直接从缓存读脏数据\n\n缓存策略的最佳实践:Cache Aside Pattern\n\n\n读取最佳实践：先读取Cache 如果没有则从DB中读取，然后更新Cache\n\n写入最佳实践：先删除Cache 再更新DB （如果DB更新失败，读出来的数据还是和DB一致）\n\n有问题的写入机制：\n\n先更新Cache 再更新DB （如果DB更新失败 则Cache为脏数据）\n先更新DB 再更新Cache （如果Cache更新失败，则数据不一致）\n先更新DB再删除Cache（如果Cache删除失败，则数据不一致）\n\n但是如果更新DB失败，在重试的过程中有查询，则会读出还没更新的数据，导致暂时的不一致，顺便更新了cache（脏数据）\n所以引入延迟双删机制，先删除Cache，然后更新DB，再删除Cache（清楚脏数据），sleep保证删除Cache完成\n保证了最终一致性\n综上 不要更新Cache，容易导致不一致，优先删除Cache，再从DB同步\n注意：\n\n如果删除Cache一直失败需要报警，同时可以通过消息队列重试保证Cache一定删除成功\n将删除Cache与业务解耦，通过订阅binlog实现\n\n\n\n用作消息队列\n异步消息队列：list, rpush, lpop；可以自行sleep然后再lpop，当然也可以blpop，阻塞地pop\n延时队列：zset,用时间戳作score，然后用zrangebyscore获取特定时间戳的元素\n\n用作分布式锁\nsetnx key:抢锁\nexpire seconds：定期释放锁\n\n","slug":"RedisLearning","date":"2023-03-02T08:40:39.000Z","categories_index":"learning","tags_index":"redis","author_index":"Sihan Chen"},{"id":"0aca10cea344fa1aabb90a273c674d58","title":"MarkupLanLearning","content":"XMLLearningeXtensible Markup Language（XML）\nXML 被设计用来传输和存储数据，不用于表现和展示数据，HTML 则用来表现数据。\ndemo&lt;bookstore>\n    &lt;book category=\"COOKING\">\n        &lt;title lang=\"en\">Everyday Italian&lt;/title>\n        &lt;author>Giada De Laurentiis&lt;/author>\n        &lt;year>2005&lt;/year>\n        &lt;price>30.00&lt;/price>\n    &lt;/book>\n    &lt;book category=\"CHILDREN\">\n        &lt;title lang=\"en\">Harry Potter&lt;/title>\n        &lt;author>J K. Rowling&lt;/author>\n        &lt;year>2005&lt;/year>\n        &lt;price>29.99&lt;/price>\n    &lt;/book>\n    &lt;book category=\"WEB\">\n        &lt;title lang=\"en\">Learning XML&lt;/title>\n        &lt;author>Erik T. Ray&lt;/author>\n        &lt;year>2003&lt;/year>\n        &lt;price>39.95&lt;/price>\n    &lt;/book>\n&lt;/bookstore>\n\nbookstore是根元素 每个标签可以有属性 属性只能有一个值\n两种开闭方法\n&lt;context:annotation-config/>\n&lt;bean id=\"user\" class=\"com.kuang.dao.User\">&lt;/bean>\n\n对大小写敏感\n属性值要加引号\n下划线命名法\n注意理解可扩展\n转义字符\n\n\n字符\n转义字符\n描述\n\n\n\n&amp;\n&amp;\n和\n\n\n&lt;\n&lt;\n小于号\n\n\n&gt;\n&gt;\n大于号\n\n\n“\n&quot;\n双引号\n\n\n‘\n&amp;apos;\n单引号\n\n\n注释&lt;!-- comment -->\n\nXML DOMYAMLLearningYet Another Markup Language(YAML)\n基本语法\n大小写敏感\n使用缩进表示层级关系\n缩进不允许使用tab，只允许空格\n缩进的空格数不重要，只要相同层级的元素左对齐即可\n‘#’表示注释\n\nK: V\n\n数据类型\n对象\n\n键值对的集合\nhash_name: \n    child-key: value\n    child-key2: value2\n    \n?  \n    - complexkey1\n    - complexkey2\n:\n    - complexvalue1\n    - complexvalue2\n\n\n\n\n数组list:\n\t- A\n\t- B\n\t- C\t\nlist: [value1, value2, ...]\n\n复合companies:\n    -\n        id: 1\n        name: company1\n        price: 200W\n    -\n        id: 2\n        name: company2\n        price: 500W\n\nlanguages:\n  - Ruby\n  - Perl\n  - Python \nwebsites:\n  YAML: yaml.org \n  Ruby: ruby-lang.org \n  Python: python.org \n  Perl: use.perl.org\n\n转化为json\n&#123; \n  languages: [ 'Ruby', 'Perl', 'Python'],\n  websites: &#123;\n    YAML: 'yaml.org',\n    Ruby: 'ruby-lang.org',\n    Python: 'python.org',\n    Perl: 'use.perl.org' \n  &#125; \n&#125;\n\n\n\n纯量（scalars）\n\n单个的、不可再分的值\n引用&amp;：锚点 \n*：别名\n&lt;&lt;：合并到当前数据\ndefaults: &amp;defaults\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  &lt;&lt;: *defaults\n\ntest:\n  database: myapp_test\n  &lt;&lt;: *defaults\n\n等于\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n\ntest:\n  database: myapp_test\n  adapter:  postgres\n  host:     localhost\n\nJsonLearningJavaScript Object Notation(JSON)\nJSON 是轻量级的文本数据交换格式\nXML是存储数据用的\n很多语言都能直接解析\n语法\n数据在名称&#x2F;值对中\n数据由逗号 , 分隔\n使用斜杆 ** 来转义字符\n大括号 {} 保存对象\n中括号 [] 保存数组，数组可以包含多个对象\n\ndemo&#123;\n    \"sites\": [\n        &#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125;, \n        &#123; \"name\":\"google\" , \"url\":\"www.google.com\" &#125;, \n        &#123; \"name\":\"微博\" , \"url\":\"www.weibo.com\" &#125;\n    ]\n&#125;\n\n转化为XML\n&lt;sites>\n  &lt;site>\n    &lt;name>菜鸟教程&lt;/name> &lt;url>www.runoob.com&lt;/url>\n  &lt;/site>\n  &lt;site>\n    &lt;name>google&lt;/name> &lt;url>www.google.com&lt;/url>\n  &lt;/site>\n  &lt;site>\n    &lt;name>微博&lt;/name> &lt;url>www.weibo.com&lt;/url>\n  &lt;/site>\n&lt;/sites>\n\nXML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析。\n","slug":"MarkupLanguageLearning","date":"2023-03-02T08:38:00.000Z","categories_index":"learning","tags_index":"XML,YAML,JSON","author_index":"Sihan Chen"},{"id":"5e8c2b7b04127754c5a977ce1b671861","title":"KubernetesLearning","content":"Kubernetes常用指令-n 表示namespace \n//查看pod信息\nkubectl --kubeconfig ~/.kube/config get pod -n mlops-system\n//查看部署情况\nkubectl --kubeconfig ~/.kube/config get deploy -n mlops-system\n//删除pod\nkubectl --kubeconfig ~/.kube/config delete pod -n mlops-system  dashboard-68748dddb8-ljkm9\n//查看：可以查看镜像信息\nkubectl --kubeconfig ~/.kube/config get deploy -n mlops-system dashboard -oyaml\n//修改服务配置\nkubectl --kubeconfig ~/.kube/config edit deploy -n mlops-system dashboard\n//查看日志\nkubectl --kubeconfig ~/.kube/config logs -f -n mlops-system dashboard-68748dddb8-s7w89   (pod_name)\n//查看status 变化\nkubectl --kubeconfig ~/.kube/config describe pod -n mlops-system dashboard-68748dddb8-s7w89\n//修改配置文件\nkubectl edit cm -n mlops-system dashboard-conf\n\n//maven打jar包\n\n部署操作流程实际上就是走了一遍dockerfile\n1:打jar包（package）\n2:启动docker容器  docker run -it -d dockerhub.mlops.jd.com/ai-platform/dashboard:0215-feat (拿到容器id)\n//imageName 上k8s用get yaml获取yaml文件 找到imageName\n3: copy jar包到指定的 容器目录下 docker cp jar  容器id:目录\n//目录具体值可以通过dockerfile找到\n4:将容器打成镜像 docker commit 容器id 镜像名称\n5: docker push 镜像名称\n6:修改yaml image信息 就会自动restart\n\n测试url：\nhttp://mlops-test.jd.com/gw/dashboard/health/get\n\ndocker//获取container 和 image信息\ndocker ps\n//登录远程镜像仓库\ndocker login dockerhub.mlops.jd.com\n//查看image\ndocker image ls\n//查看容器\ndocker container ls\n//打包镜像\ndocker save -o /root/xxx.tar  &lt;name>\n//导入镜像\ndocker load -i /root/xxx.tar\n//容器一般先打包成镜像\ndocker commit container_name name:tag\n\n","slug":"KubernetesLearning","date":"2023-03-02T08:30:56.000Z","categories_index":"learning","tags_index":"K8s","author_index":"Sihan Chen"},{"id":"4250e66bce89b75e9ef464236ec9b3e1","title":"MavenLearning","content":"MavenLearningMaven是一个Java项目管理工具，简单来说就是用来引包的\ngo这种较新的语言自带包管理工具，java也需要包管理工具\n类似的包管理工具还有gradle\n配置\nconf&#x2F;settings.xml\n\nrepository：本地的jar包存放位置\n\n\n都可以改位置\n注意在settings中的mirrors加上阿里云镜像 加速下载\n&lt;mirror>\n    &lt;id>aliyunmaven&lt;/id>\n    &lt;mirrorOf>*&lt;/mirrorOf>\n    &lt;name>阿里云公共仓库&lt;/name>\n    &lt;url>https://maven.aliyun.com/repository/public&lt;/url>\n&lt;/mirror>\n\nMaven目录\n\n\n目录\n目的\n\n\n\n${basedir}\n存放pom.xml和所有的子目录\n\n\n${basedir}&#x2F;src&#x2F;main&#x2F;java\n项目的java源代码\n\n\n${basedir}&#x2F;src&#x2F;main&#x2F;resources\n项目的资源，比如说property文件，springmvc.xml\n\n\n${basedir}&#x2F;src&#x2F;test&#x2F;java\n项目的测试类，比如说Junit代码\n\n\n${basedir}&#x2F;src&#x2F;test&#x2F;resources\n测试用的资源\n\n\n${basedir}&#x2F;src&#x2F;main&#x2F;webapp&#x2F;WEB-INF\nweb应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面\n\n\n${basedir}&#x2F;target\n打包输出目录\n\n\n${basedir}&#x2F;target&#x2F;classes\n编译输出目录\n\n\n${basedir}&#x2F;target&#x2F;test-classes\n测试编译输出目录\n\n\nTest.java\nMaven只会自动运行符合该命名规则的测试类\n\n\n~&#x2F;.m2&#x2F;repository\nMaven默认的本地仓库目录位置\n\n\nPOMPOM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。\nproject object 把项目当成了对象,有一些项目属性\nSuper POM， 类似于object类\n执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\nPOM 中可以指定以下配置：\n\n项目依赖\n插件\n执行目标\n项目构建 profile\n项目版本\n项目开发者列表\n相关邮件列表信息\n\n\n\n\n节点\n描述\n\n\n\nproject\n工程的根标签。\n\n\nmodelVersion\n模型版本需要设置为 4.0。\n\n\ngroupId\n这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。\n\n\nartifactId\n这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。\n\n\nversion\n这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1\n\n\nExample&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n    &lt;parent>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-parent&lt;/artifactId>\n        &lt;version>2.7.10-SNAPSHOT&lt;/version>\n        &lt;relativePath/> &lt;!-- lookup parent from repository -->\n    &lt;/parent>\n    &lt;groupId>com.example&lt;/groupId>\n    &lt;artifactId>demo&lt;/artifactId>\n    &lt;version>0.0.1-SNAPSHOT&lt;/version>\n    &lt;name>demo&lt;/name>\n    &lt;description>demo&lt;/description>\n    &lt;properties>\n        &lt;java.version>1.8&lt;/java.version>\n    &lt;/properties>\n    &lt;dependencies>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.springframework.boot&lt;/groupId>\n                &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId>\n            &lt;/plugin>\n        &lt;/plugins>\n    &lt;/build>\n    &lt;repositories>\n        &lt;repository>\n            &lt;id>spring-milestones&lt;/id>\n            &lt;name>Spring Milestones&lt;/name>\n            &lt;url>https://repo.spring.io/milestone&lt;/url>\n            &lt;snapshots>\n                &lt;enabled>false&lt;/enabled>\n            &lt;/snapshots>\n        &lt;/repository>\n        &lt;repository>\n            &lt;id>spring-snapshots&lt;/id>\n            &lt;name>Spring Snapshots&lt;/name>\n            &lt;url>https://repo.spring.io/snapshot&lt;/url>\n            &lt;releases>\n                &lt;enabled>false&lt;/enabled>\n            &lt;/releases>\n        &lt;/repository>\n    &lt;/repositories>\n    &lt;pluginRepositories>\n        &lt;pluginRepository>\n            &lt;id>spring-milestones&lt;/id>\n            &lt;name>Spring Milestones&lt;/name>\n            &lt;url>https://repo.spring.io/milestone&lt;/url>\n            &lt;snapshots>\n                &lt;enabled>false&lt;/enabled>\n            &lt;/snapshots>\n        &lt;/pluginRepository>\n        &lt;pluginRepository>\n            &lt;id>spring-snapshots&lt;/id>\n            &lt;name>Spring Snapshots&lt;/name>\n            &lt;url>https://repo.spring.io/snapshot&lt;/url>\n            &lt;releases>\n                &lt;enabled>false&lt;/enabled>\n            &lt;/releases>\n        &lt;/pluginRepository>\n    &lt;/pluginRepositories>\n\n&lt;/project>\n\n\n\n构建流程\n\n\n\n阶段\n处理\n描述\n\n\n\n验证 validate\n验证项目\n验证项目是否正确且所有必须信息是可用的\n\n\n编译 compile\n执行编译\n源代码编译在此阶段完成\n\n\n测试 Test\n测试\n使用适当的单元测试框架（例如JUnit）运行测试。\n\n\n包装 package\n打包\n创建JAR&#x2F;WAR包如在 pom.xml 中定义提及的包\n\n\n检查 verify\n检查\n对集成测试的结果进行检查，以保证质量达标\n\n\n安装 install\n安装\n安装打包的项目到本地仓库，以供其他项目使用\n\n\n部署 deploy\n部署\n拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程\n\n\n注意几个关键的节点：\n\npackage:可以生成jar包\ninstall:可以将jar包更新到dependency中\ndeploy:部署到远程依赖仓库\n\n具体使用的时候可以用mvn + 命令 \n更多还是直接通过idea点击图标自动执行指令\n配置文件(profile)构建配置文件是一系列的配置项的值，可以用来设置或者覆盖 Maven 构建默认值。\n使用构建配置文件，你可以为不同的环境，比如说生产环境（Production）和开发（Development）环境，定制构建方式。\n配置文件在 pom.xml 文件中使用 activeProfiles 或者 profiles 元素指定，并且可以通过各种方式触发\n配置文件在构建时修改 POM，并且用来给参数设定不同的目标环境\n依赖（dependency）引入jar包时使用\n在pom.xml填上具体的dependency即可 \n递归依赖发现\n原型（archetype）通过插件实现，自动生成项目模板\n一般在idea新建项目时选择模板即可\n文档（doc）配置pom.xml 添加插件\n&lt;build>\n&lt;pluginManagement>\n    &lt;plugins>\n        &lt;plugin>\n          &lt;groupId>org.apache.maven.plugins&lt;/groupId>\n          &lt;artifactId>maven-site-plugin&lt;/artifactId>\n          &lt;version>3.3&lt;/version>\n        &lt;/plugin>\n        &lt;plugin>\n          &lt;groupId>org.apache.maven.plugins&lt;/groupId>\n          &lt;artifactId>maven-project-info-reports-plugin&lt;/artifactId>\n          &lt;version>2.7&lt;/version>\n        &lt;/plugin>\n    &lt;/plugins>\n    &lt;/pluginManagement>\n&lt;/build>\n\nmvn site\n\n生成项目文档\n快照（snapshot）如果使用版本号，则每次更新版本号必须改变\n使用快照可以避免版本号的频繁变更\nmaven每次构建项目都会搜索远程仓库最新的快照\n&lt;version>1.0-SNAPSHOT&lt;/version>\n\n仓库Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。\nMaven 仓库有三种类型（一如既往：git，docker）：\n\n本地（local）：本地电脑的仓库\n中央（central）：maven社区仓库\n远程（remote）：私有远程仓库\n\n插件(plugin)Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：\n\n创建 jar 文件\n创建 war 文件\n编译代码文件\n代码单元测试\n创建工程文档\n创建工程报告\n\n具体在POM中配置\nwarning注意选择springboot版本时不能太高 否则模板生成的pom.xml中的java版本会很高 导致运行出错\n","slug":"MavenLearning","date":"2023-03-02T08:26:49.000Z","categories_index":"learning","tags_index":"Java,Maven","author_index":"Sihan Chen"},{"id":"e2282de6728a80d0791f191a978c3c81","title":"SpringLearning","content":"SpringLearningIoC (Inversion of Control)\n谁负责创建组件？\n\n\nIoC容器\n\n\n谁负责根据依赖关系组装组件？\n销毁时，如何按依赖顺序正确销毁？\n\n\nXML文件指定\n\n&lt;beans&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;HikariDataSource&quot; &#x2F;&gt;\n    &lt;bean id&#x3D;&quot;bookService&quot; class&#x3D;&quot;BookService&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;UserService&quot;&gt;\n        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n依赖注入（dependency injection）：把组件（service）传到具体的实例\nbeans：Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean\n注入类型：Spring的IoC容器同时支持属性注入和构造方法（反射）注入，并允许混合使用\n无侵入容器：在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：\n\n应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；\n测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。\n\nSpringXML配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!-- xml 版本 编码-->\n&lt;!-- 所有要让spring托管的类都在beans中声明 beans中有一个个小bean-->\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    &lt;!--bean就是java对象 , 由Spring创建和管理-->\n    &lt;bean id=\"hello\" class=\"com.kuang.pojo.Hello\">\n        &lt;property name=\"name\" value=\"Spring\"/>\n    &lt;/bean>\n&lt;/beans>\n\n客户端使用\n@Test\npublic void test()&#123;\n    //解析beans.xml文件 , 生成管理相应的Bean对象\n    //最重要的容器 每次从这个context里获取实例\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n    //getBean : 参数即为spring配置文件中bean的id .\n    //相当于new\n    Hello hello = (Hello) context.getBean(\"hello\");\n    hello.show();\n&#125;\n\n注入constant&lt;bean id=\"student\" class=\"com.kuang.pojo.Student\">\n    &lt;!-- 注意千万要有setter 不然没法注入-->\n    &lt;property name=\"name\" value=\"小明\"/>\n&lt;/bean>\n\nBean（ref）作用域singleton:单例模式\nprototype:每次都new\nrequest:每个HTTP请求都有自己的\nsession：每个HTTPsession都有自己的\nArrayListMapSetNullProperty自动装配byName: 按名称装配\nbyType：按照类型装配\nAnnotation最佳实践：XML中写bean 属性和setter用注解实现\n注意需要在配置文件中加上context限制\n&lt;!-- 说明扫描的地方 非常重要-->\n&lt;context:component-scan base-package=\"com.kuang.pojo\"/>\n&lt;context:annotation-config/>\n\n创建对象@Component\n默认class name 小写去获取\n&lt;bean id=\"user\" class=\"com.kuang.pojo.Hello\"/>\n\n以下为MVC架构下的衍生物\n@Controller\n@Service:\n@Repository:对应DAO曾\n注入数据@Autowired:byType 然后 byName\n@Resource:byName 然后 byType\n@Qualifier\n@Value\n注意如果用XML一定要有setter 注解可以没有setter\n可以作用于属性和setter\n&lt;property name=\"name\" value=\"sihan\"/>\n\n作用范围@Scope\n其他@Data：自动生成getter setter toString\nCache@Cacheable: 使用缓存\nCacheconfig\n把XML构造成类客户端\nApplicationContext context = new AnnotationConfigApplicationContext(Config.class);\nUser user = context.getBean(\"getUser\", User.class);\nSystem.out.println(user.name);\n\n服务端\n//扫描路径\n@ComponentScan(\"com.kuang\")\n\n//表明是配置文件\n@Configuration\npublic class Config &#123;\n    //类似于&lt;bean/>\n    @Bean\n    //User等于bean中的class getUser等于bean中的id\n    public User getUser() &#123;\n        return new User();\n    &#125;\n&#125;\n\n\n\n@Configuration 类似于xml配置文件\n@Bean\n@Import\nAOP(Aspect Oriented Programming)\n执行一个动作前后需要有一些HOOK，本质上就是处理这些HOOK （权限检查 异常处理 日志打印等）\n可以通过代理模式实现\nOOP面向名词领域，AOP面向动词领域\n代理模式把真正的service藏在proxy里面 通过proxy进行操作\n静态代理动态代理AOP配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    &lt;!--注册bean-->\n    &lt;bean id=\"userService\" class=\"com.kuang.service.UserServiceImpl\"/>\n    &lt;bean id=\"log\" class=\"com.kuang.log.Log\"/>\n    &lt;bean id=\"afterLog\" class=\"com.kuang.log.AfterLog\"/>\n    \n    \n    &lt;!--aop的配置-->\n    &lt;aop:config>\n        &lt;!--切入点  expression:表达式匹配要执行的方法-->\n        &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/>\n        &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点-->\n        &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/>\n        &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/>\n    &lt;/aop:config>\n&lt;/beans>\n\n织入方法(weave)使用时先配置XML \n&lt;!-- 注释千万别去-->\n&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->\n&lt;dependency>\n    &lt;groupId>org.aspectj&lt;/groupId>\n    &lt;artifactId>aspectjweaver&lt;/artifactId>\n    &lt;version>1.9.4&lt;/version>\n&lt;/dependency>\n\nSpring API配置XML即可\n&lt;aop:config>\n    &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/>\n    &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/>\n    &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/>\n&lt;/aop:config>\n\n自定义类&lt;!--注册自定义类的bean-->\n&lt;bean id=\"diy\" class=\"com.kuang.config.DiyPointcut\"/>\n&lt;!--aop的配置-->\n&lt;aop:config>\n    &lt;!--第二种方式：使用AOP的标签实现-->\n    &lt;aop:aspect ref=\"diy\">\n        &lt;aop:pointcut id=\"diyPonitcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/>\n        &lt;aop:before pointcut-ref=\"diyPonitcut\" method=\"before\"/>\n        &lt;aop:after pointcut-ref=\"diyPonitcut\" method=\"after\"/>\n    &lt;/aop:aspect>\n&lt;/aop:config>\n\n注解&lt;bean id=\"annotationPointcut\" class=\"com.kuang.config.AnnotationPointcut\"/>\n&lt;aop:aspectj-autoproxy/>\n\n@Aspect 声明切片类\n@Before:前HOOK\n@After:后HOOK\n@Around:前后HOOK\n@Aspect\npublic class AnnotationPointcut &#123;\n    @Before(\"execution(* com.kuang.service.UserServiceImpl.*(..))\")\n    public void before()&#123;\n        System.out.println(\"---------方法执行前---------\");\n    &#125;\n    @After(\"execution(* com.kuang.service.UserServiceImpl.*(..))\")\n    public void after()&#123;\n        System.out.println(\"---------方法执行后---------\");\n    &#125;\n    @Around(\"execution(* com.kuang.service.UserServiceImpl.*(..))\")\n    public void around(ProceedingJoinPoint jp) throws Throwable &#123;\n        System.out.println(\"环绕前\");\n        System.out.println(\"签名:\"+jp.getSignature());\n        //执行目标方法proceed\n        Object proceed = jp.proceed();\n        System.out.println(\"环绕后\");\n        System.out.println(proceed);\n    &#125;\n&#125;\n\n&lt;!--xml中配置-->\n&lt;bean id=\"annotationPointcut\" class=\"com.kuang.config.AnnotationPointcut\"/>\n&lt;aop:aspectj-autoproxy/>\n\n\n\nSpringBoot创建选择Spring initializer \n选上springweb 自动导入需要的包\n依赖管理 \n自动配置\n注解@SpringBootApplication:启动类\n@Controller：@Component衍生注解 注册为bean@Service： @Component衍生注解 注册为bean\n@Repository： @Component衍生注解 注册为bean\n@RequestMapping:路径映射\n@ResponseBody: 将内容返回给browser\n@RestController: @Controller + @ResponseBody\n@Mapper：Mybatis注解  写在接口上 和 mapper.xml对应\n@Transactional: 事务注解 要么同时成功要么同时失败\n@configurationProperties:可以通过application.yaml 设置属性\n@Validated:JSR 303 校验\n@Jsonignore: json序列化时忽略属性\n@Configuration\n@EnableScheduling\n@Scheduled(cron &#x3D; “0 3 17 * * ?”): 秒 分 时 日 月 周 年\n年一般不写 星期几一般写？即不做要求 *表示每隔一个unit都要执行一次\n整合Mapper.xml和Mapper接口对应 \nMapper可以理解为直接操作数据库的接口，需要封装在DAO (data access object)里面作为属性 加了一层\n把所有公共的增删改查操作抽离出来写在BaseMapper里面 用泛型 之后每需要增加一张表就创建一个Mapper接口 指定Type\n由于在Mapper外封装了DAO，所以也需要把所有DAO的公共操作拉出来，封装为BaseDAO， 之后创建的表对应一个新创建的DAO，具体指定类型即可扩展\n为什么要拆为Mapper和DAO：\nMapper里的操作比较死板，就是MySQL的增删改查，不好定制化\n加一层DAO可灵活满足需求\n为什么要有Param：\n刚开始参数很少Param和User属性都相同，理解不了为什么不直接转为User?\n后来开始有除了User属性以外的参数 就知道Param类的用处了\nSpringMVCModel：后端 （业务逻辑 数据处理）\nView：前端 （前端展示）\nController:负责交接处理 \n演进过程Tomcat + JSP + Servlet -&gt; SpringMVC -&gt; SpringBoot\nSpringCloudTomcatWEB服务器\n可作为独立的服务器来运行 JSP 和 Servlets\n现在不用自己配了 了解即可\n配置环境变量\nCATALINA_HOME：XX\\apache-tomcat-9.0.69\nPath:%CATALINA_HOME%\\bin\nstartup启动\nJSPJava Server Pages\n估计快淘汰了 适当了解\n&lt;%content%&gt;\n&lt;html&gt;\n    &lt;head&gt;\n           &lt;title&gt;第一个 JSP 程序&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n           &lt;%\n                  out.println(&quot;Hello World！&quot;);\n           %&gt;\n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nREST ful 风格@RequestMapping(value = \"/fixExceptionalPod/&#123;id&#125;\", method = RequestMethod.PATCH)\npublic Map&lt;String, Object> fixExceptionalPod(@PathVariable int id) &#123;\n    LOG.info(\"开始处理异常pod的标记！\");\n    try &#123;\n        return result(podManageService.fixExceptionalPod(id));\n    &#125; catch (Exception e) &#123;\n        throw e;\n    &#125;\n&#125;\n\n\n\n\nGET：读取（Read）\nPOST：新建（Create）\nPUT：更新（Update）\nPATCH：更新（Update），通常是部分更新\nDELETE：删除（Delete）\n\n","slug":"SpringLearning","date":"2023-03-02T08:15:34.000Z","categories_index":"learning","tags_index":"Java,Spring","author_index":"Sihan Chen"},{"id":"e18ef9199ee439813c2a9daa0bdcd42b","title":"MybatisLearning","content":"MybatisLearningMyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。\nidea自动生成模板是真的好用 ：dao entity xml\nSqlSessionFactory &amp;&amp; SqlSessionSqlSessionFactory :全局唯一 单例模式 一个实例对应一个数据库\nSqlSession：每个线程都应该有它自己的 SqlSession 实例 打开之后要确保关闭\nString resource = \"org/mybatis/example/mybatis-config.xml\";\nInputStream inputStream = Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\n//推荐使用mapper\n//mapper只在代码块中起作用 之后会释放\ntry (SqlSession session = sqlSessionFactory.openSession()) &#123;\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  Blog blog = mapper.selectBlog(101);\n&#125;\n\nDEMOMySQL建表\nCREATE DATABASE &#96;mybatis&#96;;\nUSE &#96;mybatis&#96;;\nDROP TABLE IF EXISTS &#96;user&#96;;\nCREATE TABLE &#96;user&#96; (\n  &#96;id&#96; int(20) NOT NULL,\n  &#96;name&#96; varchar(30) DEFAULT NULL,\n  &#96;pwd&#96; varchar(30) DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;\ninsert  into &#96;user&#96;(&#96;id&#96;,&#96;name&#96;,&#96;pwd&#96;) values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;);\n\nMybatisUtils\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport java.io.IOException;\nimport java.io.InputStream;\npublic class MybatisUtils &#123;\n    private static SqlSessionFactory sqlSessionFactory;\n    static &#123;\n        try &#123;\n            String resource = \"mybatis-config.xml\";\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n    //获取SqlSession连接\n    public static SqlSession getSession()&#123;\n        return sqlSessionFactory.openSession();\n    &#125;\n&#125;\n\n数据表映射\npublic class User &#123;\n    private int id;  //id\n    private String name;   //姓名\n    private String pwd;   //密码\n    //构造,有参,无参\n    //set/get\n    //toString()\n&#125;\n\nCRUD映射\nimport com.kuang.pojo.User;\nimport java.util.List;\npublic interface UserMapper &#123;\n    List&lt;User> selectUser();\n&#125;\n\nxml配置\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.kuang.dao.UserMapper\">\n  &lt;select id=\"selectUser\" resultType=\"com.kuang.pojo.User\">\n    select * from user\n  &lt;/select>\n&lt;/mapper>\n\npublic class MyTest &#123;\n    @Test\n    public void selectUser() &#123;\n        SqlSession session = MybatisUtils.getSession();\n        UserMapper mapper = session.getMapper(UserMapper.class);\n        List&lt;User> users = mapper.selectUser();\n        for (User user: users)&#123;\n            System.out.println(user);\n        &#125;\n        session.close();\n    &#125;\n&#125;\n\nXML配置&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;environments default=\"development\">\n  &lt;environment id=\"development\">\n    &lt;transactionManager type=\"JDBC\">\n      &lt;property name=\"...\" value=\"...\"/>\n    &lt;/transactionManager>\n    &lt;dataSource type=\"POOLED\">\n      &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/>\n      &lt;property name=\"url\" value=\"$&#123;url&#125;\"/>\n      &lt;property name=\"username\" value=\"$&#123;username&#125;\"/>\n      &lt;property name=\"password\" value=\"$&#123;password&#125;\"/>\n    &lt;/dataSource>\n  &lt;/environment>\n&lt;/environments>\n\nSpringBoot改为在yaml中配置\ndemo列举工作时写的比较复杂的xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;mapper namespace=\"com.jd.kuplus.dashboard.dao.PodLifeCycleDao\">\n  &lt;resultMap id=\"BaseResultMap\" type=\"com.jd.kuplus.dashboard.entity.PodLifeCycle\">\n    &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\" />\n    &lt;result column=\"pod_id\" jdbcType=\"VARCHAR\" property=\"podId\" />\n    &lt;result column=\"pod_name\" jdbcType=\"VARCHAR\" property=\"podName\" />\n    &lt;result column=\"namespace\" jdbcType=\"VARCHAR\" property=\"namespace\" />\n    &lt;result column=\"pod_status\" jdbcType=\"TINYINT\" property=\"podStatus\" />\n    &lt;result column=\"reason\" jdbcType=\"VARCHAR\" property=\"reason\" />\n    &lt;result column=\"log_path\" jdbcType=\"VARCHAR\" property=\"logPath\" />\n    &lt;result column=\"submit_time\" jdbcType=\"TIMESTAMP\" property=\"submitTime\" />\n    &lt;result column=\"pending_time\" jdbcType=\"TIMESTAMP\" property=\"pendingTime\" />\n    &lt;result column=\"start_time\" jdbcType=\"TIMESTAMP\" property=\"startTime\" />\n    &lt;result column=\"finish_time\" jdbcType=\"TIMESTAMP\" property=\"finishTime\" />\n    &lt;result column=\"node_name\" jdbcType=\"VARCHAR\" property=\"nodeName\" />\n    &lt;result column=\"business_code\" jdbcType=\"VARCHAR\" property=\"businessCode\" />\n    &lt;result column=\"limit_cpu\" jdbcType=\"SMALLINT\" property=\"limitCpu\" />\n    &lt;result column=\"limit_gpu\" jdbcType=\"SMALLINT\" property=\"limitGpu\" />\n    &lt;result column=\"limit_memory\" jdbcType=\"SMALLINT\" property=\"limitMemory\" />\n    &lt;result column=\"max_cpu\" jdbcType=\"DECIMAL\" property=\"maxCpu\" />\n    &lt;result column=\"max_gpu\" jdbcType=\"DECIMAL\" property=\"maxGpu\" />\n    &lt;result column=\"max_memory\" jdbcType=\"DECIMAL\" property=\"maxMemory\" />\n    &lt;result column=\"avg_cpu\" jdbcType=\"DECIMAL\" property=\"avgCpu\" />\n    &lt;result column=\"avg_gpu\" jdbcType=\"DECIMAL\" property=\"avgGpu\" />\n    &lt;result column=\"avg_memory\" jdbcType=\"DECIMAL\" property=\"avgMemory\" />\n    &lt;result column=\"del_status\" jdbcType=\"TINYINT\" property=\"delStatus\" />\n    &lt;result column=\"creator_erp\" jdbcType=\"VARCHAR\" property=\"creatorErp\" />\n    &lt;result column=\"created_date\" jdbcType=\"TIMESTAMP\" property=\"createdDate\" />\n    &lt;result column=\"modified_erp\" jdbcType=\"VARCHAR\" property=\"modifiedErp\" />\n    &lt;result column=\"modified_date\" jdbcType=\"TIMESTAMP\" property=\"modifiedDate\" />\n    &lt;result column=\"cr_type\" jdbcType=\"VARCHAR\" property=\"crType\" />\n    &lt;result column=\"cr_name\" jdbcType=\"VARCHAR\" property=\"crName\" />\n    &lt;result column=\"organization_code\" jdbcType=\"VARCHAR\" property=\"organizationCode\" />\n    &lt;result column=\"resource_id\" jdbcType=\"VARCHAR\" property=\"resourceId\" />\n    &lt;result column=\"gpu_type\" jdbcType=\"VARCHAR\" property=\"gpuType\" />\n  &lt;/resultMap>\n  &lt;sql id=\"Base_Column_List\">\n    id, pod_id, pod_name, namespace, pod_status, reason, log_path, submit_time, pending_time, \n    start_time, finish_time, node_name, business_code, limit_cpu, limit_gpu, limit_memory, \n    max_cpu, max_gpu, max_memory, avg_cpu, avg_gpu, avg_memory, del_status, creator_erp, \n    created_date, modified_erp, modified_date, cr_type, cr_name, organization_code, resource_id, \n    gpu_type\n  &lt;/sql>\n  &lt;select id=\"selectByPrimaryKey\" parameterType=\"java.lang.Integer\" resultMap=\"BaseResultMap\">\n    select \n    &lt;include refid=\"Base_Column_List\" />\n    from pod_life_cycle\n    where id = #&#123;id,jdbcType=INTEGER&#125;\n  &lt;/select>\n  &lt;delete id=\"deleteByPrimaryKey\" parameterType=\"java.lang.Integer\">\n    delete from pod_life_cycle\n    where id = #&#123;id,jdbcType=INTEGER&#125;\n  &lt;/delete>\n  &lt;insert id=\"insert\" keyColumn=\"id\" keyProperty=\"id\" parameterType=\"com.jd.kuplus.dashboard.entity.PodLifeCycle\" useGeneratedKeys=\"true\">\n    insert into pod_life_cycle (pod_id, pod_name, namespace, \n      pod_status, reason, log_path, \n      submit_time, pending_time, start_time, \n      finish_time, node_name, business_code, \n      limit_cpu, limit_gpu, limit_memory, \n      max_cpu, max_gpu, max_memory, \n      avg_cpu, avg_gpu, avg_memory, \n      del_status, creator_erp, created_date, \n      modified_erp, modified_date, cr_type, \n      cr_name, organization_code, resource_id, \n      gpu_type)\n    values (#&#123;podId,jdbcType=VARCHAR&#125;, #&#123;podName,jdbcType=VARCHAR&#125;, #&#123;namespace,jdbcType=VARCHAR&#125;, \n      #&#123;podStatus,jdbcType=TINYINT&#125;, #&#123;reason,jdbcType=VARCHAR&#125;, #&#123;logPath,jdbcType=VARCHAR&#125;, \n      #&#123;submitTime,jdbcType=TIMESTAMP&#125;, #&#123;pendingTime,jdbcType=TIMESTAMP&#125;, #&#123;startTime,jdbcType=TIMESTAMP&#125;, \n      #&#123;finishTime,jdbcType=TIMESTAMP&#125;, #&#123;nodeName,jdbcType=VARCHAR&#125;, #&#123;businessCode,jdbcType=VARCHAR&#125;, \n      #&#123;limitCpu,jdbcType=SMALLINT&#125;, #&#123;limitGpu,jdbcType=SMALLINT&#125;, #&#123;limitMemory,jdbcType=SMALLINT&#125;, \n      #&#123;maxCpu,jdbcType=DECIMAL&#125;, #&#123;maxGpu,jdbcType=DECIMAL&#125;, #&#123;maxMemory,jdbcType=DECIMAL&#125;, \n      #&#123;avgCpu,jdbcType=DECIMAL&#125;, #&#123;avgGpu,jdbcType=DECIMAL&#125;, #&#123;avgMemory,jdbcType=DECIMAL&#125;, \n      #&#123;delStatus,jdbcType=TINYINT&#125;, #&#123;creatorErp,jdbcType=VARCHAR&#125;, #&#123;createdDate,jdbcType=TIMESTAMP&#125;, \n      #&#123;modifiedErp,jdbcType=VARCHAR&#125;, #&#123;modifiedDate,jdbcType=TIMESTAMP&#125;, #&#123;crType,jdbcType=VARCHAR&#125;, \n      #&#123;crName,jdbcType=VARCHAR&#125;, #&#123;organizationCode,jdbcType=VARCHAR&#125;, #&#123;resourceId,jdbcType=VARCHAR&#125;, \n      #&#123;gpuType,jdbcType=VARCHAR&#125;)\n  &lt;/insert>\n  &lt;insert id=\"insertSelective\" keyColumn=\"id\" keyProperty=\"id\" parameterType=\"com.jd.kuplus.dashboard.entity.PodLifeCycle\" useGeneratedKeys=\"true\">\n    insert into pod_life_cycle\n    &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\">\n      &lt;if test=\"podId != null\">\n        pod_id,\n      &lt;/if>\n      &lt;if test=\"podName != null\">\n        pod_name,\n      &lt;/if>\n      &lt;if test=\"namespace != null\">\n        namespace,\n      &lt;/if>\n      &lt;if test=\"podStatus != null\">\n        pod_status,\n      &lt;/if>\n      &lt;if test=\"reason != null\">\n        reason,\n      &lt;/if>\n      &lt;if test=\"logPath != null\">\n        log_path,\n      &lt;/if>\n      &lt;if test=\"submitTime != null\">\n        submit_time,\n      &lt;/if>\n      &lt;if test=\"pendingTime != null\">\n        pending_time,\n      &lt;/if>\n      &lt;if test=\"startTime != null\">\n        start_time,\n      &lt;/if>\n      &lt;if test=\"finishTime != null\">\n        finish_time,\n      &lt;/if>\n      &lt;if test=\"nodeName != null\">\n        node_name,\n      &lt;/if>\n      &lt;if test=\"businessCode != null\">\n        business_code,\n      &lt;/if>\n      &lt;if test=\"limitCpu != null\">\n        limit_cpu,\n      &lt;/if>\n      &lt;if test=\"limitGpu != null\">\n        limit_gpu,\n      &lt;/if>\n      &lt;if test=\"limitMemory != null\">\n        limit_memory,\n      &lt;/if>\n      &lt;if test=\"maxCpu != null\">\n        max_cpu,\n      &lt;/if>\n      &lt;if test=\"maxGpu != null\">\n        max_gpu,\n      &lt;/if>\n      &lt;if test=\"maxMemory != null\">\n        max_memory,\n      &lt;/if>\n      &lt;if test=\"avgCpu != null\">\n        avg_cpu,\n      &lt;/if>\n      &lt;if test=\"avgGpu != null\">\n        avg_gpu,\n      &lt;/if>\n      &lt;if test=\"avgMemory != null\">\n        avg_memory,\n      &lt;/if>\n      &lt;if test=\"delStatus != null\">\n        del_status,\n      &lt;/if>\n      &lt;if test=\"creatorErp != null\">\n        creator_erp,\n      &lt;/if>\n      &lt;if test=\"createdDate != null\">\n        created_date,\n      &lt;/if>\n      &lt;if test=\"modifiedErp != null\">\n        modified_erp,\n      &lt;/if>\n      &lt;if test=\"modifiedDate != null\">\n        modified_date,\n      &lt;/if>\n      &lt;if test=\"crType != null\">\n        cr_type,\n      &lt;/if>\n      &lt;if test=\"crName != null\">\n        cr_name,\n      &lt;/if>\n      &lt;if test=\"organizationCode != null\">\n        organization_code,\n      &lt;/if>\n      &lt;if test=\"resourceId != null\">\n        resource_id,\n      &lt;/if>\n      &lt;if test=\"gpuType != null\">\n        gpu_type,\n      &lt;/if>\n    &lt;/trim>\n    &lt;trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\">\n      &lt;if test=\"podId != null\">\n        #&#123;podId,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"podName != null\">\n        #&#123;podName,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"namespace != null\">\n        #&#123;namespace,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"podStatus != null\">\n        #&#123;podStatus,jdbcType=TINYINT&#125;,\n      &lt;/if>\n      &lt;if test=\"reason != null\">\n        #&#123;reason,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"logPath != null\">\n        #&#123;logPath,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"submitTime != null\">\n        #&#123;submitTime,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"pendingTime != null\">\n        #&#123;pendingTime,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"startTime != null\">\n        #&#123;startTime,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"finishTime != null\">\n        #&#123;finishTime,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"nodeName != null\">\n        #&#123;nodeName,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"businessCode != null\">\n        #&#123;businessCode,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"limitCpu != null\">\n        #&#123;limitCpu,jdbcType=SMALLINT&#125;,\n      &lt;/if>\n      &lt;if test=\"limitGpu != null\">\n        #&#123;limitGpu,jdbcType=SMALLINT&#125;,\n      &lt;/if>\n      &lt;if test=\"limitMemory != null\">\n        #&#123;limitMemory,jdbcType=SMALLINT&#125;,\n      &lt;/if>\n      &lt;if test=\"maxCpu != null\">\n        #&#123;maxCpu,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"maxGpu != null\">\n        #&#123;maxGpu,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"maxMemory != null\">\n        #&#123;maxMemory,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"avgCpu != null\">\n        #&#123;avgCpu,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"avgGpu != null\">\n        #&#123;avgGpu,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"avgMemory != null\">\n        #&#123;avgMemory,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"delStatus != null\">\n        #&#123;delStatus,jdbcType=TINYINT&#125;,\n      &lt;/if>\n      &lt;if test=\"creatorErp != null\">\n        #&#123;creatorErp,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"createdDate != null\">\n        #&#123;createdDate,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"modifiedErp != null\">\n        #&#123;modifiedErp,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"modifiedDate != null\">\n        #&#123;modifiedDate,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"crType != null\">\n        #&#123;crType,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"crName != null\">\n        #&#123;crName,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"organizationCode != null\">\n        #&#123;organizationCode,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"resourceId != null\">\n        #&#123;resourceId,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"gpuType != null\">\n        #&#123;gpuType,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n    &lt;/trim>\n  &lt;/insert>\n  &lt;update id=\"updateByPrimaryKeySelective\" parameterType=\"com.jd.kuplus.dashboard.entity.PodLifeCycle\">\n    update pod_life_cycle\n    &lt;set>\n      &lt;if test=\"podId != null\">\n        pod_id = #&#123;podId,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"podName != null\">\n        pod_name = #&#123;podName,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"namespace != null\">\n        namespace = #&#123;namespace,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"podStatus != null\">\n        pod_status = #&#123;podStatus,jdbcType=TINYINT&#125;,\n      &lt;/if>\n      &lt;if test=\"reason != null\">\n        reason = #&#123;reason,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"logPath != null\">\n        log_path = #&#123;logPath,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"submitTime != null\">\n        submit_time = #&#123;submitTime,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"pendingTime != null\">\n        pending_time = #&#123;pendingTime,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"startTime != null\">\n        start_time = #&#123;startTime,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"finishTime != null\">\n        finish_time = #&#123;finishTime,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"nodeName != null\">\n        node_name = #&#123;nodeName,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"businessCode != null\">\n        business_code = #&#123;businessCode,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"limitCpu != null\">\n        limit_cpu = #&#123;limitCpu,jdbcType=SMALLINT&#125;,\n      &lt;/if>\n      &lt;if test=\"limitGpu != null\">\n        limit_gpu = #&#123;limitGpu,jdbcType=SMALLINT&#125;,\n      &lt;/if>\n      &lt;if test=\"limitMemory != null\">\n        limit_memory = #&#123;limitMemory,jdbcType=SMALLINT&#125;,\n      &lt;/if>\n      &lt;if test=\"maxCpu != null\">\n        max_cpu = #&#123;maxCpu,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"maxGpu != null\">\n        max_gpu = #&#123;maxGpu,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"maxMemory != null\">\n        max_memory = #&#123;maxMemory,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"avgCpu != null\">\n        avg_cpu = #&#123;avgCpu,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"avgGpu != null\">\n        avg_gpu = #&#123;avgGpu,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"avgMemory != null\">\n        avg_memory = #&#123;avgMemory,jdbcType=DECIMAL&#125;,\n      &lt;/if>\n      &lt;if test=\"delStatus != null\">\n        del_status = #&#123;delStatus,jdbcType=TINYINT&#125;,\n      &lt;/if>\n      &lt;if test=\"creatorErp != null\">\n        creator_erp = #&#123;creatorErp,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"createdDate != null\">\n        created_date = #&#123;createdDate,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"modifiedErp != null\">\n        modified_erp = #&#123;modifiedErp,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"modifiedDate != null\">\n        modified_date = #&#123;modifiedDate,jdbcType=TIMESTAMP&#125;,\n      &lt;/if>\n      &lt;if test=\"crType != null\">\n        cr_type = #&#123;crType,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"crName != null\">\n        cr_name = #&#123;crName,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"organizationCode != null\">\n        organization_code = #&#123;organizationCode,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"resourceId != null\">\n        resource_id = #&#123;resourceId,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n      &lt;if test=\"gpuType != null\">\n        gpu_type = #&#123;gpuType,jdbcType=VARCHAR&#125;,\n      &lt;/if>\n    &lt;/set>\n    where id = #&#123;id,jdbcType=INTEGER&#125;\n  &lt;/update>\n  &lt;update id=\"updateByPrimaryKey\" parameterType=\"com.jd.kuplus.dashboard.entity.PodLifeCycle\">\n    update pod_life_cycle\n    set pod_id = #&#123;podId,jdbcType=VARCHAR&#125;,\n      pod_name = #&#123;podName,jdbcType=VARCHAR&#125;,\n      namespace = #&#123;namespace,jdbcType=VARCHAR&#125;,\n      pod_status = #&#123;podStatus,jdbcType=TINYINT&#125;,\n      reason = #&#123;reason,jdbcType=VARCHAR&#125;,\n      log_path = #&#123;logPath,jdbcType=VARCHAR&#125;,\n      submit_time = #&#123;submitTime,jdbcType=TIMESTAMP&#125;,\n      pending_time = #&#123;pendingTime,jdbcType=TIMESTAMP&#125;,\n      start_time = #&#123;startTime,jdbcType=TIMESTAMP&#125;,\n      finish_time = #&#123;finishTime,jdbcType=TIMESTAMP&#125;,\n      node_name = #&#123;nodeName,jdbcType=VARCHAR&#125;,\n      business_code = #&#123;businessCode,jdbcType=VARCHAR&#125;,\n      limit_cpu = #&#123;limitCpu,jdbcType=SMALLINT&#125;,\n      limit_gpu = #&#123;limitGpu,jdbcType=SMALLINT&#125;,\n      limit_memory = #&#123;limitMemory,jdbcType=SMALLINT&#125;,\n      max_cpu = #&#123;maxCpu,jdbcType=DECIMAL&#125;,\n      max_gpu = #&#123;maxGpu,jdbcType=DECIMAL&#125;,\n      max_memory = #&#123;maxMemory,jdbcType=DECIMAL&#125;,\n      avg_cpu = #&#123;avgCpu,jdbcType=DECIMAL&#125;,\n      avg_gpu = #&#123;avgGpu,jdbcType=DECIMAL&#125;,\n      avg_memory = #&#123;avgMemory,jdbcType=DECIMAL&#125;,\n      del_status = #&#123;delStatus,jdbcType=TINYINT&#125;,\n      creator_erp = #&#123;creatorErp,jdbcType=VARCHAR&#125;,\n      created_date = #&#123;createdDate,jdbcType=TIMESTAMP&#125;,\n      modified_erp = #&#123;modifiedErp,jdbcType=VARCHAR&#125;,\n      modified_date = #&#123;modifiedDate,jdbcType=TIMESTAMP&#125;,\n      cr_type = #&#123;crType,jdbcType=VARCHAR&#125;,\n      cr_name = #&#123;crName,jdbcType=VARCHAR&#125;,\n      organization_code = #&#123;organizationCode,jdbcType=VARCHAR&#125;,\n      resource_id = #&#123;resourceId,jdbcType=VARCHAR&#125;,\n      gpu_type = #&#123;gpuType,jdbcType=VARCHAR&#125;\n    where id = #&#123;id,jdbcType=INTEGER&#125;\n  &lt;/update>\n\n  &lt;select id=\"selectWithDynamicCondition\" parameterType=\"com.jd.kuplus.dashboard.entity.SqlInfo\" resultMap=\"BaseResultMap\">\n    $&#123;sql&#125;\n  &lt;/select>\n\n  &lt;select id=\"selectNamespace\" resultType=\"java.lang.String\">\n    select distinct namespace from pod_life_cycle\n  &lt;/select>\n\n  &lt;select id=\"selectCrType\" resultType=\"java.lang.String\">\n    select distinct cr_type from pod_life_cycle\n  &lt;/select>\n\n  &lt;select id=\"selectNodeName\" resultType=\"java.lang.String\">\n    select distinct node_name from pod_life_cycle\n  &lt;/select>\n\n  &lt;select id=\"selectAllWithMultiCond\" parameterType=\"com.jd.kuplus.dashboard.entity.SqlInfo\" resultMap=\"BaseResultMap\">\n    select\n    &lt;include refid=\"Base_Column_List\" />\n    from pod_life_cycle\n    &lt;where>\n      del_status = 0\n      &lt;if test=\"namespace != null\">\n        and\n        &lt;foreach item=\"item\" index=\"index\" collection=\"namespace\"\n                 open=\"namespace in (\" separator=\",\" close=\")\">\n          #&#123;item&#125;\n        &lt;/foreach>\n      &lt;/if>\n      &lt;if test=\"crType != null\">\n        and\n        &lt;foreach item=\"item\" index=\"index\" collection=\"crType\"\n                 open=\"cr_type in (\" separator=\",\" close=\")\">\n          #&#123;item&#125;\n        &lt;/foreach>\n      &lt;/if>\n      &lt;if test=\"nodeName != null\">\n        and\n        &lt;foreach item=\"item\" index=\"index\" collection=\"nodeName\"\n                 open=\"node_name in (\" separator=\",\" close=\")\">\n          #&#123;item&#125;\n        &lt;/foreach>\n      &lt;/if>\n      &lt;if test=\"taskStatus != null\">\n        &lt;choose>\n          &lt;when test=\"taskStatus == 0\">\n            and not exists (select * from reporter_record where pod_life_cycle.id = reporter_record.pod_life_cycle_id)\n          &lt;/when>\n          &lt;when test=\"taskStatus == 1\">\n            and exists (select * from reporter_record where pod_life_cycle.id = reporter_record.pod_life_cycle_id and reporter_record.del_status = 0)\n          &lt;/when>\n          &lt;otherwise>\n            and exists (select * from reporter_record where pod_life_cycle.id = reporter_record.pod_life_cycle_id)\n            and not exists (select * from reporter_record where pod_life_cycle.id = reporter_record.pod_life_cycle_id and reporter_record.del_status = 0)\n          &lt;/otherwise>\n        &lt;/choose>\n      &lt;/if>\n      &lt;if test=\"podStatus != null\">\n        &lt;choose>\n          &lt;when test=\"podStatus == 4\">\n            and pod_life_cycle.pod_status = 4 and pod_life_cycle.reason != 'Killed'\n          &lt;/when>\n          &lt;when test=\"podStatus == 5\">\n            and pod_life_cycle.pod_status = 4 and pod_life_cycle.reason = 'Killed'\n          &lt;/when>\n          &lt;otherwise>\n            and pod_life_cycle.pod_status = #&#123;podStatus,jdbcType=TINYINT&#125;\n          &lt;/otherwise>\n        &lt;/choose>\n      &lt;/if>\n      &lt;if test=\"key != null\">\n        and (pod_name like '%$&#123;key&#125;%' or cr_name like '%$&#123;key&#125;%' or creator_erp like '%$&#123;key&#125;%')\n      &lt;/if>\n    &lt;/where>\n    order by submit_time desc\n  &lt;/select>\n\n  &lt;select id=\"countWithMultiCond\" parameterType=\"com.jd.kuplus.dashboard.entity.SqlInfo\" resultType=\"java.lang.Integer\">\n    select count(*)\n    from pod_life_cycle\n    &lt;where>\n      del_status = 0\n      &lt;if test=\"namespace != null\">\n        and\n        &lt;foreach item=\"item\" index=\"index\" collection=\"namespace\"\n                 open=\"namespace in (\" separator=\",\" close=\")\">\n          #&#123;item&#125;\n        &lt;/foreach>\n      &lt;/if>\n      &lt;if test=\"crType != null\">\n        and\n        &lt;foreach item=\"item\" index=\"index\" collection=\"crType\"\n                 open=\"cr_type in (\" separator=\",\" close=\")\">\n          #&#123;item&#125;\n        &lt;/foreach>\n      &lt;/if>\n      &lt;if test=\"nodeName != null\">\n        and\n        &lt;foreach item=\"item\" index=\"index\" collection=\"nodeName\"\n                 open=\"node_name in (\" separator=\",\" close=\")\">\n          #&#123;item&#125;\n        &lt;/foreach>\n      &lt;/if>\n      &lt;if test=\"taskStatus != null\">\n        &lt;choose>\n          &lt;when test=\"taskStatus == 0\">\n            and not exists (select * from reporter_record where pod_life_cycle.id = reporter_record.pod_life_cycle_id)\n          &lt;/when>\n          &lt;when test=\"taskStatus == 1\">\n            and exists (select * from reporter_record where pod_life_cycle.id = reporter_record.pod_life_cycle_id and reporter_record.del_status = 0)\n          &lt;/when>\n          &lt;otherwise>\n            and exists (select * from reporter_record where pod_life_cycle.id = reporter_record.pod_life_cycle_id)\n            and not exists (select * from reporter_record where pod_life_cycle.id = reporter_record.pod_life_cycle_id and reporter_record.del_status = 0)\n          &lt;/otherwise>\n        &lt;/choose>\n      &lt;/if>\n      &lt;if test=\"podStatus != null\">\n        &lt;choose>\n          &lt;when test=\"podStatus == 4\">\n            and pod_life_cycle.pod_status = 4 and pod_life_cycle.reason != 'Killed'\n          &lt;/when>\n          &lt;when test=\"podStatus == 5\">\n            and pod_life_cycle.pod_status = 4 and pod_life_cycle.reason = 'Killed'\n          &lt;/when>\n          &lt;otherwise>\n            and pod_life_cycle.pod_status = #&#123;podStatus,jdbcType=TINYINT&#125;\n          &lt;/otherwise>\n        &lt;/choose>\n      &lt;/if>\n      &lt;if test=\"key != null\">\n        and (pod_name like '%$&#123;key&#125;%' or cr_name like '%$&#123;key&#125;%' or creator_erp like '%$&#123;key&#125;%')\n      &lt;/if>\n    &lt;/where>\n  &lt;/select>\n&lt;/mapper>\n\n\n\nXML SQL映射mapper中的内容\nselect&lt;select id=\"selectPerson\" parameterType=\"int\" resultType=\"hashmap\">\n  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;\n&lt;/select>\n\n语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值\n@Param(“id”) int id 传入参数\n或者直接传入map\nUser selectUserByNP2(Map&lt;String,Object> map);\n\n&lt;select id=\"selectUserByNP2\" parameterType=\"map\" resultType=\"com.kuang.pojo.User\">\n  select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;\n&lt;/select>\n\ninsert&lt;insert\n  id=\"insertAuthor\"\n  parameterType=\"domain.blog.Author\"\n  flushCache=\"true\"\n  statementType=\"PREPARED\"\n  keyProperty=\"\"\n  keyColumn=\"\"\n  useGeneratedKeys=\"\"\n  timeout=\"20\"\n  resultType=\"\">\n    \n&lt;/insert>\n\n//添加一个用户\nint addUser(User user);\n\n&lt;insert id=\"addUser\" parameterType=\"com.kuang.pojo.User\">\n     insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)\n&lt;/insert>\n\n注意提交事务\n@Test\npublic void testAddUser() &#123;\n    SqlSession session = MybatisUtils.getSession();\n    UserMapper mapper = session.getMapper(UserMapper.class);\n    User user = new User(5,\"王五\",\"zxcvbn\");\n    int i = mapper.addUser(user);\n    System.out.println(i);\n    session.commit(); //提交事务,重点!不写的话不会提交到数据库\n    session.close();\n&#125;\n\nupdate&lt;update\n  id=\"updateAuthor\"\n  parameterType=\"domain.blog.Author\"\n  flushCache=\"true\"\n  statementType=\"PREPARED\"\n  timeout=\"20\">\n&lt;/update>\n\n//修改一个用户\nint updateUser(User user);\n\n&lt;update id=\"updateUser\" parameterType=\"com.kuang.pojo.User\">\n    update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;\n&lt;/update>\n\n注意commit!\ndelete&lt;delete\n  id=\"deleteAuthor\"\n  parameterType=\"domain.blog.Author\"\n  flushCache=\"true\"\n  statementType=\"PREPARED\"\n  timeout=\"20\">\n&lt;/delete>\n\n//根据id删除用户\nint deleteUser(int id);\n\n&lt;delete id=\"deleteUser\" parameterType=\"int\">\n    delete from user where id = #&#123;id&#125;\n&lt;/delete>\n\nsql&lt;sql id=\"userColumns\"> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password &lt;/sql>\n&lt;select id=\"selectUsers\" resultType=\"map\">\n  select\n    &lt;include refid=\"userColumns\">&lt;property name=\"alias\" value=\"t1\"/>&lt;/include>,\n    &lt;include refid=\"userColumns\">&lt;property name=\"alias\" value=\"t2\"/>&lt;/include>\n  from some_table t1\n    cross join some_table t2\n&lt;/select>\n\nparameterType&lt;select id=\"selectUsers\" resultType=\"User\">\n  select id, username, password\n  from users\n  where id = #&#123;id&#125;\n&lt;/select>\n&lt;insert id=\"insertUser\" parameterType=\"User\">\n  insert into users (id, username, password)\n  values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)\n&lt;/insert>\n\nresultType//hashmap\nresultType=\"map\"\n//POJO Java bean\nresultType=\"com.someapp.model.User\" \n\nresultMap显示配置\n&lt;resultMap id=\"UserMap\" type=\"User\">\n    &lt;!-- id为主键 -->\n    &lt;id column=\"id\" property=\"id\"/>\n    &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 -->\n    &lt;result column=\"name\" property=\"name\"/>\n    &lt;result column=\"pwd\" property=\"password\"/>\n&lt;/resultMap>\n&lt;select id=\"selectUserById\" resultMap=\"UserMap\">\n    select id , name , pwd from user where id = #&#123;id&#125;\n&lt;/select>\n\n如果属性名和列名能完全对上 resultType可以选为map \nid &amp;&amp; result&lt;id property=\"id\" column=\"post_id\"/>\n&lt;result property=\"subject\" column=\"post_subject\"/>\n\n表述MySQL和java对象属性的映射关系\nid用于主键\nconstructorassociationcollectionresultSetdiscriminator分页SELECT * FROM table LIMIT stratIndex，pageSize\n\n\n\n自动映射缓存&lt;cache\n  eviction=\"FIFO\"\n  flushInterval=\"60000\"\n  size=\"512\"\n  readOnly=\"true\"/>\n\n一级缓存本地缓存 默认开启\n\n每个sqlSession缓存独立\n\n不用缓存的情况：\n\n查询之间做了增删改条件\n不同 \n缓存中不存在数据\n手动清除\n\n二级缓存需要手动开启\nnamespace缓存 mapper里的缓存\n\n只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据\n查出的数据都会被默认先放在一级缓存中\n只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中\n\n动态SQLwhere里面套if 或者 choose 或者include\nupdate set里面套if 或者 choose 或者 include\nif&lt;select id=\"findActiveBlogLike\"\n     resultType=\"Blog\">\n  SELECT * FROM BLOG WHERE state = ‘ACTIVE’\n  &lt;if test=\"title != null\">\n    AND title like #&#123;title&#125;\n  &lt;/if>\n  &lt;if test=\"author != null and author.name != null\">\n    AND author_name like #&#123;author.name&#125;\n  &lt;/if>\n&lt;/select>\n\nchoose &amp;&amp; when &amp;&amp; otherwise有点类似switch\n&lt;select id=\"findActiveBlogLike\"\n     resultType=\"Blog\">\n  SELECT * FROM BLOG WHERE state = ‘ACTIVE’\n  &lt;choose>\n    &lt;when test=\"title != null\">\n      AND title like #&#123;title&#125;\n    &lt;/when>\n    &lt;when test=\"author != null and author.name != null\">\n      AND author_name like #&#123;author.name&#125;\n    &lt;/when>\n    &lt;otherwise>\n      AND featured = 1\n    &lt;/otherwise>\n  &lt;/choose>\n&lt;/select>\n\nwhere &amp;&amp; set &amp;&amp; trim动态加条件 和 动态update 也可以用trim实现\n&lt;select id=\"findActiveBlogLike\"\n     resultType=\"Blog\">\n  SELECT * FROM BLOG\n  &lt;where>\n    &lt;if test=\"state != null\">\n         state = #&#123;state&#125;\n    &lt;/if>\n    &lt;if test=\"title != null\">\n        AND title like #&#123;title&#125;\n    &lt;/if>\n    &lt;if test=\"author != null and author.name != null\">\n        AND author_name like #&#123;author.name&#125;\n    &lt;/if>\n  &lt;/where>\n&lt;/select>\n\n&lt;update id=\"updateAuthorIfNecessary\">\n  update Author\n    &lt;set>\n      &lt;if test=\"username != null\">username=#&#123;username&#125;,&lt;/if>\n      &lt;if test=\"password != null\">password=#&#123;password&#125;,&lt;/if>\n      &lt;if test=\"email != null\">email=#&#123;email&#125;,&lt;/if>\n      &lt;if test=\"bio != null\">bio=#&#123;bio&#125;&lt;/if>\n    &lt;/set>\n  where id=#&#123;id&#125;\n&lt;/update>\n\nforeach以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值\n&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\">\n  SELECT *\n  FROM POST P\n  &lt;where>\n    &lt;foreach item=\"item\" index=\"index\" collection=\"list\"\n        open=\"ID in (\" separator=\",\" close=\")\" nullable=\"true\">\n          #&#123;item&#125;\n    &lt;/foreach>\n  &lt;/where>\n&lt;/select>\n\nscript主要用在注解里\n@Update(&#123;\"&lt;script>\",\n  \"update Author\",\n  \"  &lt;set>\",\n  \"    &lt;if test='username != null'>username=#&#123;username&#125;,&lt;/if>\",\n  \"    &lt;if test='password != null'>password=#&#123;password&#125;,&lt;/if>\",\n  \"    &lt;if test='email != null'>email=#&#123;email&#125;,&lt;/if>\",\n  \"    &lt;if test='bio != null'>bio=#&#123;bio&#125;&lt;/if>\",\n  \"  &lt;/set>\",\n  \"where id=#&#123;id&#125;\",\n  \"&lt;/script>\"&#125;)\nvoid updateAuthorValues(Author author);\n\nbind在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文\n&lt;select id=\"selectBlogsLike\" resultType=\"Blog\">\n  &lt;bind name=\"pattern\" value=\"'%' + _parameter.getTitle() + '%'\" />\n  SELECT * FROM BLOG\n  WHERE title LIKE #&#123;pattern&#125;\n&lt;/select>\n\n动态SQL实例\n  select\n  &lt;include refid=\"Base_Column_List\" />\n  from pod_life_cycle\n  &lt;where>\n    del_status = 0\n    &lt;if test=\"namespace != null\">\n      and\n      &lt;foreach item=\"item\" index=\"index\" collection=\"namespace\"\n               open=\"namespace in (\" separator=\",\" close=\")\">\n        #&#123;item&#125;\n      &lt;/foreach>\n    &lt;/if>\n    &lt;if test=\"crType != null\">\n      and\n      &lt;foreach item=\"item\" index=\"index\" collection=\"crType\"\n               open=\"cr_type in (\" separator=\",\" close=\")\">\n        #&#123;item&#125;\n      &lt;/foreach>\n    &lt;/if>\n    &lt;if test=\"nodeName != null\">\n      and\n      &lt;foreach item=\"item\" index=\"index\" collection=\"nodeName\"\n               open=\"node_name in (\" separator=\",\" close=\")\">\n        #&#123;item&#125;\n      &lt;/foreach>\n    &lt;/if>\n    &lt;if test=\"isException == 1\">\n      and exists (select * from reporter_record where pod_life_cycle.id = reporter_record.pod_life_cycle_id and reporter_record.del_status = 0)\n    &lt;/if>\n    &lt;if test=\"key != null\">\n      and pod_name like '%$&#123;key&#125;%' or cr_name like '%$&#123;key&#125;%' or creator_erp like '%$&#123;key&#125;%'\n    &lt;/if>\n  &lt;/where>\n&lt;/select>\n\n\n\n注解有了注解就不用写mapper.xml了 只需要在核心配置文件中注册 \n注意mapper.xml与mapper接口对应 需要在核心配置文件中注册 （springboot好像注册都不用了）\nSelect//根据id查询用户\n@Select(\"select * from user where id = #&#123;id&#125;\")\nUser selectUserById(@Param(\"id\") int id);\n\nupdate//修改一个用户\n@Update(\"update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;\")\nint updateUser(User user);\n\nInsert//添加一个用户\n@Insert(\"insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)\")\nint addUser(User user);\n\nDelete @Delete(\"delete from user where id = #&#123;id&#125;\")\nint deleteUser(@Param(\"id\")int id);\n\n​                                                            \n\n如果参数是 JavaBean ， 则不能使用@Param。\n不使用@Param注解时，参数只能有一个，并且是Javabean。\n\nSQL语句构建器相比于String拼写更加方便 但是不推荐使用\n日志Tips$用？在sql中进行占位\n#传入的是字符串 自动加上&#96;&#96;防注入\n能用#就别用$\n\n","slug":"MybatisLearning","date":"2023-03-02T08:07:12.000Z","categories_index":"learning","tags_index":"Java,Mybatis","author_index":"Sihan Chen"},{"id":"cc9917eea87f0911c627dfa9deeeca84","title":"INTERN","content":"ByteDance, Beijing\n\n\n\n\n\n\n\n\n\nBack-end Intern of Master Data Department of Lark SuiteResponsible for data management (query, storage and transfer) and participated in three important projects as below:\nMessage Deduplication of the ETL Module\nCombined the messages with same content in the Message Queue of ETL module, which reduced the pressure of query interfaces of Vault Service\nChose distribution architecture based on Partition Key of RocketMQ rather than centralized architecture based on Redis, to avoid complex and inefficient lock operation and consideration\nChanged the offset of RocketMQ to the one before fault for disaster recovery, which assured the consistency of data and no messages loss\n\nOptimization of Data Table Design\nChanged the manage_relations table which has been put into use into job_data table, because of the poor performance on both function and efficiency of the former one, due to the imperfect design before\nKept two tables working simultaneously using double-write strategy to avoid data loss and pollution\nWrote Go script to assure the correctness of combination and storage of data\nIncreased the rate of flow online slowly, which prevented huge online fault during the table-change process\n\nMultiGeo Function of Vault Service\nTransferred the sensitive information of Singapore employee from China to Singapore, due to the legal requirements\nUsed the strategy of soft deletion followed by a hard deletion, which avoided data loss in transfer process\nAdded the support for cross-region storage and cross-region query for Vault Service\n\nJD.com, Beijing\n\n\n\n\n\n\n\n\n\nBack-end Development Engineer of Technology and Product Innovation Department of JD TechnologyParticipated in the development of Ku+ AI platform, a software based on AutoML and MLOps, designed for enterprise-level AI research\nOSS Data Transfer\nBuilt a Java script to flatten the file tree in OSS(Object Storage Service), wrote the results into MySQL database as persistent management via mybatis\nGuaranteed the data consistency via transaction mechanism\n\nDept Tree Generator\nDeployed a scheduled task to generate department Tree everyday\nUsed incremental-processing strategy, assuring the efficiency of scheduled task\nConsidered all departmental adjustments, carried out black and white box test\n\nExceptional Pod Reporter and Dashboard\nBuilt a reporter to monitor the health conditions of pod, then sent exception details to pod owner and system administrator;a exceptional task dashboard, showing exceptional information of pod, including the status and description from Kubernetes\nAdded dynamic configuration function, supporting hot-swap the monitor rules (via mybatis dynamic SQL) and message receiver\nUsed cache layer (redis) to speed up the back-end query interface\n\nModel Deployment Service\nDeveloped the online deployment service, made the algorithm model as a RESTful API, holding the computing resources to assure the real-time capability\nBuilt the offline deployment service to process the offline data, then wrote the results back into MySQL\n\nComputing Resources Scheduler\nBuilt a computing resources scheduler based on Docker and Kubernetes to improve the availability of the resources\nImplemented several scheduling strategies, including Binpack, Spread, Coscheduling, Gang scheduling\n\n\t   \n","slug":"intern","date":"2022-11-02T14:33:58.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"},{"id":"b39baedab164cf8277508d2f603d42e1","title":"MESSAGE BOARD","content":"Just a Message Board, feel free to talk with me in the comment area, if you want!","slug":"messageboard","date":"2022-11-02T13:25:43.000Z","categories_index":"","tags_index":"","author_index":"Sihan Chen"},{"id":"bcbd58ac5f0b48fdbd3c6d1a1cb9f5d7","title":"GoLearning","content":"GoLearning记录一下Go的学习 (主要是ByteDance实习用)，方便以后复习，如果能帮到其他人就更好了\n\nGo modgo mod init\ngo mod tidy\ngo mod download\ngo get XXX@branch_name  XX@commit-id\n\n\n\n数据类型值类型 引用类型\n布尔型：默认为false\n数字类型:默认为0\n\n(u)int(8&#x2F;16&#x2F;32&#x2F;64)\nByte\n\n字符串类型：默认为””\n派生类型：默认为nil\n\n(a) 指针类型（Pointer）:*type\n(b) 数组类型:[]type\n(c) 结构化类型(struct):\n(d) Channel 类型:chan int\n(e) 函数类型 func(type) type\n(f) 切片类型\n(g) 接口类型（interface）\n(h) Map 类型:map[type] type\n\n类型转换\nvar sum int = 17\n//sum := 17也可\nfloat32(sum)\n\n类型断言（只用于空接口 interafce{}）\n接口都包括两个属性 一个是值一个是类型\nfunc ManageInterface(i interface&#123;&#125;) &#123;\n  //会返回一个新的变量 带有新的指定类型 v 与 i不同 i的类型不发生变化\n\tv, ok := i.(string)\n\tif ok &#123;\n\t\tfmt.Println(v)\n\t&#125; else &#123;\n\t\tfmt.Println(ok)\n\t&#125;\n&#125;\n//对i空接口的的类型（一个属性）进行判断 不改变i接口的类型 如果需要改变 需要使用类型断言 改变空接口的类型属性 然后返回一个新的变量\n\tswitch i.(type) &#123;\n\tcase int:\n\t\tfmt.Println(i)\n\tcase string:\n\t\tfmt.Println(\"is int\")\n\tdefault:\n\t\tfmt.Println(\"other\")\n\t&#125;\n\n\n\n变量和常量//未进行初始化 有默认值\nvar name1,name2 type\n//自动推理 并行赋值\nvar name1,name2 = 1,2 \n//赋值\nname1 = value\n//声明变量并进行初始化\nname1,name2 := 1,2\n//声明变量并进行初始化\nvar (\n  name1 int\n  name2 bool\n)\n//全局变量声明并初始化 注意全局变量不能用:=\nvar name1,name2 = 1,2\nvar name1,name2\n//go中必须使用所有声明的变量 _表示只写 和Python不一样\nval,err = Func1(var1)\nval,_ = Func1(var1)\n\n//常量声明 初始化\nconst name1 = 1\n//常量用作枚举\nconst (\n  a = 0\n  b = 1\n  c = 2\n)\n//iota是可以被编译器修改的常量\nconst (\n    a = iota\n    b = iota\n    c = iota\n)\nconst (\n    a = iota\n    b\n    c\n)\n\n作用域全局 局部 形参\n运算符有自增&#x2F;减运算符\n异或:^\n取地址:&amp;\n取值:*\n控制流条件//if\n//注意如果只有一个cond 不要用() 后面接 &#123;&#125;\nif a == 1 &#123;\n  \n&#125; else &#123;\n  \n&#125;\n//switch var1可以是任何类型 val1,val2,val3类型必须相同\nswitch var1 &#123;\n\tcase val1:\n  ...\n  case val2,val3:\n  \tfallthrough //强制执行后面的分支\n  //不需要break\n\tdefault:\n&#125;\n//select \nselect &#123;\n  case i1 \n&#125;\n\n/*如果任意某个通信可以进行，它就执行，其他被忽略。\n如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。\n否则：\n如果有 default 子句，则执行该语句。\n如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。*/\n\n循环貌似没有while 用for代替while\nfor i := 0;i &lt;= 10 ;i++ &#123;\n  ftm.Println(i)\n&#125;\nfor k,v := range map1 &#123;\n  \n&#125;\nfor k := range map1 &#123;\n  \n&#125;\nfor _,v := range map1 &#123;\n  \n&#125;\n\n函数值传参 引用传参\nfunc max(num1,num2 int) int &#123;\n  return res\n  //可以返回多个值\n&#125;\nfunc main() &#123;\n  var res = max(a,b)\n&#125;\n\n闭包\nfunc getSequence() func() int &#123;\n   i:=0\n   return func() int &#123;\n      i+=1\n     return i  \n   &#125;\n&#125;\n\nfunc main()&#123;\n   /* nextNumber 为一个函数，函数 i 为 0 */\n   nextNumber := getSequence()  \n\n   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */\n   fmt.Println(nextNumber())\n   fmt.Println(nextNumber())\n   fmt.Println(nextNumber())\n   \n   /* 创建新的函数 nextNumber1，并查看结果 */\n   nextNumber1 := getSequence()  \n   fmt.Println(nextNumber1())\n   fmt.Println(nextNumber1())\n&#125;\n\n数组注意go中数组作为拷贝传递 \n切片(slice)作为引用传递 \nchan func map\n//自动初始化为0\nvar list [10]int\nlist := [5]int&#123;1,2,3,4,5&#125;\nvar list [MAX]*int\n//可以省略长度 type[5]int\nlist := [...]int&#123;1,2,3,4,5&#125;\n//用index初始化\nlist := [5]float32&#123;1:2.0,3:7.0&#125;\nlist[i]\n//二维数组\nlist := [2][3]int &#123;\n  &#123;1,2,3&#125;,\n  &#123;4,5,6&#125;,\n&#125;\nlist = append(list,element)\ncopye(new_list,list)\n//返回切片类型\nlist[:5]\n\nGO指针var ptr *int\nptr = &amp;name\n(param *int,param []int)\n\n结构体type Name struct &#123;\n  radius float64\n  name1 int\n  name2 float32\n&#125;\nfunc (n Name) getArea() float64 &#123;\n  //c.radius 即为 Circle 类型对象中的属性 访问属性\n  return 3.14 * n.radius * n.radius\n&#125;\nfunc main() &#123;\n  //对象初始化\n  var b1 = Books &#123;\n    radius:1.1,\n    name1:1,\n    name2:2\n  &#125;\n  //对象指针\n  var b *Book\n  b = &amp;b1\n&#125;\n\n接口注意go和java的interface完全不一样 java是侵入式 显式实现\n//注意任何类型都可以看作是interface&#123;&#125; 作为泛型理解\nvar a interface&#123;&#125;\n//interface&#123;&#125; 是可以由任意类型转换过来 但是[]string 不能转化为[]interface&#123;&#125;\n//甚至[]interface&#123;&#125;可以转化为interface&#123;&#125;\nfunc PrintAll(vals []interface&#123;&#125;) &#123;\n    for _, val := range vals &#123;\n        fmt.Println(val)\n    &#125;\n&#125;\n \nfunc main() &#123;\n    names := []string&#123;\"stanley\", \"david\", \"oscar\"&#125;\n    vals := make([]interface&#123;&#125;, len(names))\n    for i, v := range names &#123;\n        vals[i] = v\n    &#125;\n    PrintAll(vals)\n&#125;\n//interface&#123;&#125;可以进行强转\nv.(float64)\n//非interface&#123;&#125;只能\nfloat64(v)\n\n切片(slice)//len为初始长度 cap为最大长度\ns := make([]type,len,cap)\ns1 := s[:]\ns2 := s[start:end]\ns3 := s[:end]\ns4 := s[start:]\ns5 := []type&#123;&#125;\n\nrange用来进行遍历\n//遍历list\nfor i,v := range list &#123;\n  \n&#125;\nfor k,v := range map1 &#123;\n  \n&#125;\n//可以省略v k/i必须使用占位符_\n\nmaphashmap\n//声明\nvar map1 map[key_type]value_type\n//初始化 \nmap1 = make(map[key_type]value_type)\n//语法糖\nmap1 := make(map[key_type]value_type)\n//delete\ndelete(map1,key)\n//add\nmap1[key] = value\n//查看是否存在\n_,exist = map1[key]\n\n错误处理类似C语言向上return error值\n没有java python catch那套\n并发//开启新线程\ngo func_name()\n\n字符串defer defer修饰的函数的参数在声明时确定\n在函数返回时执行\npackage main\n\nimport \"fmt\"\n\nfunc main() &#123;\n\tvar a int = 5\n\tdefer fmt.Println(a)\n\ta = a + 1\n//5\n\n用defer修饰的call会等到周围的函数都执行完之后才执行，但是此call的参数会提前压入\nchan主要用于goroutine之间的交互通讯，管道(队列)\n//创建int类型的管道 设置容量为100 单位为元素的个数\nch := make(chan int，100)\n//将v放入管道\nch &lt;- v\n//从chan中接收数据 并赋给x,ok表示执行情况\nx，ok := &lt;- ch\n//for range可以遍历chan\nfor i := range c &#123;\n  fmt.Println(i)\n&#125;\n//select 伪随机的执行操作\nfunc fibonacci(c, quit chan int) &#123;\n    x, y := 0, 1\n    for &#123;\n        select &#123;\n        case c &lt;- x:\n            x, y = y, x+y\n        case &lt;-quit:\n            fmt.Println(\"quit\")\n            return\n        &#125;\n    &#125;\n&#125;\nfunc main() &#123;\n    c := make(chan int)\n    quit := make(chan int)\n    go func() &#123;\n        for i := 0; i &lt; 10; i++ &#123;\n            fmt.Println(&lt;-c)\n        &#125;\n        quit &lt;- 0\n    &#125;()\n    fibonacci(c, quit)\n&#125;\n//加上for可以无限循环\nfor &#123;\n  \n&#125;\n//timeout 如果超时 就把当前时间放进chan\ncase &lt;- time.After(time.Second * 1):\n//Timer\ntimer := time.NewTimer(time.Second * 2)\n&lt;-timer1.C\nstop := timer.Stop()\n//Ticker\nticker := time.NewTicker(time.Millisecond * 500)\ngo func() &#123;\n    for t := range ticker.C &#123;\n        fmt.Println(\"Tick at\", t)\n    &#125;\n&#125;()\n//关闭管道 关闭之后不能写入 可以读出（已发送数据、零值）\nclose(c)\n//用range遍历 会跳出\nfor i := range c &#123;\n    fmt.Println(i)\n&#125;\n//查看chan状态\ni, ok := &lt;-c\n//可以利用chan进行同步\nfunc worker(done chan bool) &#123;\n    time.Sleep(time.Second)\n    // 通知任务已完成\n    done &lt;- true\n&#125;\nfunc main() &#123;\n    done := make(chan bool, 1)\n    go worker(done)\n    // 等待任务完成 chan中出现元素 开始执行下面的代码\n    &lt;-done\n&#125;\n\n匿名函数 //返回匿名函数\n//func(i, j string) string为函数类型 返回一个函数\n func GFG() func(i, j string) string&#123; \n\t\t//创建一个函数\n     myf := func(i, j string)string&#123; \n          return i + j + \"nhooo\"\n     &#125; \n   //返回创建的函数\n    return myf \n &#125; \n    \nfunc main() &#123; \n    value := GFG() \n    fmt.Println(value(\"Welcome \", \"to \")) \n&#125;\n//创建匿名函数并执行\nfunc(i int) &#123;\n\t\tfmt.Println(i)\n\t&#125;(2)\nfmt.Println(func(c celsius) celsius &#123; return 5 &#125;(c))\n\n\ntype//重命名类型\ntype sensor func(c celsius) kelvin\n\n\n\n\n\n多线程同步注意不像java有守护线程 main不管其他线程 \n利用sync.WaitGroup 进行同步 main等其他线程执行完之后 再推出\n注意Golang与Java不一样 Javamain执行完之后线程不会结束，Golang中main执行完协程自动结束\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"sync\"\n)\n\ntype WaitGroupWrapper struct &#123;\n\tsync.WaitGroup\n&#125;\n\ntype Consumer struct &#123;\n\tdedupMap     map[string]int\n\tconsumerName string\n&#125;\n\nfunc (c Consumer) getName() string &#123;\n\treturn c.consumerName\n&#125;\n\nfunc (c Consumer) count() &#123;\n\tfor i := 0; i &lt; 10; i++ &#123;\n\t\tc.dedupMap[c.getName()] += 1\n\t\tfmt.Println(c.getName() + \":\" + strconv.Itoa(c.dedupMap[c.getName()]))\n\t&#125;\n&#125;\n\nfunc (c Consumer) getVal() int &#123;\n\treturn c.dedupMap[c.getName()]\n&#125;\n\nfunc (c Consumer) setVal(val int) &#123;\n\tc.dedupMap[c.getName()] = val\n&#125;\n\nfunc (c Consumer) consumerMain() &#123;\n\t//wg.Add(1)\n\tc.count()\n\tdefer wg.Done()\n&#125;\n\nvar wg sync.WaitGroup\n\nfunc main() &#123;\n\tc1 := Consumer&#123;make(map[string]int), \"c1\"&#125;\n\tc2 := Consumer&#123;make(map[string]int), \"c2\"&#125;\n  //注意要在main中先加\n  wg.Add(2)\n\tgo c1.consumerMain()\n\tgo c2.consumerMain()\n  //所有协程结束main才能结束\n\twg.Wait()\n\tfmt.Println(\"123\")\n&#125;\n\n\n通道//默认没有缓冲区\nch := make(chan int)\n//设置缓冲区\nch := make(chan int, 100)\n//可以用for进行遍历 本质上是while 可以阻塞\nfor i := range ch &#123;\n  \n&#125;\n\n// Write Data\nfunc write(intChan chan int) &#123;\n\tfor i := 1; i &lt;= 50; i++ &#123;\n\t\t// 放入数据\n\t\tintChan &lt;- i\n\t\tfmt.Println(\"Write Data\", i)\n\t&#125;\n  //写完之后就可以关闭channel了 关闭之后还可以读channel\n\tclose(intChan)\n&#125;\n\n// Read data\nfunc readData(intChan chan int, exitChan chan bool) &#123;\n\n\tfor  &#123;\n\t\tv, ok :=&lt;- intChan\n\t\tif !ok&#123;\n\t\t\tbreak\n\t\t&#125;\n\t\t//time.Sleep(time.Second)\n\t\tfmt.Println(\"读到数据\",v)\n\t&#125;\n\n\t// 读取完数据后，即任务完成\n    // exitChan 是一个标志，当读完数据后，向exit中存放一个true，主线程除非取出这个true，否则不停止\n\texitChan &lt;- true\n\tclose(exitChan)\n&#125;\n\nfunc main() &#123;\n\tintChan := make(chan int, 50)\n\texitChan := make(chan bool, 1)\n\n\tgo write(intChan)\n\n\tgo readData(intChan,exitChan)\n\n\tfor  &#123;\n\t\t_, ok := &lt;-exitChan\n\t\tif !ok &#123;\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n\n&#125;\n\n\n锁// 定义一个map\nvar (\n    myMap = make(map[int]int,10)\n    // 声明一个全局变量互斥锁\n    // lock 是一个全局互斥锁\n    // sync 是包：sychorinized\n    // Mutex : 互斥\n    lock sync.Mutex\n    )\n\n// 定义一个函数计算n！\nfunc factorial(num int) &#123;\n    res :=1\n    for i := 1; i &lt;= num; i++&#123;\n        res += i\n    &#125;\n    // 将计算出的结果存入map中\n    // 访问 myMap 前，加锁\n    lock.Lock()\n    myMap[num] = res\n    // 访问完，释放所\n    lock.Unlock()\n&#125;\n\n\n\n\n反射//判断类型是否相等\nreflect.TypeOf(a).Kind() == reflect.TypeOf(b).Kind()\n//判断类型和值是否相等\nreflect.DeepEqual(a, b interface&#123;&#125;)\n//直接获得类型名\nreflect.TypeOf(a).Name()\n\n\n\n判断运行时变量类型var t interface&#123;&#125;\nt = &amp;Test&#123;\n\ta: 1,\n&#125;\np := &amp;t\nswitch t.(type) &#123;\ncase int:\n\tfmt.Println(\"int\")\ncase string:\n\tfmt.Println(\"string\")\ncase *Test:\n\tfmt.Println(\"Test\")\ndefault:\n\tfmt.Println(\"other\")\n&#125;\n\nmysqlgorm进行mysql操作\n//按照数据库进行定义 struct字段可以是数据库的一部分 即智能选择字段\ntype WkTenantInit struct &#123;\n\tgorm.Model\n\tTenantID string `gorm:\"column:tenant_id\"`\n&#125;\n//query 不能声明为指针类型\nvar tenantIDs []WkTenantInit\nresult := db.Model(&amp;WkTenantInit&#123;&#125;).Find(&amp;tenantIDs)\n//insert\nresult := db.Create(&amp;WkTenantInit&#123;\n\tTenantID: id,\n&#125;)\n//select\n//智能选择字段\ndb.Select([]string&#123;\"name\", \"age\"&#125;).Find(&amp;users)\ndb.Model(&amp;WkTenantInit&#123;&#125;).Find(&amp;tenantIDs)\n//where or not condition\ndb.Where(\"name = ?\", \"jinzhu\").First(&amp;user)\ndb.Where(\"name in (?)\", []string&#123;\"jinzhu\", \"jinzhu 2\"&#125;).Find(&amp;users)\ndb.Not(\"name = ?\", \"jinzhu\").First(&amp;user)\ndb.Where(\"role = ?\", \"admin\").Or(\"role = ?\", \"super_admin\").Find(&amp;users)\n//update\nresult := db.Model(User&#123;&#125;).Where(\"role = ?\", \"admin\").Updates(User&#123;Name: \"hello\", Age: 18&#125;)\n//delete\ndb.Where(\"name = ?\", \"jinzhu\").Delete(&amp;email)\n\n\nMQ//handler\ntype handler struct &#123;\n&#125;\n//注册Batchhandler\nfunc (h *Handler) HandleMessages(msgs []*types.CtxMessageExt)\n//注册handler\nfunc (h *handler) HandleMessage(ctx context.Context, msg *pb.ConsumeMessage)\n\n//生成consumer\ncfg := config.NewDefaultConsumerConfig(cc.ConsumerGroup, cc.Topic, cc.ClusterName)\n\t//有序消费\n\tcfg.Orderly = true\n\t//设置协程数\n\tcfg.WorkerNum = cc.WorkerNum\n\t//tag过滤\n\tcfg.SubExpr = cc.SubExpr\n\t//从上次的offset开始消费 可能重复\n\tcfg.ConsumeFromWhere = config.ConsumeFromWhere_CONSUME_FROM_LATEST\n\t//batch size\n\tcfg.ConsumeMessageBatchMaxSize = cc.ConsumeMessageBatchMaxSize\n\t//batch wait time\n\tcfg.ConsumeMessageBatchMaxLingerTime = cc.ConsumeMessageBatchMaxLingerTime\n\n\tr, err := consumer.NewConsumer(cfg)\n\n\tif err != nil &#123;\n\t\tlogs.Fatalf(\"%v\", err)\n\t\tpanic(err)\n\t&#125;\n\n\thandler := &amp;Handler&#123;\n\t\tuhandler,\n\t&#125;\n\n\tr.RegisterBatchHandler(handler)\n\t//start consumer here\n\t//r.Start() blocks here\n\t//if you don't want to block, perhaps call `go r.Start()`\n\tlogs.Error(\"%v\", r.Start())\n\n\tsig := make(chan os.Signal)\n\tsignal.Notify(sig, syscall.SIGTERM, syscall.SIGINT)\n\t&lt;-sig\n\tlogs.Error(\"%v\", r.Close())\n\n\n\n\n\n常用函数marshal &amp; unmarshal类似序列化\njsonData := []byte(`&#123;\n\t\"name\":\"迪丽热巴\",\n\t\"birthday\":\"1992-06-03\",\n\t\"birthPlace\":\"新疆乌鲁木齐市\",\n\t\"opus\":[\n\t\t\"《阿娜尔罕》\",\n\t\t\"《逆光之恋》\",\n\t\t\"《克拉恋人》\"\n\t]\n\t\"opus\": &#123;\n     \"Date\":\"2013\",\n     \"Title\":\"《阿娜尔罕》\"\n    &#125;\n&#125;`)\n\nvar actress Actress\n//unmarshal 之后变成了struct 里面有map和slice\nerr := json.Unmarshal(jsonData, &amp;actress)\njsonData,err := json.Marshal(actress)\nfmt.Printf(%s\", actress.Opus.Date)\n \n            \n        \n\nsorttype Person struct &#123;\n\tage  int\n\tname string\n&#125;\n\nfunc main() &#123;\n\tvar persons []Person\n\tpersons = append(persons, Person&#123;age: 1, name: \"a\"&#125;)\n\tpersons = append(persons, Person&#123;age: 1, name: \"ab\"&#125;)\n\tsort.SliceStable(persons, func(i, j int) bool &#123;\n\t\tif persons[i].age != persons[j].age &#123;\n\t\t\treturn persons[i].age &lt; persons[j].age\n\t\t&#125; else &#123;\n\t\t\treturn persons[i].name &lt; persons[j].name\n\t\t&#125;\n\t&#125;)\n\tfor _, person := range persons &#123;\n\t\tfmt.Println(person.age, person.name)\n\t&#125;\n&#125;\n\n文件读取写入package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nfunc main() &#123;\n\tfileName := \"myfile.txt\"\n\tf, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, 0600)\n\tif err != nil &#123;\n\t\tf, err = os.Create(fileName)\n\t\tif err != nil &#123;\n\t\t\tfmt.Println(\"create failed\")\n\t\t&#125;\n\t&#125;\n\tdefer f.Close()\n\n\tif _, err = f.WriteString(\"new data that wasn't there originally\\n\"); err != nil &#123;\n\t\tpanic(err)\n\t&#125;\n\n\tdata, err := ioutil.ReadFile(fileName)\n\tif err != nil &#123;\n\t\tfmt.Println(err)\n\t&#125;\n\n\tfmt.Print(string(data))\n\n&#125;\n\n\n\n\n\n大坑//注意到底是声明指针还是结构体变量\nfunc UnmarshalJobDataMapJsonBiz(jobDataMapJson map[string][]string) (map[string][]*biz_model.JobData, error) &#123;\n\tjobDataMap := make(map[string][]*biz_model.JobData)\n\tfor jobDataID, jobDataListJson := range jobDataMapJson &#123;\n\t\tvar jobDataList []*biz_model.JobData\n\t\tfor _, jobDataJson := range jobDataListJson &#123;\n\t\t\tvar jobData biz_model.JobData\n\t\t\terr := json.Unmarshal([]byte(jobDataJson), &amp;jobData)\n\t\t\tif err != nil &#123;\n\t\t\t\treturn nil, err\n\t\t\t&#125;\n\t\t\tjobDataList = append(jobDataList, &amp;jobData)\n\t\t&#125;\n\t\tjobDataMap[jobDataID] = jobDataList\n\t&#125;\n\treturn jobDataMap, nil\n&#125;\n//注意返回的值不能直接取&amp;\n&amp;func()\n\n","slug":"GoLearning","date":"2022-09-05T03:18:12.000Z","categories_index":"learning","tags_index":"Go","author_index":"Sihan Chen"},{"id":"043ea5846f4ce7e1aaad5107c0f5a6a3","title":"CppLearning","content":"C++learning1.基本语法1.命名空间在C&#x2F;C++中，变量、函数和类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染。\n定义：namespace name1 &#123;\n  int a &#x3D; 5;\n  int add(int b, int c)&#123;\n    return b + c;\n  &#125;\n  namespace name2 &#123;\n    int a &#x3D; 3;\n    int sub(int b,int c) &#123;\n      return b - c;\n    &#125;\n  &#125;\n    &#x2F;&#x2F;函数\n&#125;\n\n可嵌套定义，如果有多个同名的命名空间会自动合并\n使用：using namespace name1;\n&#x2F;&#x2F;命名空间全部导入\nusing name1::a;\n&#x2F;&#x2F;此种声明下命名空间name1下的变量a就能直接使用\nusing name1::name2::b;\nint main() &#123;\n  printf(&quot;%d\\n&quot;,a);\n  return 0;\n&#125;\n\n当导入的命名空间中有重复的变量或者函数时会报错\nusing namespace std;\n&#x2F;&#x2F;之后写cout cin都可以直接写而不用 std::cin std::cout\n&#x2F;&#x2F;不提前导入的话之后每次使用都得带上命名空间名字和双冒号\n&#x2F;&#x2F;告诉编辑器使用命名空间\n\n范围解析运算符:::\n2.关键词volatile：提醒编译器该变量所在内存可能会因为其他因素改变，每次使用需要从内存中重新取值\nexplicit： 禁止隐式转换\nmutable：对象中的const函数不能改变对象成员，但是对于mutable声明的成员变量可以在const函数里面改变\n2.基本数据类型\n\n\n类型\n关键字\n\n\n\n布尔型\nbool\n\n\n字符型\nchar\n\n\n整型\nint\n\n\n浮点型\nfloat\n\n\n双浮点型\ndouble\n\n\n无类型\nvoid\n\n\n宽字符型\nwchar_t\n\n\ntypedef short int wchar_t;\n&#x2F;&#x2F;2B\n\n修饰类型：\n\nsigned\nunsigned\nlong\n\nlong int &#x3D;&#x3D; 4B short int &#x3D;&#x3D; 2B double &#x3D; 8B long double &#x3D; 16B\n\nshort\n\nConst:不可更改\nVolatile:不要优化 每次使用时从内存上拿取最新的值\nrestrict:？？？？？\n3.typedef用法：\ntypedef type newname\n&#x2F;&#x2F;将已有的type名定义为新的name\n\n4.枚举enum 枚举名&#123; \n     标识符[&#x3D;整型常数], \n     标识符[&#x3D;整型常数], \n... \n    标识符[&#x3D;整型常数]\n&#125; 枚举变量;\n\n如果枚举变量在定义的时候没有赋值，默认从0开始\n使用\ncolor c1,c2;\nc1 &#x3D; blue;\n\n5.声明和初始化只有声明了编译过程才能进行\n初始化与否不影响编译\n（函数和变量）\n当局部变量和全局变量名字相同时，优先使用局部变量（具有更高的优先级）\n全局变量会自动初始化\n变量：\n\n静态变量：\n\n静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。\n静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。\nclass foo &#123;\n    static void foo() &#123;\n        &#x2F;&#x2F;body\n    &#125;\n&#125;;\nint main() &#123;\n    foo::foo();\n&#125;\n\n\n\n\n实例变量\n全局变量\n局部变量\n\n6.define const#define a 1\ncont int b &#x3D; 1;\n\n7.存储类\nregister：意味着变量可能存储在寄存器中，多用于计数器，可大大加速\n\nstatic：存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁\n1.在函数中对修饰局部变量可以在函数调用之间保持局部变量的值\n2.修饰类的静态属性\n3.修饰全局变量，作用域限制在声明他的文件里\n\nextern：使一个文件中定义的变量或者函数可以在另一个文件中使用\n\nmutable：\n\nThread_local:\n\n\n8.运算符\n算数运算符\n关系运算符\n逻辑运算符\n位运算符\n赋值运算符（含有等号的运算符）\n杂项运算符\n\n9.函数1.函数传参\n传值调用\n指针调用\n引用调用\n\n2.参数默认值类似python\n3.lambda函数与表达式[capture](parameters)-&gt;return-type&#123;body&#125;\n\n10.库函数1.随机数srand(2);\n&#x2F;&#x2F;随机数种子\nint a &#x3D; rand();\n\n2.timesrand(time(NULL));\n&#x2F;&#x2F;随机数种子\n\n3.setwsetw(n)函数只对紧接着的输出产生作用 n表示宽度\n4.setfillsetfill(char c)\n&#x2F;&#x2F;用字符来填充空白\n\n5.字符串函数strcpy(s1,s2)\n&#x2F;&#x2F;s2复制到s1中 不管原来s1是什么内容直接覆盖\nstrlen(s1)\n&#x2F;&#x2F;返回s1长度 这里的长度不包括&#39;\\0&#39;\nstrcmp(s1,s2)\n&#x2F;&#x2F;若s1 &gt; s2则返回正数 相等则返回0 反之则返回负数 对于string类型的字符串不能使用\nstrchr(s1,ch);\n&#x2F;&#x2F;返回指针指向s1中ch第一次出现的位置 从左开始\nstrcat(s1,s2)\n&#x2F;&#x2F;将s2接在s1后面 注意只能对char name[]的字符数组使用 对于string类型的字符串（C++新增）可以直接使用 &#39;+&#39;连接\nstrstr(s1,s2)\n&#x2F;&#x2F;返回一个指针表示s2在s1中的匹配 如果没有匹配则返回\n\nchar s1[] &#x3D; &quot;abc&quot;;\ncout &lt;&lt; s1 &lt;&lt; endl;\n&#x2F;&#x2F;打印字符串指针 就是从该位置开始打印字符串\ns1 &#x3D; s2;\n&#x2F;&#x2F;不管是string还是char s[]都可以直接改变指针引用 \n\n\n\n11.指针数组是常量指针\n12.引用类型引用很容易与指针混淆，它们之间有三个主要的不同：\n\n不存在空引用。引用必须连接到一块合法的内存。\n一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n引用必须在创建时被初始化。指针可以在任何时间被初始化。\n\n试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签\nint a &#x3D; 5;\nint &amp;b &#x3D; a;\ncout &lt;&lt; a &lt;&lt;endl;\n&#x2F;&#x2F;5\ncout &lt;&lt; b &lt;&lt; endl;\n&#x2F;&#x2F;5\na &#x3D;&#x3D; b;\n\n13.字符流C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。\n\n\n\n头文件\n函数和描述\n\n\n\n\n该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。\n\n\n\n该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I&#x2F;O 有用的服务。\n\n\n\n该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。\n\n\n流提取运算符 &gt;&gt; 在一个语句中可以多次使用\nstring name;\ncin &gt;&gt; name;&#x2F;&#x2F;标准输入流\ncout &lt;&lt; name &lt;&lt; endl;&#x2F;&#x2F;标准输出流\ncerr &lt;&lt; &quot;wrong&quot;;&#x2F;&#x2F;标准错误流\nclog &lt;&lt; &quot;done&quot;;&#x2F;&#x2F;标准日志流\n\n预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。\n clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。\n14.结构struct type_name &#123;\n    member_type1 member_name1;\n    member_type2 member_name2;\n    member_type3 member_name3;\n&#125;;\n&#x2F;*or\ntypedef struct type_name &#123;\n    member_type1 member_name1;\n    member_type2 member_name2;\n    member_type3 member_name3;\n&#125;object_names;*&#x2F;\ntype_name name1,name2;\ncout &lt;&lt; name1.member_name1 &lt;&lt; endl;\ntype_name *ptrname;\nptrname &#x3D; &amp;name2;\ncout &lt;&lt; name2-&gt;member_name1 &lt;&lt; endl;\n\ntypedef long int *pint32;\n \npint32 x, y, z;\n\n15.类与对象class name &#123;\n  modifier:\n    type name1;\n    type name2;\n  modifier:\n    returntype func(type para);\n  &#x2F;&#x2F; func signature\n  modifier:\n  \treturntype func(type para) &#123;\n      &#x2F;&#x2F;body also ok!\n    &#125;\n&#125;;\ntype name::func(type para) &#123;\n  &#x2F;&#x2F;func body\n&#125;\n\n注意与java的区别与联系\n\n相同的修饰符可以只写一次\n方法在class域里只写头也行 带上方法体也行\n当参数名和属性成员名相同时，成员名加上this以达到区分\n没有任何修饰符时默认private\n\n成员函数可以定义在类定义内部，或者单独使用范围解析运算符 :: 来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。\n注意C++里面类的实例化有两种方法：\nclass foo &#123;\n    &#x2F;&#x2F;class\n&#125;;\nint main() &#123;\n    foo foo1;&#x2F;&#x2F;类似结构体\n    &#x2F;&#x2F;这种实例化方法把对象建立在栈上 自动调用构造函数和析构函数\n    foo *foo1 &#x3D; new foo;&#x2F;&#x2F;类似结构体指针\n    &#x2F;&#x2F;这种实例化方式是类指针 建立在堆上 不会自动回收 要手动delete 否则发生内存泄漏\n&#125;\n\n注意this指针和类指针的区别\n构造函数：默认public\n使用初始化列表来初始化字段：\nC::C( double a, double b, double c): X(a), Y(b), Z(c)\n&#123;  .... &#125;;\n\n\n\n析构函数：析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。\nclass foo &#123;\n    public:\n\t\tfoo() &#123;\n            &#x2F;&#x2F;body\n        &#125;\n    \t~foo() &#123;\n            &#x2F;&#x2F;body\n        &#125;\n&#125;;\n\n拷贝构造函数：拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：\n\n通过使用另一个同类型的对象来初始化新创建的对象。\n复制对象把它作为参数传递给函数。\n复制对象，并从函数返回这个对象。\n\n16.友元函数\nC++中引入友元函数，是为在该类中提供一个对外（除了他自己意外）访问的窗口;\n这个友元函数他不属于该类的成员函数，他是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员。\n将数据和处理数据的函数封装在一起，构成类，实现了数据的隐藏，无疑是面向对象程序设计的一大优点。但是有时候封装不是绝对的。\n友元函数提供了不同类或对象的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通俗的说，友元关系就是一个类主动声明哪些类或函数是它的朋友，进而给它们提供对本类的访问特性。也就是说，通过友元关系，一个普通函数或者类的成员函数可以访问封装于另外一个类中的数据。\n从一定程度上讲，友元是对数据隐藏和封装的破坏，但是为了数据共享，提高程序的效率和可读性，很多情况下这种小的破坏是必要的。\n在一个类中，利用关键字friend将其它函数或类声明为友元。如果友元是一般函数或类的成员函数，称为友元函数。如果友元是一个类，则称为友元类。友元类的所有成员函数都自动称为友元函数。\n成员函数有this指针，而友元函数没有this指针。\n友元函数是不能被继承的，就像父亲的朋友未必是儿子的朋友。\n\n1.类中通过使用关键字friend 来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。\n2.一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。\n3.友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。\n4.友元函数在调用上同一般函数一样，不必通过对对象进行引用。\n17.内联函数C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。\n对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。\n如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。\n在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。\n18.继承三种继承：\n\n1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private\n2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private\n3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private\n\n我们几乎不使用 protected 或 private 继承，通常使用 public 继承\n\n\n\n访问\npublic\nprotected\nprivate\n\n\n\n同一个类\nyes\nyes\nyes\n\n\n派生类\nyes\nyes\nno\n\n\n外部的类\nyes\nno\nno\n\n\nC++支持多继承，具体使用方法是：\nclass foo1:access-specifier classname....&lt;list&gt;\n\n19.重载函数重载C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。\n重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。\n当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。\n函数的签名是由函数的参数和函数的名字决定的与返回值无关\n运算符重载class Box &#123;\n    public:\n    \tBox operator+(const Box&amp;b) &#123;\n             Box box;\n             box.length &#x3D; this-&gt;length + b.length;\n             box.breadth &#x3D; this-&gt;breadth + b.breadth;\n             box.height &#x3D; this-&gt;height + b.height;\n             return box;\n        &#125;\n&#125;\n\n\n\n可重载运算符\n\n\n双目算术运算符\n+ (加)，-(减)，*(乘)，&#x2F;(除)，% (取模)\n\n\n\n关系运算符\n&#x3D;&#x3D;(等于)，!&#x3D; (不等于)，&lt; (小于)，&gt; (大于)，&lt;&#x3D;(小于等于)，&gt;&#x3D;(大于等于)\n\n\n逻辑运算符\n||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)\n\n\n单目运算符\n+ (正)，-(负)，*(指针)，&amp;(取地址)\n\n\n自增自减运算符\n++(自增)，–(自减)\n\n\n位运算符\n| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)\n\n\n赋值运算符\n&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; , % &#x3D; , &amp;&#x3D;, |&#x3D;, ^&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D;\n\n\n空间申请与释放\nnew, delete, new[ ] , delete[]\n\n\n其他运算符\n()(函数调用)，**-&gt;(成员访问)，,(逗号)，[]**(下标)\n\n\n不可重载运算符\n**.**：成员访问运算符\n.*, **-&gt;***：成员指针访问运算符\n**::**：域运算符\nsizeof：长度运算符\n**?:**：条件运算符\n**#**： 预处理符号\n\n虚函数：导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。\n虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。\n纯虚函数要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。\n如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的.\n设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。\n因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。\n可用于实例化对象的类被称为具体类。\nvirtual int area() &#x3D; 0;\n\n20.文件和流\n\n\n模式标志\n描述\n\n\n\nios::app\n追加模式。所有写入都追加到文件末尾。\n\n\nios::ate\n文件打开后定位到文件末尾。\n\n\nios::in\n打开文件用于读取。\n\n\nios::out\n打开文件用于写入。\n\n\nios::trunc\n如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。\n\n\n打开文件void open(const char *filename, ios::openmode mode);\n\n关闭文件void close();\n\n写入文件在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。\n读取文件在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。\nhint：\nint main() &#123;\n    ofstream file;\n    file.open(&quot;file.txt&quot;,ios::app);\n    file &lt;&lt; &quot;fuck&quot;;\n    fstream infile;\n    infile.open(&quot;file.txt&quot;,ios::in);\n    string s &#x3D; &quot;&quot;;\n    infile &gt;&gt; s;\n    cout &lt;&lt; s;\n    file.close();\n&#125;\n&#x2F;&#x2F;需要重新以读模式打开文件\n\n文件位置指针istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。\nseekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。\n文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。\nint main() &#123;\n    fstream outFile;\n    outFile.open(&quot;file.txt&quot;,ios::trunc);\n    outFile.seekp(4);\n    cout &lt;&lt; outFile.tellp() &lt;&lt; endl;\n    outFile &lt;&lt; &quot;foofoofoo&quot;;\n    outFile.close();\n    ifstream inFile;\n    inFile.open(&quot;file.txt&quot;,ios::in);\n    string s;\n    inFile.seekg(-1,ios::end);\n    cout &lt;&lt; inFile.tellg() &lt;&lt; endl;\n    inFile &gt;&gt; s;\n    cout &lt;&lt; s &lt;&lt; endl;\n    inFile.close();\n    return 0;\n&#125;\n&#x2F;&#x2F;C++读写指针是分开的\n&#x2F;&#x2F;输出：\n-1\n12\no\n  foofoofoo\n  &#x2F;&#x2F;tellp tellg\n  &#x2F;&#x2F;seekp seekg\n  &#x2F;&#x2F;ios::beg ios::cur ios::end\n\n21.异常处理\n\n\n异常\n描述\n\n\n\nstd::exception\n该异常是所有标准 C++ 异常的父类。\n\n\nstd::bad_alloc\n该异常可以通过 new 抛出。\n\n\nstd::bad_cast\n该异常可以通过 dynamic_cast 抛出。\n\n\nstd::bad_exception\n这在处理 C++ 程序中无法预期的异常时非常有用。\n\n\nstd::bad_typeid\n该异常可以通过 typeid 抛出。\n\n\nstd::logic_error\n理论上可以通过读取代码来检测到的异常。\n\n\nstd::domain_error\n当使用了一个无效的数学域时，会抛出该异常。\n\n\nstd::invalid_argument\n当使用了无效的参数时，会抛出该异常。\n\n\nstd::length_error\n当创建了太长的 std::string 时，会抛出该异常。\n\n\nstd::out_of_range\n该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator。\n\n\nstd::runtime_error\n理论上不可以通过读取代码来检测到的异常。\n\n\nstd::overflow_error\n当发生数学上溢时，会抛出该异常。\n\n\nstd::range_error\n当尝试存储超出范围的值时，会抛出该异常。\n\n\nstd::underflow_error\n当发生数学下溢时，会抛出该异常。\n\n\n在这里，what() 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因\n例子：\nstruct MyException : public exception\n&#123;\n  const char * what () const throw ()\n  &#123;\n    return &quot;C++ Exception&quot;;\n  &#125;\n&#125;;\n \nint main()\n&#123;\n  try\n  &#123;\n    throw MyException();\n  &#125;\n  catch(MyException&amp; e)\n  &#123;\n    std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n  &#125;\n  catch(std::exception&amp; e)\n  &#123;\n    &#x2F;&#x2F;其他的错误\n  &#125;\n\n22.动态内存\n栈：在函数内部声明的所有变量都将占用栈内存。\n堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。\n\nnewnew data-type;\n\ndouble *ptr;\nptr &#x3D; new double;\n*ptr &#x3D; 1.2;\ncout &lt;&lt; *ptr;\n\ndeletedelete ptr;\n\n数组申请和释放的例子：\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main()\n&#123;   \n    int i,j,k;   &#x2F;&#x2F; p[2][3][4]\n    \n    int ***p;\n    p &#x3D; new int **[2]; \n    for(i&#x3D;0; i&lt;2; i++) \n    &#123; \n        p[i]&#x3D;new int *[3]; \n        for(j&#x3D;0; j&lt;3; j++) \n            p[i][j]&#x3D;new int[4]; \n    &#125;\n    \n    &#x2F;&#x2F;输出 p[i][j][k] 三维数据\n    for(i&#x3D;0; i&lt;2; i++)   \n    &#123;\n        for(j&#x3D;0; j&lt;3; j++)   \n        &#123; \n            for(k&#x3D;0;k&lt;4;k++)\n            &#123; \n                p[i][j][k]&#x3D;i+j+k;\n                cout&lt;&lt;p[i][j][k]&lt;&lt;&quot; &quot;;\n            &#125;\n            cout&lt;&lt;endl;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n    \n    &#x2F;&#x2F; 释放内存\n    for(i&#x3D;0; i&lt;2; i++) \n    &#123;\n        for(j&#x3D;0; j&lt;3; j++) \n        &#123;   \n            delete [] p[i][j];   \n        &#125;   \n    &#125;       \n    for(i&#x3D;0; i&lt;2; i++)   \n    &#123;       \n        delete [] p[i];   \n    &#125;   \n    delete [] p;  \n    return 0;\n&#125;\n\n23.模版函数模版template &lt;typename T&gt;\nT funcname (T a, T b) &#123;\n  &#x2F;&#x2F;body\n&#125;\n\n类模版template &lt;class T&gt;\nclass Stack &#123; \n  private: \n    vector&lt;T&gt; elems;     &#x2F;&#x2F; 元素 \n \n  public: \n    void push(T const&amp;);  &#x2F;&#x2F; 入栈\n    void pop();               &#x2F;&#x2F; 出栈\n    T top() const;            &#x2F;&#x2F; 返回栈顶元素\n    bool empty() const&#123;       &#x2F;&#x2F; 如果为空则返回真。\n        return elems.empty(); \n    &#125; \n&#125;; \n\n24.预处理器预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。\n所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。\ndefine\n宏常量\n\n宏函数\n\n\n条件编译#ifdef\n&#x2F;&#x2F;body\n#endif\n#if\n&#x2F;&#x2F;body\n#endif\n\n#和##运算符#define MKSTR( x ) #x\n&#x2F;&#x2F;用于转化为字符串\n#define concat(a, b) a ## b\n&#x2F;&#x2F;连接ab变量名成为新的变量名\n\n\n\n25.信号处理信号定义在csignal库中\n信号是由操作系统传给进程的中断，会提早终止一个程序。\n有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。\n信号\n\n\n信号\n描述\n\n\n\nSIGABRT\n程序的异常终止，如调用 abort。\n\n\nSIGFPE\n错误的算术运算，比如除以零或导致溢出的操作。\n\n\nSIGILL\n检测非法指令。\n\n\nSIGINT\n程序终止(interrupt)信号。\n\n\nSIGSEGV\n非法访问内存。\n\n\nSIGTERM\n发送到程序的终止请求。\n\n\nsignal将信号和相应需要执行的操作绑定，当出现对应信号时执行相应的操作\n#include &lt;csignal&gt;\nsignal(registered signal, signal handler)\n&#x2F;&#x2F;signal handler是自己写的函数\nint raise (signal sig);\n\nvoid signalHandler( int signum )\n&#123;\n    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\\n&quot;;\n \n    &#x2F;&#x2F; 清理并关闭\n    &#x2F;&#x2F; 终止程序  \n \n   exit(signum);  \n&#125;\nint main ()\n&#123;\n    &#x2F;&#x2F; 注册信号 SIGINT 和信号处理程序\n    signal(SIGINT, signalHandler);  \n \n    while(1)&#123;\n       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;\n       sleep(1);\n    &#125;\n \n    return 0;\n&#125;\n\nraise抛出对应的信号\n26.多线程27.web编程28.STL\n\n\n组件\n描述\n\n\n\n容器（Containers）\n容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。\n\n\n算法（Algorithms）\n算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。\n\n\n迭代器（iterators）\n迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。\n\n\niteratorint main() &#123;\n  vector&lt;int&gt; vec;\n  vec.push_back();\n  &#x2F;&#x2F;类似于python append 从尾部加入\n  vector&lt;int&gt;::iterator iterator &#x3D; vec.begin();\n  &#x2F;&#x2F;返回指向开头的迭代器\n  while (iterator !&#x3D; vec.end()) &#123;\n    &#x2F;&#x2F;当指针还没到队尾\n    cout &lt;&lt; *iterator++ &lt;&lt; endl;\n  &#125;\n  &#x2F;&#x2F;迭代器指针访问 \n&#125;\n\n\ninclude &lt;XXSTLXX&gt;\n\n\n\nvector数组实现\n\nvector&lt;int&gt;a = &#123;1, 2, 3, 4, 5&#125;;\n\n\nat(int index) : 返回指定位置的元素\nempty() : 判断 Vector 是否为空（返回 true 时为空）\nclear() : 清空所有元素\n\n\nfront() : 返回第一个元素\nback() : 返回最末一个元素\npop_back() : 移除最后一个元素\npush_back() : 在 Vector 最后添加一个元素\nerase(iterator it) : 删除指定元素\ninsert(iterator it, type ele) : 插入元素到 Vector 中\nbegin() : 返回第一个元素的迭代器\nend() : 返回最末元素后一个位置的迭代器 (注意: 实际指向最末元素的下一个位置)\nrbegin() : 返回 Vector 尾部的逆迭代器\nrend() : 返回 Vector 起始的逆迭代器\nsize() : 返回 Vector 元素数量的大小\n[]: 获取指定元素\n\nlist链表实现 实际上就是双端队列\n\nlist&lt;int&gt;a = &#123;1, 2, 3, 4, 5&#125;;\n\n\nbegin() : 返回指向第一个元素的迭代器\nend() : 返回末尾下一个元素的迭代器\nrbegin() : 返回指向第一个元素的逆向迭代器\nrend() : 指向 list 末尾的逆向迭代器\n\n\nfront() : 返回第一个元素\n\nback() : 返回最后一个元素\n\nclear() : 删除所有元素\n\nempty() : 如果 list 是空的则返回 true\n\nremove(int num) : 从 list 删除元素\n\nerase(iterator it) : 删除指定元素\n\ninsert(iterator it, type ele) : 插入一个元素到 list 中\n\npop_back() : 删除最后一个元素\n\npop_front() : 删除第一个元素\n\npush_back() : 在 list 的末尾添加一个元素\n\npush_front() : 在 list 的头部添加一个元素\n\nsize() : 返回 list 中的元素个数\n\n\nstring\nchar&amp; operator[](int n);&#x2F;&#x2F; 通过[]方式取字符\n\nchar&amp; at(int n);&#x2F;&#x2F; 通过 at 方法获取字符\n\nstring&amp; operator+=(const string&amp; str);&#x2F;&#x2F; 重载 +&#x3D; 运算符\n\nint compare(const string &amp;s)const;&#x2F;&#x2F; 与字符串 s 比较 \n\n&gt; 时返回 1，&lt; 时返回 - 1，相等时返回 0，\n\n\nstring&amp; replace(int pos,int n,const string&amp; str);&#x2F;&#x2F; 替换从 pos 开始的 n 个字符为字符串 str\n\nint find(const string&amp; str,int pos = 0)const;&#x2F;&#x2F; 查找 str 第一次出现的位置，从 pos 开始查找\n\nint rfind(const string&amp; str, int pos = npos)const;&#x2F;&#x2F; 查找 str 最后一次出现位置，从 pos 开始查找 (即从右向左找)\n\nstring substr(int pos = 0,int n = npos)const;&#x2F;&#x2F; 返回由 pos 开始的 n 个字符组成的字符串\n\nstring&amp; insert(int pos,const string &amp;str);&#x2F;&#x2F; 插入字符串\n\nstring&amp; erase(int pos,int n = npos);&#x2F;&#x2F; 删除从 pos 开始的 n 个字符\n\nint isalnum(char c);判断是否是字母+数字\n\nint isalpha(char c);判断是否是字母\n\nint isupper(char c);判断是否是大写\n\nint islower(char c);判断是否是小写\n\nint tolower(char c);转化成小写 对于非字母则不发生变化\n\nint toupper(char c);转化成大写 对于非字母则不发生变化\n\n\nstack\nstack&lt;T&gt; stkT; : 采用模板类实现，stack 对象的默认构造形式\nstack(const stack &amp;stk); : 拷贝构造函数\nsize(): 返回栈中的元素数\ntop(): 返回栈顶的元素\npop(): 从栈中取出并删除元素\npush(type ele): 向栈中添加元素 x\nempty(): 在栈为空时返回 true\n\nqueue\nback() : 返回最后一个元素\nempty() : 如果队列空则返回真\nfront() : 返回第一个元素\npop() : 删除第一个元素\npush(type ele) : 在末尾加入一个元素\nsize() : 返回队列中元素的个数\n\ndequeue和list底层结构一样 都是链表实现 可以双端操作 \n\nback();&#x2F;&#x2F; 返回最后一个元素\nfront();&#x2F;&#x2F; 返回第一个元素\ninsert(iterator it, type ele);&#x2F;&#x2F;插入元素\npop_back();&#x2F;&#x2F; 删除尾部的元素\npop_front();&#x2F;&#x2F; 删除头部的元素\npush_back();&#x2F;&#x2F; 在尾部加入一个元素\npush_front();&#x2F;&#x2F; 在头部加入一个元素\nat();&#x2F;&#x2F; 访问指定位置元素 注意list没有这个api \n[]&#x2F;&#x2F; 访问指定位置元素 注意list没有这个api \nempty();&#x2F;&#x2F; 判断队列是否为空\nsize();&#x2F;&#x2F; 返回队列的大小\n\npriority_queue\n     priority_queue&lt;Type, Container, Functional&gt; 构造函数\n\n\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; 小顶堆\n\ntop 访问队头元素\n\nempty 队列是否为空\n\nsize 返回队列内元素个数\n\npush 插入元素到队尾 (并排序)\n\npop 弹出队头元素\n\n\nset\nstd::set&lt;int&gt;a&#123;1, 2, 3, 4, 5&#125;;:构造函数\nclear() : 清除所有元素\nempty() : 如果集合为空，返回 true\ninsert(type num) : 在集合中插入元素\nerase() : 删除集合中的元素\ncount(type ele) : 返回某个值元素的个数 实际上只可能是0或者1 与java contains一样\nbegin() : 返回指向第一个元素的迭代器\nend() : 返回指向最后一个元素的迭代器\nsize() : 集合中元素的数目\n\nmap\nclear() : 删除所有元素\n\ncount(type ele) : 返回指定元素出现的次数, 只会出现0或者1\n\nempty() : 如果 map 为空则返回 true\n\nbegin() : 返回指向 map 头部的迭代器\n\nend() : 返回指向 map 末尾下一个元素的迭代器\n\nerase(key ele) : 删除一个元素\n\nsize() : 返回 map 中元素的个数\n\n[key]&#x2F;&#x2F; 访问key对应的value\n\n\npair\n    pair&lt;int, int&gt; p = pair&lt;int, int&gt;(5,5);&#x2F;&#x2F; 初始化pair\n\n    p.first&#x2F;&#x2F; 访问第一个位置的元素\n\n    p.second&#x2F;&#x2F;访问第二个位置的元素\n\n\n","slug":"CppLearning","date":"2021-06-21T02:55:58.000Z","categories_index":"learning","tags_index":"C++","author_index":"Sihan Chen"},{"id":"9b79bd1397114c7816318b0d6a9c055c","title":"JavaLearning","content":"Java learningdetail匿名类：没有class关键词 只能实例化一个对象\n内部类\n类变量\n实例变量\n局部变量:循环体中的变量作用域仅限于该循环体\n可变参数:\n类中没有初始化的成员变量自动初始化为0，引用为null\ndouble... numbers\n\n字符可以相减\n&#39;b&#39; - &#39;a&#39; &#x3D;&#x3D; 1\n\njava未初始化数组元素有默认值！\n字符和字符串竟然可以想加！\n&quot;123&quot; + &#39;1&#39;\n\n异或^\n算数&gt;&gt;\n逻辑&gt;&gt;&gt;\n\n\n\nIOpublic class ScannerDemo &#123;\n    public static void main(String[] args) &#123;\n        Scanner scan &#x3D; new Scanner(System.in);\n        &#x2F;&#x2F; 判断是否还有输入\n        if (scan.hasNext()) &#123;\n            String str1 &#x3D; scan.next();\n            String str2 &#x3D; scan.nextLine();\n            System.out.println(&quot;输入的数据为：&quot; + str1);\n        &#125;\n        scan.close();\n    &#125;\n&#125;\n&#x2F;&#x2F;next去掉空白符 nextline读取一整行 没有回车\n\n\n数据类型引用\n内置 byte short int long char float double boolean\n装箱&#x2F;拆箱将基本类型封&#x2F;拆成对象\n\n字符串StringBuffer线程安全 速度慢\nStringBuilder速度更快 线程不安全\nString[] array &#x3D; sentence.split(&quot; &quot;);\n        StringBuilder ans &#x3D; new StringBuilder();\n        for (String s:array) &#123;\n            String cur &#x3D; rootNode.getRoot(s);\n            if (cur !&#x3D; null) &#123;\n                ans.append(cur);\n            &#125; else &#123;\n                ans.append(s);\n                &#x2F;&#x2F;不替换\n            &#125;\n            &#x2F;&#x2F;注意空格\n            ans.append(&quot; &quot;);\n        &#125;\n        &#x2F;&#x2F;删去最后一个空格\n        ans.deleteCharAt(ans.length() - 1);\n        return ans.toString();\nString s &#x3D; &quot;123&quot;;\ns.indexOf(&quot;1&quot;);&#x2F;&#x2F;返回开始的下标 如果为0 说明是prefix\n\n控制流&#x2F;&#x2F;while\npublic class Test &#123;\n   public static void main(String[] args) &#123;\n      int x &#x3D; 10;\n      while( x &lt; 20 ) &#123;\n         System.out.print(&quot;value of x : &quot; + x );\n         x++;\n         System.out.print(&quot;\\n&quot;);\n      &#125;\n   &#125;\n&#125;\n&#x2F;&#x2F;do while\npublic class Test &#123;\n   public static void main(String[] args)&#123;\n      int x &#x3D; 10;\n \n      do&#123;\n         System.out.print(&quot;value of x : &quot; + x );\n         x++;\n         System.out.print(&quot;\\n&quot;);\n      &#125;while( x &lt; 20 );\n   &#125;\n&#125;\n&#x2F;&#x2F;for \npublic class Test &#123;\n   public static void main(String[] args) &#123;\n \n      for(int x &#x3D; 10; x &lt; 20; x &#x3D; x+1) &#123;\n         System.out.print(&quot;value of x : &quot; + x );\n         System.out.print(&quot;\\n&quot;);\n      &#125;\n   &#125;\n&#125;\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        int[] foo &#x3D; &#123;1,2,3&#125;;\n        for (int f : foo) &#123;\n            System.out.println(f);\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;switch 没有break一直往下执行 注意一定要有break\npublic class Test &#123;\n   public static void main(String args[])&#123;\n      &#x2F;&#x2F;char grade &#x3D; args[0].charAt(0);\n      char grade &#x3D; &#39;C&#39;;\n      switch(grade)\n      &#123;\n         case &#39;A&#39; :\n            System.out.println(&quot;优秀&quot;); \n            break;\n         case &#39;B&#39; :\n         case &#39;C&#39; :\n            System.out.println(&quot;良好&quot;);\n            break;\n         default :\n            System.out.println(&quot;未知等级&quot;);\n      &#125;\n      System.out.println(&quot;你的等级是 &quot; + grade);\n   &#125;\n&#125;\n\n\n数组int[] name &#x3D; &#123;&#125;;\nint[] name &#x3D; new int[5];\n\n\n\n\n\n容器List Map Array遍历可用foreach\nint[] nums &#x3D; &#123;1,2&#125;;\nArrays.stream(nums).forEach(System.out::println);\n&#x2F;&#x2F;IntStream\n&#x2F;&#x2F;函数式编程 函数接口\n\n统一遍历\nfor (int num:nums) &#123;\n    \n&#125;\nfor (Entry&lt;String,String&gt; entry : hashMap.entrySet()) &#123;\n    \n&#125;\n\n\ncomparator是一个interface 这里不是new接口 而是new一个实现了该接口的匿名类 {} 里是对该interface的实现\nprivate PriorityQueue&lt;int[]&gt; heap &#x3D; new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;() &#123;\n        public int compare(int[] m, int[] n) &#123;\n            return m[1] - n[1];\n        &#125;\n    &#x2F;&#x2F;\n    &#125;);\n\n\n\n\n1.Queue&#x2F;PriorityQueuejava默认小顶堆\n        Queue&lt;String&gt; foo &#x3D; new LinkedList&lt;&gt;();\n        foo.offer(&quot;123&quot;);\n\t\tfoo.poll();\n\t\tfoo.peek();\n\t\t&#x2F;&#x2F;无异常\n\t\tfoo.add(&quot;123&quot;);\n\t\tfoo.remove();\n\t\tfoo.element();\n\t\t&#x2F;&#x2F;可能有异常\n        foo.offer(&quot;4444&quot;);\n        System.out.println(foo.poll());\n        System.out.println(foo.poll());\n        System.out.println(foo.remove());\n&#x2F;&#x2F;      foo.add(“123”);如果容量满了则会报异常\n&#x2F;&#x2F;尽量用offer poll\n\n2.ArrayList&#x2F;LinkedListArrayList&lt;type&gt; l &#x3D; new ArrayList();\nl.add();\nl.addAll();\nl.contains();\nl.containsAll();\nl.get();\nl.indexOf();\nl.clone();\nl.size();\nl.remove();\nl.removeAll();\nl.removeIf(e -&gt; e &#x3D;&#x3D; 8);\n\nif (!emaillist.isEmpty()) &#123;\n            Collections.sort(emaillist, new Comparator&lt;Email&gt;() &#123;\n                @Override\n                public int compare(Email o1, Email o2) &#123;\n                    return o1.getUsername().toLowerCase().compareTo(o2.getUsername().toLowerCase());\n                &#125;\n            &#125;);\n        &#125;\nCollections.sort(sites);  &#x2F;&#x2F; 字母排序\nArrayList&lt;Integer&gt; num &#x3D; (ArrayList&lt;Integer&gt;) myNumbers.clone();&#x2F;&#x2F;clone\nArrayList&lt;Integer&gt; n &#x3D; new ArrayList&lt;&gt;(num);&#x2F;&#x2F;clone\n\n\n\n3.HashMap&#x2F;HashSet&#x2F;LinkedHashmap&#x2F;TreeMap无序 非线程安全\nHashMap和LinkedHashMap使用接口完全一样TreeMap\nm.put(k,v);\nm.get(k);\nm.remove(k);\nm.clear();\nm.size();\nm.keySet();\nm.values();\nm.entrySet();\nm.containsKey();\nm.containsValue();\n\nHashSet&#x2F;TreeSet\ns.add();\ns.addAll();\ns.remove();\ns.size();\n\nTreeSet&#x2F;TreeMap\nTreeSet&lt;String&gt; s &#x3D; new TreeSet&lt;&gt;();\ns.floor();\ns.ceiling();\nTreeMap&lt;String,String&gt; m &#x3D; new TreeMap&lt;&gt;();\nm.floorEntry();\nm.ceilingEntry();\n\n\n\n4.HashSet&#x2F;TreeSets.add();\ns.addAll();\ns.remove();\ns.size();\n\n5.stackStack&lt;type&gt; s &#x3D; new Stack&lt;&gt;();\ns.push();\ns.pop();\n\n\n\n迭代器        Iterator&lt;String&gt; ite&#x3D;list.iterator();\n        while(ite.hasNext())&#x2F;&#x2F;判断下一个元素之后有值\n        &#123;\n            System.out.println(ite.next());\n        &#125;\n\nIterator&lt;Map.Entry&lt;String, String&gt;&gt; it &#x3D; map.entrySet().iterator();\n        while (it.hasNext()) &#123;\n            Map.Entry&lt;String, String&gt; entry &#x3D; it.next();\n            System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());\n        &#125;\nite.next();\nite.hasNext();\nite.remove();\n\n\n\n去重ArrayList collect &#x3D;(ArrayList)Stream.of(a,b).flatMap(Collection::stream).distinct().collect(Collectors.toList());\n\n排序   @Override\n   public int compareTo(Object o) &#123;\n       Error error &#x3D; (Error) o;\n       if (this.getLine() &lt; error.getLine()) &#123;\n           return -1;\n       &#125; else if (this.getLine() &#x3D;&#x3D; error.getLine()) &#123;\n           return 0;\n       &#125; else &#123;\n           return 1;\n       &#125;\n   &#125;&#x2F;&#x2F;重写方法\nCollections.sort(errorList);\nArrays.sort(a,new Comparator&lt;int[]&gt;() &#123;\n       &#x2F;&#x2F;Comparator里的类型为要排序的对象的类型\n           public int compare(int[] o1,int[] o2) &#123;\n               if (o1[0] - o2[0] !&#x3D; 0) &#123;\n                   return o1[0] - o2[0];\n               &#125; else &#123;\n                   return o1[1] - o2[1];\n               &#125;\n           &#125;\n       &#125;);\n\n泛型\n通配符 ？不能超过上层类型\n   public static &lt; E &gt; void printArray( E[] inputArray )\n   &#123;\n      &#x2F;&#x2F; 输出数组元素            \n         for ( E element : inputArray )&#123;        \n            System.out.printf( &quot;%s &quot;, element );\n         &#125;\n         System.out.println();\n    &#125;\n\n   public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z)\n   &#123;                     \n      T max &#x3D; x; &#x2F;&#x2F; 假设x是初始最大值\n      if ( y.compareTo( max ) &gt; 0 )&#123;\n         max &#x3D; y; &#x2F;&#x2F;y 更大\n      &#125;\n      if ( z.compareTo( max ) &gt; 0 )&#123;\n         max &#x3D; z; &#x2F;&#x2F; 现在 z 更大           \n      &#125;\n      return max; &#x2F;&#x2F; 返回最大对象\n   &#125;\n\npublic class Box&lt;T&gt; &#123;\n   \n  private T t;\n \n  public void add(T t) &#123;\n    this.t &#x3D; t;\n  &#125;\n \n  public T get() &#123;\n    return t;\n  &#125;\n \n  public static void main(String[] args) &#123;\n    Box&lt;Integer&gt; integerBox &#x3D; new Box&lt;Integer&gt;();\n    Box&lt;String&gt; stringBox &#x3D; new Box&lt;String&gt;();\n \n    integerBox.add(new Integer(10));\n    stringBox.add(new String(&quot;菜鸟教程&quot;));\n \n    System.out.printf(&quot;整型值为 :%d\\n\\n&quot;, integerBox.get());\n    System.out.printf(&quot;字符串为 :%s\\n&quot;, stringBox.get());\n  &#125;\n&#125;\n\n   public static void getData(List&lt;?&gt; data) &#123;\n      System.out.println(&quot;data :&quot; + data.get(0));\n   &#125;\n\n\n\n序列化Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。\n将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。\n反序列化的时候，必须能够找到对应字节码的类\ntransient 反序列初始为0\n多线程\n\n等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。\n同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。\n其他阻塞（虽然阻塞但是没有获得锁）：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。\n\n守护线程：其他所有线程结束后 JVM退出 不关心守护线程的运行情况 JVM退出后守护线程会自动关闭 用来执行后台任务\n优先级不保证执行顺序\n只需要自己执行start（）,run能隐式执行\nstart会创建线程 run不会 只是一个普通方法\n创建线程的方式(都需要实现run方法 calllable是call方法):\n\nimplements runnable\nextends Thread\nimplements callable （可以有返回值 可以抛异常）\n\n修饰符限定范围\ndefault (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\nprivate : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\npublic : 对所有类可见。使用对象：类、接口、变量、方法\nprotected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\n\n\n字符串&#x2F;字符string不可修改\ns.charAt(num);\ns.length();\ns.equals();\ns.toLowerCase();\n&#x2F;&#x2F;+ 拼接\ns.compareTo();\ns.indexOf(String str,int index)\nString replace(char oldChar, char newChar)\nString substring(int beginIndex, int endIndex)\nString toString()\ncontains(CharSequence chars)\n&#x2F;&#x2F;格式化字符串输出\nString.format(&quot;XX&quot; + &quot;YY&quot; + &quot;%d&quot;,v);\nString a &#x3D; &quot;123&quot;;&#x2F;&#x2F;常量池\nString b &#x3D; new String(&quot;123&quot;);&#x2F;&#x2F;堆\n\n\n常用库Math.floor;\nMath.round;\nMath.ceil;\n\n正则表达式        String s &#x3D; &quot;W10&quot;;\n        String pattern &#x3D; &quot;(A|W|D|S)(?&lt;num&gt;\\\\d&#123;2&#125;)&quot;;\n        Pattern p &#x3D; Pattern.compile(pattern);\n        Matcher m &#x3D; p.matcher(s);\n        if (m.find()) &#123;\n&#x2F;&#x2F;            Integer n &#x3D; m.group(2);\n            System.out.println(m.group(2));\n        &#125;\n        String a &#x3D; &quot;aaabbaaaa&quot;;\n        String pattern &#x3D; &quot;.*(...).*\\\\1.*&quot;;\n&#x2F;&#x2F;\\\\1表示第一个group 要和第一个group相同\n        Pattern p &#x3D; Pattern.compile(pattern);\n        Matcher m &#x3D; p.matcher(a);\n        System.out.println(m.find());\n\n随机数private Random random &#x3D; new Random();\n&#x2F;&#x2F;[0,total)\nint x &#x3D; (int) random.nextInt(total - 1) * total + 1;\n\nArrayint[] a &#x3D; new int[] &#123;1,2&#125;;\nSystem.out.println(Arrays.stream(a).max().getAsInt());\n&#x2F;&#x2F;串行流没有for循环快 并行流比for快\nint[][] a &#x3D; &#123;&#123;1,2&#125;,&#123;4,3&#125;,&#123;1,3&#125;&#125;;\n        Arrays.sort(a,new Comparator&lt;int[]&gt;() &#123;\n            public int compare(int[] o1,int[] o2) &#123;\n                if (o1[0] - o2[0] !&#x3D; 0) &#123;\n                    return o1[0] - o2[0];\n                &#125; else &#123;\n                    return o1[1] - o2[1];\n                &#125;\n            &#125;\n        &#125;);\n&#x2F;&#x2F;排序\n        List&lt;int[]&gt; b &#x3D; Arrays.asList(a);\n        a &#x3D; b.toArray(new int[b.size()][]);\n\n\n\n文件IOtry (BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(\"output.txt\"))) &#123;\n            Iterator iterator = wordAnalysisList.iterator();\n            while (iterator.hasNext()) &#123;\n                symbol = (HashMap&lt;String, String>) iterator.next();\n                if (symbol.get(\"class\").equals(\"ANNO\")) &#123;\n                    continue;\n                &#125;\n                bufferedOutputStream.write((String.format(\"%s %s\\n\",symbol.get(\"class\"),symbol.get(\"word\"))).getBytes());\n            &#125;\n            bufferedOutputStream.flush();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\ntry &#123;\n            FileWriter writer = new FileWriter(writeFile);\n            Iterator iterator = wordAnalysisList.iterator();\n            while (iterator.hasNext()) &#123;\n                symbol = (HashMap&lt;String, String>) iterator.next();\n                if (symbol.get(\"class\").equals(\"ANNO\")) &#123;\n                    continue;\n                &#125;\n                writer.write(String.format(\"%s %s\\n\",symbol.get(\"class\"),symbol.get(\"word\")));\n            &#125;\n            writer.flush();\n            writer.close();\n        &#125; catch (IOException e) &#123;\n            e.pintStackTrace();\n        &#125;\n\n\n异常\ntry &#123;\n    file &#x3D; new FileInputStream(fileName);\n    x &#x3D; (byte) file.read();\n&#125; catch(FileNotFoundException f) &#123; &#x2F;&#x2F; Not valid!\n    f.printStackTrace();\n    return -1;\n&#125; catch(IOException i) &#123;\n    i.printStackTrace();\n    return -1;\n&#125;\n\nException又分为两种：\n\nJVM(Java**虚拟机)** 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。\n程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。\n\n函数式编程{}里面是匿名函数\nmap.forEach((key,value) -&gt; &#123;\n            if (heap.size() &lt; k) &#123;\n                heap.offer(new int[] &#123;key,value&#125;);\n            &#125; else if (value &gt; heap.peek()[1]) &#123;\n                heap.poll();\n                heap.offer(new int[] &#123;key,value&#125;);\n            &#125;\n            &#x2F;&#x2F;匿名函数\n        &#125;);\n\nPriorityQueue&lt;int[]&gt; heap &#x3D; new PriorityQueue&lt;&gt;(new &lt;int[]&gt;() &#123;\n            public int compare(int[] m, int[] n) &#123;\n                return m[1] - n[1];\n            &#125;\n        &#125;);\n表示实现Comparator接口的匿名类\n\nlambda表达式PriorityQueue&lt;int[]&gt; pq &#x3D; new PriorityQueue&lt;int[]&gt;((a,b)-&gt;nums1[a[0]]+nums2[a[1]]-nums1[b[0]]-nums2[b[1]]);\n&#x2F;&#x2F;() -&gt; 返回值 括号为传入参数\n\n\n\nOO相关继承extends 默认继承object\nsuper this\npublic class Animal &#123; \n    private String name;  \n    private int id; \n    public Animal(String myName, int myid) &#123; \n        name &#x3D; myName; \n        id &#x3D; myid;\n    &#125; \n    public void eat()&#123; \n        System.out.println(name+&quot;正在吃&quot;); \n    &#125;\n&#125;\npublic class Penguin extends Animal &#123; \n    public Penguin(String myName, int myid) &#123; \n        super(myName, myid); \n    &#125; \n&#125;\n\n\n\n\n接口implements\n除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n\n抽象类&#x2F;方法abstract \n抽象方法无方法体\n必须被继承才能使用 必须重写抽象类的抽象方法 否则也必须是抽象类\npublic abstract class Employee\n&#123;\n   private String name;\n   private String address;\n   private int number;\n   \n   public abstract double computePay();\n   \n   &#x2F;&#x2F;其余代码\n&#125;\n\n\n\n重载和重写重载（overload）：必须拥有不同的参数列表（名字还是相同）返回类型可以不同 方法体当然可以不同\n\n重写(override):只改变方法体\n\nJava8lambdalambda表达式本质上可以理解成一个函数 是函数式编程中的概念\n在java中没有新提出函数类型，而是用实现了对应接口的类的实例\n函数式接口(@FunctionalInterface)：有且仅有一个抽象方法，但是可以有多个非抽象方法的接口；可以被隐式转化为lambda表达式\npublic static void main(String[] args) &#123;\n    List&lt;Apple> apples = new ArrayList&lt;>();\n    apples.add(new Apple(5));\n    apples.add(new Apple(3));\n    apples.add(new Apple(4));\n    //最naive的写法:一个比较器类 实现了comparator接口\n    //面向接口编程\n    Comparator apppleComparator = new AppleComparator();\n    Collections.sort(apples, apppleComparator);\n    //使用匿名类\n    Collections.sort(apples, new Comparator&lt;Apple>() &#123;\n        @Override\n        public int compare(Apple o1, Apple o2) &#123;\n            return o1.getWeight() - o2.getWeight();\n        &#125;\n    &#125;);\n    //lambda表达式\n    Collections.sort(apples, (a1, a2) -> a1.getWeight() - a2.getWeight());\n    //使用Comparator的comparing静态方法\n    //comparing:根据传入的keyExtractor构造comparator\n    //keyExtractor使用lambda表达式\n    Collections.sort(apples, Comparator.comparing(a -> a.getWeight()));\n    //keyExtractor使用方法引用\n    Collections.sort(apples, Comparator.comparing(Apple::getWeight));\n\n\n&#125;\n\npublic static class AppleComparator implements Comparator&lt;Apple> &#123;\n    @Override\n    public int compare(Apple o1, Apple o2) &#123;\n        return o1.getWeight() - o2.getWeight();\n    &#125;\n&#125;\n\n\n\n\nstream\nfilter：将元素按条件过滤 （lambda表达式返回为true就留下，反之过滤）\nmap：将元素进行映射 （lambda表达式进行元素转换）\nflatMap:扁平化映射\nlimit（n）：从左往右数n个\nskip(n)：扔掉前n个元素\ncollect：lambda表达式表示表示要转化的目标容器\ntoList:转化成list\n\n\nforEach：每个元素执行lambda表达式的操作\ndistinct：去重\nsorted: 排序（按照lambda表达式）\ncount: 统计元素个数\nanyMatch: 是否有一个匹配（lambda表达式返回bool）\nallMatch：所有的都匹配\nnoneMatch:没有一个匹配\nfindFirst：返回第一个符合的元素(注意有Optional的包装)\nfindAny：随机返回一个Optional\nreduce（n,lambda):两两进行规约，n表示起始值 ；lambda为规约方式\n\nint max = Arrays.stream(array).reduce(Integer.MIN_VALUE, Integer::max);\n\n\ngroupingBy(lambda):按照lambda(keyExtractor)的方式进行分组；返回Map\n\nint[] a = &#123;1, 2, 3, 4, 5, 5&#125;;\nList&lt;Integer> s = Arrays.stream(a).distinct().boxed().collect(Collectors.toList());\ns.forEach(System.out::println);\n\n\nStream.of：构造of中元素的流\n\nList和Array互转//int[] -> List\nList&lt;Integer> ans = Arrays.stream(array).boxed().collect(Collectors.toList());\n\n//List -> int[]\nint[] res = ans.stream().mapToInt(Integer::intValue).toArray();\n\n//List -> int[]\nList&lt;String> a = new ArrayList&lt;>();\nString[] b = a.stream().toArray(String[]::new);\n\n\n\noptionalAPIJsonjson-&gt;object@Data\nstatic class DirObject &#123;\n    private boolean hasChildren;\n\n    private ArrayList&lt;DirObject> children;\n\n    private String name;\n&#125;\n\n注意解析的时候如果有内部类的嵌套 嵌套内部类需要用静态内部类\nString dirContent = downloadString(url);\nDirObject dirObject = JSONObject.toJavaObject(JSONObject.parseObject(dirContent), DirObject.class);\n   Map&lt;String, DataInfo> data = JSONObject.toJavaObject(JSONObject.parseObject(fileContent), Map.class);\n\n\njson容器JSONObject jsonObject = new JSONObject();\njsonObject.put(column[i], item[i]);\n\n正则表达式group(0)代表整个 group(1)代表第一个括号里的 以此类推\npublic class RegexMatches\n&#123;\n    public static void main( String[] args )&#123;\n \n      // 按指定模式在字符串查找\n      String line = \"This order was placed for QT3000! OK?\";\n      String pattern = \"(\\\\D*)(\\\\d+)(.*)\";\n \n      // 创建 Pattern 对象\n      Pattern r = Pattern.compile(pattern);\n \n      // 现在创建 matcher 对象\n      Matcher m = r.matcher(line);\n      if (m.find( )) &#123;\n         System.out.println(\"Found value: \" + m.group(0) );\n         System.out.println(\"Found value: \" + m.group(1) );\n         System.out.println(\"Found value: \" + m.group(2) );\n         System.out.println(\"Found value: \" + m.group(3) ); \n      &#125; else &#123;\n         System.out.println(\"NO MATCH\");\n      &#125;\n   &#125;\n&#125;\n\n文件读写CSVpublic List&lt;User> readUserCSV() &#123;\n    ArrayList&lt;User> results = new ArrayList&lt;>();\n    try &#123;\n        BufferedReader reader = new BufferedReader(new FileReader(csvFile));\n        //读取columnName list\n        String line = null;\n        String column[] = line.split(\"，\");\n        while((line = reader.readLine()) != null)&#123;\n            String item[] = line.split(\"，\");\n            results.add(loadUser(column, item));\n        &#125;\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n    return results;\n&#125;\n\nattention整型溢出问题int a = Short.MAX_VALUE;\nlong b = Short.MAX_VALUE;\nSystem.out.println(a * b > 1); //true a 向上转化成long 不溢出\n\nint a = Short.MAX_VALUE;\nint b = Short.MAX_VALUE;\nSystem.out.println(a * b > 1);//false a * b 还是int型 溢出\n\n","slug":"JavaLearning","date":"2021-03-03T02:56:52.000Z","categories_index":"learning","tags_index":"Java","author_index":"Sihan Chen"},{"id":"16dddd2808895ffe203f5dab69ce83b4","title":"PythonLearning","content":"PythonLearning记录一下Python的学习，方便以后复习，如果能帮到其他人就更好了\n\nIOinputleft,right = map(int,input().split(\" \"))\n#以list的形式存储\nl = list(map(int,input().split(\" \")))\n\noutput#python中没有类似c和java的%s %d\n#想要输出的都包括再括号中\nprint(\"&#123;&#125;,&#123;&#125;\".format(1,[1,2]))\n#保留两位小数\nprint(\"&#123;:.2f&#125;\".format(3.1415))\n#表示带符号\nprint(\"&#123;:+.2f&#125;\".format(3.1415))\n#科学计数法\nprint(\"&#123;:.2e&#125;\".format(3.1415))\n#不空行\nprint(1,end=\"\")\n\n运算符~:取反\n^:异或\nstr&#x2F;chr1.lower() upper() 方法对字符&#x2F;字符串可以直接使用 如果是字母自动生效 否则不起作用\n2.count统计字符串中字符出现次数\ns = \"123\"\ns.count(\"1\")\n#1\n\nListunhashable! 不能做dict 的key\n1.list.index得到下标如果有多个相同元素 优先第一个\n2.list.insert(index,obj)list.insert(index,obj)在原列表上进行插入，直接更改原列表，无有意义的返回值，默认返回None\nhint:replace字符串不同，由于字符串的不可变性，replace需要进行构造新的字符串，所以有有意义的返回值，返回新的字符串\n3.join split‘char’.join(seq) 将char作为分隔符将seq里面的元素连接成新的字符串\n注意seq里的元素必须是字符数组\n#互逆\n#注意seq必须是由字符(串)组成的\n&#39;,&#39;.join(seq)\ns.split(&#39;,&#39;)\n\n4.sort &amp;&amp; sorted(key&#x3D;排序方式,reverse&#x3D;是否反转 默认升序)s &#x3D; [1,5,3]\ns.sort() # s &#x3D; sorted(s) 两种方法都可以 前一种是方法，与list这种结构捆绑，在原有的list上操作，不生成新的list,后一种是库函数，返回新的list\ns &#x3D; &quot;ba&quot;\ns &#x3D; &#39;&#39;.join(sorted(s))\nl &#x3D; sorted(int(t[:2]) * 60 + int(t[-2:]) for t in timePoints)\nl.sort()\nsorted(l)\n#key可以传一个cmp函数进去（需要进行封装）\nfrom functools import cmp_to_key\ndef cmp(a,b):\n    return a - b\nl.sort(key&#x3D;cmp_to_key(cmp))\n#key 当然也可以是lambda表达式\nl.sort(key&#x3D;lambda x:x)\n\n默认升序 reverse&#x3D;True 表示逆序排列\n5.切片注意[a:b]:表示左闭右开，右边取不到，左边能取到\n6.list.count(obj)统计某个元素出现的次数\n7.list.extend(seq)seq为可迭代对象\n向右端迭代加入seq中的所有元素\n8.list.pop()默认index &#x3D; -1 即最后一个 \n注意pop里面的参数是index\n9.list.remove(obj)移除第一个默认的匹配项 \n注意remove里面的参数是element！\n10.切片s1 &#x3D; [1,2,3]\n#深拷贝!\ns2 &#x3D; s1[:]\n#可以用来反转列表！\ns3 &#x3D; s1[::-1]\n\n11.列表推导式return [1 if x &gt;&#x3D; 0.5 else 0 for x in probability]\n\n每当申请的内存用完了 如果还在加元素 就寻找一个更大的内存 并完成复制\n如果不断减少元素，就找一个更小的内存 并完成复制 以节省内存\ndict1、if xxx in dic判断的是key在不在dic里，而不是value\n2.字典相关操作dict.items() 返回turple的可迭代对象\ndict.keys()\ndict.values()\ndict.pop(key)#这里和list有区别！pop 在字典里是pop key 返回的是value 在list里是pop index 返回的是element\n\ntuplehashbale \n可以作为dict的 key 可以由list转过来\nRandom1.intrandom.randint(a,b)\n包含[a,b]\n2.charrandom.choice(string)\n实际上是选一个元素\n3.string''.join(random.sample(seq,num))\n\n队列队列插入弹出操作都是O(1)\npeek时间复杂度为O(1)\n队列完全可以用链表实现\n只需要用deque和priorityqueue\ndequefrom collections import deque\n\ndeque是python中的双端队列，既可以当作单向队列queue使用，又可以当作stack使用(stack也能用list实现)\n两端操作的时间复杂度都是O(1) 但是不能随机访问 (list可以随机访问 但是对左端操作的时间复杂度为O(n))\n感觉deque更像是链表\ndq &#x3D; deque()&#x2F;&#x2F;构造器 第一个参数为初始的元素，第二个为maxlen 默认无穷大\ndeque.append(obj)\ndeque.appendleft(obj)\ndeque.popleft()\ndeque.pop()\n#队列长度\nlen(dq)\ndq[0]\ndq[-1]\n\nPriorityQueue优先队列 默认递增队列 先出来的数value更小\n不推荐使用（没办法peek)\nimport queue\nqueue.PriorityQueue()\n#第一个参数为优先级，第二个参数是obj 需要合并成一个turple\nq.put((1,2))\n#优先get出低优先级的turple\nq.get()\n#优先队列的容量\nq.qsize()\n\n堆Python默认小顶堆! 如果需要大顶堆可以将元素取相反数 最后再取相反数回来\n插入弹出操作为O(logn):为了维护堆的性质 \n插入需要经过logn次上浮\n删除需要经过logn次下沉\n建堆O(n)\npeek时间复杂度为O(1)\n注意海量数据求TOPk(维护容量为k的堆 遍历元素 每次操作插入删除复杂度为O(logk)建堆O(k)  总共O(nlogk))\nimport heapq\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    h &#x3D; []\n    #先创建堆\n    heapq.heapify(h)\n    heapq.heappush(h,1)\n    heapq.heappush(h,4)\n    heapq.heappush(h,5)\n    print(heapq.heappop(h))\n    print(heapq.heappop(h))\n    print(heapq.heappop(h))\n    #可迭代 堆顶元素\n    print(h[0])\n\nDFS BFSDFS路径类问题 排列组合问题\n生成器和迭代器迭代器class Fib:\n    def __init__(self, n):\n        self.prev &#x3D; 0\n        self.cur &#x3D; 1\n        self.n &#x3D; n\n    def __iter__(self):\n    \treturn self\n    def __next__(self):\n        if self.n &gt; 0:\n            value &#x3D; self.cur\n            self.cur &#x3D; self.cur + self.prev\n            self.prev &#x3D; value\n            self.n -&#x3D; 1\n            return value\n    \telse:\n            raise StopIteration()\n    # 兼容python2\n    def __next__(self):\n        return self.next()\nf &#x3D; Fib(10)\nprint([i for i in f])\n    #[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\t\n\n\n生成器本质是迭代器\n在 Python 中还有一种函数，用关键字 yield 来返回值，这种函数叫生成器函数 ，函数被调用时会返回一 个生成器对象，生成器本质上还是一个迭代器(iterable)，也是用在迭代操作中，因此它有和迭代器一样的特性，唯 一的区别在于实现方式上不一样，后者更加简洁\ndef fib(n):\n    prev, curr &#x3D; 0, 1\n    while n &gt; 0:\n        n -&#x3D; 1\n        yield curr\n        prev, curr &#x3D; curr, curr + prev\nprint([i for i in fib(10)])\n\n类class heap(object):\n    #括号里可以填写要继承的父类 python语法上支持多继承\n    #python类属性的引用都需要带上self\n    &#39;&#39;&#39;mode &#x3D;&#x3D; 0 means little heap mode &#x3D;&#x3D; 1 means big heap&#39;&#39;&#39;\n    def __init__(self,heap,mode):\n        self.__heap &#x3D; []\n        self.__mode &#x3D; mode\n        for element in heap:\n            self.push(element)\n\n    def get_size(self):\n        return len(self.__heap)\n\n    def get_top(self):\n        if not heap:\n            raise IndexError()\n        return self.__heap[0]\n\n    def push(self,element):\n        p &#x3D; self.get_size()\n        self.__heap.append(element)\n        if self.__mode &#x3D;&#x3D; 0:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &gt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        else:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &lt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        ##up\n\n    def pop(self):\n        p &#x3D; self.get_size() - 1\n        self.__heap[0],self.__heap[p] &#x3D; self.__heap[p],self.__heap[0]\n        top &#x3D; self.__heap.pop()\n        p &#x3D; 0\n        size &#x3D; self.get_size()\n        if self.__mode &#x3D;&#x3D; 0:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &lt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &gt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                ##down handle index out of range\n        else:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &gt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &lt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                #down handle index out of range\n        return top\n\n和**arg代表位置参数 实质上是turple\n**arg代表关键词参数 实质上是dict\n并行赋值(多变量赋值) 、连续赋值并行赋值（多变量赋值）千万别用 超级容易错 并且错了都没法de的那种 如果光是两个int这种不可变类型勉强可用 一旦涉及指针千万别用！\ndef reverseList(self, head):\n    prev &#x3D; None\n    while head:\n        head.next, prev, head &#x3D; prev, head, head.next\n    return prev\n\n具体的过程是这样的。先执行&#x3D;右边表达式(None, head, head.next)，然后第一步把head.next=None，此时head变成了1-&gt;None；第二步，执行prev=head，这里为什么head的值时1-&gt;None而不是1-&gt;2-3-&gt;None呢，因为虽然等式先执行的右边，拿到了head，但是上一步的操作是将head修改了，由于head是一个可变对象，prev的值是1-&gt;None，最后再把head=head.next，这里为什么head.next的值又是2-&gt;3-&gt;None了呢，因为，执行右侧的表达式之后，head.next这个对象再前两步中没有被修改，一直都是2-&gt;3-&gt;None，这正是和第二步不同的地方，所以这两个写法是等同的。\n连续赋值a &#x3D; a.next &#x3D; ListNode(1)\n#等价于\n_ &#x3D; ListNode(1)  \na &#x3D; _\na.next &#x3D; _\n\nfoo &#x3D; [0]\nbar &#x3D; foo\nfoo[0] &#x3D; foo &#x3D; [1]\n\nprint(foo) #[1]\nprint(bar) #[[1]]\n\n遇到指针就别用这些东西了！\n下划线_foo\n#表示private 方法&#x2F;属性\n__foo\n#表示final 不允许进行重写\n__foo__\n#表示特殊的方法 一般会对其进行重写\nfoo_\n#表示避免和python内置关键词重复\n_\n#约定表示占位符\n\n特殊方法1.getitem:\n重写后实例变为subscriptable 支持通过实例直接当字典和list用 eg.f[1]\nOOP@注解@property\ndef foo():\n    pass\n\n之后可以将方法当作属性调用\n文件操作相对路径.&#x2F; ..&#x2F; ..&#x2F;..&#x2F; \n常用函数1.sums &#x3D; sum(x for x in l)\n\n2.json&lt;-&gt;dictj = json.dumps(d)\ntype(j)\n#已经转化为json字符串\nd = json.loads(j)\ntype(d1)\n\n3.arg注意python中有positional argument,keyword argument两种参数 规定前者在前\n传参的时候依次赋值，如果存在有默认值的参数也需要赋值，一旦出现后者，后面的赋值必须都要是keyword argument型\n4.bisectprint(bisect.bisect_left([1,2,3,4,5,6],3,1,3))\n源码\ndef bisect_left(a, x, lo&#x3D;0, hi&#x3D;None):\n    &quot;&quot;&quot;Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that \n    \n    all e in a[:i] have e &lt; x, and all e in\n    a[i:] have e &gt;&#x3D; x.  \n    \n    So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    &quot;&quot;&quot;\n\n    if lo &lt; 0:\n        raise ValueError(&#39;lo must be non-negative&#39;)\n    if hi is None:\n        hi &#x3D; len(a)\n    while lo &lt; hi:\n        mid &#x3D; (lo+hi)&#x2F;&#x2F;2\n        if a[mid] &lt; x: lo &#x3D; mid+1\n        else: hi &#x3D; mid\n    return lo\n\n如果所有数都比x小 则返回的index为len(a)！所以如果hi要写最好写len(a) 否则会与假定情况相悖\n例如\nbisect.bisect_left([0,1,3,6,10,15],25,5,5) 返回5 但是15并不大于等于25 导致出错 \nbisect.bisect_left([0,1,3,6,10,15],25,5,6) 6 &#x3D; len(a) 返回的是6 意思是整个数组中没有大于25的数 全都小于25 综上hi一定要用len(a) 或者不写hi\n\n5.ord chrx &#x3D; &#39;a&#39;\nprint(ord(x)) #61h\nprint(chr(97)) #&#39;a&#39;\n\n6.&#x3D;&#x3D;注意python&#x3D;&#x3D;如果用于对象是判断地址是否相同 需要改写__eq__\n如果用于list可以直接判断list对应元素相不相等\n如果用于dict也可以判断对应kv是否完全相同\nAnacondaconda create -n name python = 3.7\n#创建新环境\n\nconda env list\n#查看环境\n\nconda activate name\n#激活环境\n\nconda deactivate\n#退出环境\n\nconda remove --name test --all\n#删除环境\n\nconda install req \npip install req\n#安装包\n\nconda remove req\npip uninstall req\n#卸载包\n\nconda list\n#查看环境\n\n常见问题基本操作pip install pipreqs\npipreqs .&#x2F;\n#导出依赖包\npip install -r requirements.txt\n#导入依赖包\npip list --format&#x3D;freeze &gt; requirements.txt\n#导出依赖\n\n数组初始化#尽量不要用 第二重循环的意思是对列表进行浅拷贝 第一重循环对element操作 直接复制\n[[0] * l] * l\n\n#改成\n[[0 for _ in range(l)] for _ in range(l)]\n\n\n\n","slug":"PythonLearning","date":"2020-09-05T02:57:00.000Z","categories_index":"learning","tags_index":"Python","author_index":"Sihan Chen"},{"id":"1cac424653694fd0abd1397c14df4e06","title":"leetcode","content":"leetcode\n\n\n\ninput size\n时间复杂度\n常见算法\n\n\n\n1~10\nn!\n排列\n\n\n15~20\n2^n\n组合\n\n\n10~50\nn^4\n\n\n\n100~200\nn^3\n\n\n\n1000~2000\nn^2\nDP 图问题\n\n\n10^6\nnlogn\n贪心 堆 分治 排序\n\n\n10^7\nn\nDP 图问题\n\n\n2^31   10^9\nsqrt(n)\n数论问题\n\n\n2^31  10^9\nlogn\n二分查找 分治\n\n\n10^9\n1\n数学归纳\n\n\n一.基本数据结构熟悉（简单题）1.栈5.19\n1.括号匹配1.简单做法 操作栈\n注意stack为空的情况\n不匹配直接结束\nhint 可以进行奇偶判断\n2.两个stack实现queueinStack和outStack作用：倒腾\n如果连续两次入队(出队)，即连续两次操作相同，不用倒腾\n一旦产生变化需要换stack\ninStack &#x3D; [1,2]\nfor item in inStack:\n\toutStack.append(inStack.pop())\n#错误 loop1：item &#x3D; 1 pop出2 不会进行第二次loop\n\n5.20\n3.两个queue实现stack\n我的做法：注意flag的维护即可 定义主队列 ？？？\n\npush O(1)\npeek 与 pop复杂度相同 O(n)\nemptyO(1)\n\n1.单队列循环实现栈\n2.规定主队列辅助队列 辅助队列用来存最新入栈的元素 实现队列与栈同顺序\n\npop的时候换队列即可\n4.最小栈\n我的思路：维护最小元素的指针 × 连续pop找不到上一个最小的\n1.最小index栈 如果a下面有bcd a对应的minIndex为x看了题解才知道的trick 如果位于栈上面的元素不动 下面的性质则和之前一样因此每个元素可以对应一个最小的index 元素改变之后刚好对应index更新另外 len忘-1 导致bug\n\n辅助栈\n将每个地方对应的最小值存起来\n5.21\n\n5.比较退格字符串  5.26\n\n1.用stack实现 压栈出栈2.双指针法注意两个字符串都要遍历完，如果写的while条件是\nwhile i &gt;&#x3D; 0 and j &gt;&#x3D; 0:\n    pass\n# bb# bb 执行错误\n\n指针是-1 退格符过多已经把所有的前面的字符都清了\n如果两个都是 -1 说明相等（后面的字符串已经相等了）\n1021.删除最外层的括号单纯的入栈弹栈括号匹配，只是要去掉最外层的括号，如果只有一层就不能去，有些坑\npython没有找到比较好的直接替换两端括号的方法：\n1.str-&gt;list-&gt;str\n2.特判选对index\nhint：入栈出栈其实还可以用count来表示，入栈count++，出栈count–，以计数器来模拟栈的出入操作\n461. 汉明距离5.28\n\nhint：海明码\n朴素想法：化成二进制逐位判断\n正常想法：做异或，判断1的个数，有几个1就有多少位不同\n优化：Brian Kernighan 统计x中1的个数每次用x&amp;&#x3D;（x-1） 循环多少次就有多少个1 每次循环把最右端的1变为0\nBrian Kernighan应用：\n\n判断一个数是否是2的幂次方 用 return x &amp; (x-1) &#x3D;&#x3D; 0\n\n把某个区间的数全部&amp;起来，可以把右端的数不断去1，直到小于左端：如果去掉1还在范围内，说明此位位0（&amp;），如果不是，那么我只关心最新的在区间中存不存在这位是0的数，如果存在那么全部&amp;起来的结果就是这个数，显然是存在的。因为左端大于等于这个数，等于则显然，如果大于，那么此位一定是0\n比如如果最后的数是1000 那么区间中一定存在1100 左端一定小于1100 所以一定是10xx\n\n\n477.汉明距离总和暴力两遍循环TLE O（n^2）\ntrick：一个数组里面按位来统计，如果是1就统计其他元素对应位有多少个0，反之亦然。这样就只有一次循环O(n)\n另外还有位数的循环O(L)忽略\n另外10^3 &lt; 2^10 &#x3D;&gt; 10^9 &lt; 2&lt;^30\nhint:\n101\n101\n100\n100\n000 \n则第0位 一共贡献3 &#x3D; 2 * 3\nc = sum((val >> i) &amp; 1 for num in nums)\n\n\n\n2.堆  5.28\n\noffer 40.最小k的个数朴素算法，直接排序取最小k个\nhint：去最小k个可以直接切片 切片相比于朴素的重新构造数列直接快了一半，个人觉得因为切片只需要移动指针，但是重新构建list需要重新append &amp;&amp; pop（）一遍，特别是对于原数组pop（0）是对头进行操作，所有的元素都要进行移动\n堆 \npython的优先队列库：\nimport heapq\nhp &#x3D; []\nheapq.heapify(hp)\n#是具有堆的性质 pyhton默认是小顶堆\nheapq.heappush(hp)\n#加入到队列 头部hp[0]始终位堆顶\nheapq.heappop(hp)\n#pop出头部的元素\nheapq.heappushpop(hp,item)\n#将新元素加入队列 并pop出头部的元素\n\n\n5.30\n\n231.2的幂就是上周的trick数1\n要注意负数，负数直接返回False (和heap有什么关系？)\nnewTrick：\n如果是2的幂次：\nn &#x3D; n &amp;(-n)\n1046. 最后一块石头的重量简单的python堆 应用\n找个机会练下手写堆:\n5.31\n\nclass heap(object):\n    &#39;&#39;&#39;mode &#x3D;&#x3D; 0 means little heap mode &#x3D;&#x3D; 1 means big heap&#39;&#39;&#39;\n    def __init__(self,heap,mode):\n        self.__heap &#x3D; []\n        self.__mode &#x3D; mode\n        for element in heap:\n            self.push(element)\n\n    def get_size(self):\n        return len(self.__heap)\n\n    def get_top(self):\n        if not heap:\n            raise IndexError()\n        return self.__heap[0]\n\n    def push(self,element):\n        p &#x3D; self.get_size()\n        self.__heap.append(element)\n        if self.__mode &#x3D;&#x3D; 0:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &gt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        else:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &lt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        ##up\n\n    def pop(self):\n        p &#x3D; self.get_size() - 1\n        self.__heap[0],self.__heap[p] &#x3D; self.__heap[p],self.__heap[0]\n        top &#x3D; self.__heap.pop()\n        p &#x3D; 0\n        size &#x3D; self.get_size()\n        if self.__mode &#x3D;&#x3D; 0:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &lt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &gt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                ##down handle index out of range\n        else:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &gt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &lt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                #down handle index out of range\n        return top\n\n由于涉及到大小根堆的模式 多了很多冗余代码暂时没有想到怎么处理，只是单纯的copy了一下 毕竟原理相同\n写的时候要特别注意python类的语法 还有堆排序的要点（上浮下沉)\n3.队列6.1\n\n346. 数据流中的移动平均值题目意思看不懂\n朴素做法：\n直接用python的list&amp;&amp;自带的方法维护队列 相当于手动构造\n由于list是单向的 实际上就是一个数组 强行搞成双端 每次pop（0）都需要涉及到一堆元素的移动 \n不需要维护list\n记录最前面的数、size、sum就好了 O(1)\n1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？儿童节快乐！！！！！！\n怪的不得了\n自己手写的算法没有做记忆化 导致超时\n先求前缀和\n然后求范围， 看是否match\n9.4\n4.二叉树递归只涉及到三条语句 前中后序遍历只涉及到语句的不同位置\n递归实现public List&lt;Integer> preorderTraversal(TreeNode root) &#123;\n    ArrayList&lt;Integer> results = new ArrayList&lt;>();\n    if (root == null) &#123;\n        return results;\n    &#125;\n    results.add(root.val);\n    results.addAll(preorderTraversal(root.left));\n    results.addAll(preorderTraversal(root.right));\n    return results;\n&#125;\n\t\npublic List&lt;Integer> inorderTraversal(TreeNode root) &#123;\n    ArrayList&lt;Integer> results = new ArrayList&lt;>();\n    if (root == null) &#123;\n        return results;\n    &#125;\n    results.addAll(inorderTraversal(root.left));\n    results.add(root.val);\n    results.addAll(inorderTraversal(root.right));\n    return results;\n&#125;\n\npublic List&lt;Integer> postorderTraversal(TreeNode root) &#123;\n    ArrayList&lt;Integer> results = new ArrayList&lt;>();\n    if (root == null) &#123;\n        return results;\n    &#125;\n    results.addAll(postorderTraversal(root.left));\n    results.addAll(postorderTraversal(root.right));\n    results.add(root.val);\n    return results;\n&#125;\n\n迭代实现前中后序遍历的迭代实现\n迭代有考究：需要用到stack ，node非空是为了避免root为空的情况吗，都需要判断当前节点是否为空\n\n1.pre 如果stack和node非空，就一直找左子节点，不断访问信息 然后压栈，压栈是为了之后能够回去找到右子节点；如果节点为空，说明没有左子节点，开始访问右子节点，这时就要弹上次压入的节点，然后找到右子节点\n2.in 做法同pre 知识访问的地方在弹栈之后：如果stack和node非空,压入该节点然后找到左子节点；如果节点空，则弹栈，访问该节点信息，然后通过该节点找到右子节点\n3.post 做法和前两者不同：先判断当前是否为空，如果不空，则压入，如果左子节点不空则找到左子节点，反之找到右子节点；如果空，则弹栈（此时两子节点都空），访问信息，然后peek一下，看是否是这个节点的左子节点，如果是，那么则找到该peek节点的右子节点，如果不是，说明现在已经是右子节点了，已经访问完了，所以就直接令为None 以便下一次循环直接再pop一次\n\n  &#x2F;&#x2F;迭代中序\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n       List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();\n       Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n       TreeNode cur &#x3D; root;\n       while (cur !&#x3D; null || !stack.isEmpty()) &#123;\n           while (cur !&#x3D; null) &#123;\n               ans.add(cur.val);\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;\n           cur &#x3D; stack.pop();\n           cur &#x3D; cur.right;\n       &#125;\n       return ans;\n   &#125;\n\n   &#x2F;&#x2F;迭代中序\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n       List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();\n       Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n       TreeNode cur &#x3D; root;\n       while (cur !&#x3D; null || !stack.isEmpty()) &#123;\n           while (cur !&#x3D; null) &#123;\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;\n           cur &#x3D; stack.pop();\n           ans.add(cur.val);\n           cur &#x3D; cur.right;\n       &#125;\n       return ans;\n   &#125;\n\n   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n       TreeNode cur &#x3D; root;\n       Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n       List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();\n       while (cur !&#x3D; null || !stack.isEmpty()) &#123;\n           while (cur !&#x3D; null) &#123;\n               stack.push(cur);\n               if (cur.left !&#x3D; null) &#123;\n                   cur &#x3D; cur.left;\n               &#125; else &#123;\n                   cur &#x3D; cur.right;\n               &#125;\n           &#125;\n           cur &#x3D; stack.pop();\n           &#x2F;&#x2F;说明这个node的左右子节点都是null 直接visit\n           ans.add(cur.val);\n           &#x2F;&#x2F;该节点是上个节点的左节点\n           if (!stack.isEmpty() &amp;&amp; stack.peek().left &#x3D;&#x3D; cur) &#123;\n               &#x2F;&#x2F;说明当前节点是上一个节点的左子节点不能弹出\n               cur &#x3D; stack.peek().right;\n           &#125; else &#123;\n               &#x2F;&#x2F;这里其实可以直接pop上一个节点\n               &#x2F;&#x2F;赋null 也可以 就是多走一次循环\n               cur &#x3D; null;\n           &#125;\n       &#125;\n       return ans;\n   &#125;\n\n二、剑指offer剑指offer专项突击1.位运算除法最直观的思路就是用减法做循环（处理好绝对值和符号） 但是会超时 \n考虑位运算 每次用最接近的数做减法即可（二进制意义）\n注意唯一可能会出现的溢出情况：不存在小数 除法不会溢出 \n但是正负的最大值差1  除-1可能溢出 \n另外注意python倒序遍历的写法\nfor i in range(31,-1,-1):\n\n就是这个MIN值恶心 注意讨论ab分别等于MIN的情况 和+-1的组合\n注意先右移判断大小 然后左移做差 防止溢出\nInteger.MIN_VALUE == Math.abs(Integer.MIN_VALUE)\n\n时间空间复杂度都是O(1)\n注意符号对结果的影响的简单写法\n(dividend > 0) ^ (divisor > 0)\n\n2.二进制加法从低位向高位累加即可 对于任意进制都适用 \n考虑到需要做除法（取余） 可以用位运算\n累加器：a b c \n当前bit的计算 : a ^ b ^ c \n性质：所有bit异或表示计算1的奇偶性 如果是奇数个 结果是1 反之是0 （当前位是1， 只有可能是1个或者3个1）\ncarry : 至少2个1才会进位\n表达式：(a &amp; b) | ((a | b) &amp; c) \n或者 (a &amp; b) | ((a ^ b) &amp; c) \n3.count 1\nBK &amp;算法：求x有多少个1 循环x &#x3D; x &amp; (x-1) 直到x &#x3D;&#x3D; 0 每做一次就末尾少一个1 （-1 减掉了末尾的1 原来1后面都是0 自然&amp;掉）\n\n最高有效位 动态规划 x &#x3D; y + z,bit[x] &#x3D; 1 + bit[z] y对应的二进制只有最高位为1 从1遍历到n 这个y为最接近x的以1开头的二进制数 需要不断更新y(每次遇到更大的y就记录一下) \n\n最低设置位 可以看成最高有效位的变种 从低位开始 拿走1之后找关系\n\n最低有效位 考虑低位 只有两种可能要么有1要么无 bit[x] &#x3D; bit[x &gt;&gt; 2] + x &amp; 1 ，注意x&amp;1表示对2取余\n\n\n总的来说后三种都是动态规划,考虑当前x和之前的数的关系,要么从头拿走1 要么从尾拿走1\nO(n)说明了只能走一遍循环\n注意位运算优先级\n4.只出现一次的数字很简单的Hashmap法 时间复杂度O(n) 但是需要额外空间\n不用额外的空间复杂度对于32位的int，如果每个数字出现了3次，那么他的第i位二进制求和mod3余0，如果只出现一次那个该位就是mod3后的值，因此只需要对所有位求和然后mod3即可\n但是这样需要遍历32位，时间复杂度位O(nlogC) C为位数\n考虑用遍历一次O(n)的方法：\n不用考虑进位 只用考虑mod，显然是状态机，并且由题意没有出现2次的数知，不可能有2 这个状态\n用00 01 10表示三个状态 写出转移表\n\n\n\n\n不看10的结果，只看00 01 显然(ai,bi)就是(bi) return b即可\n5.单词长度的最大乘积首先想到的就是两两比较 二重循环 然后用hashset看字母是否有交集\n由于求的是是否有交集可以用bitmap\n改进 用int32 存储每个单词的信息 如果没有交集 那么两个int相交为0 \n由于字母多次重复不影响bitmap，同时长度更长 对于同一个int32 优先长度更长的\n使用hashmap，然后两两计算无交集下的长度乘积\n时间复杂度O(n^2+ nL)\n6.排序数组中两个数字的和用hashmap （num,index) 很直观 （注意题目要求index1 &lt; index2) 时间空间复杂度都是O(n)\n但是注意题目给了一个条件非降序\n遍历+二分查找 O(nlogn) 这里自己动手实现了二分查找 \n双指针法 O(n) 注意思考什么不会漏答案 （什么时候移动左边 什么时候右边）\n7.数组中和为定值的若干个数初步思想为用hash表 但是注意题目要求不重复（针对num而不是index不重复）先固定第一个元素， 然后后两个转化成两数之和 用hashset 进行check，然后把结果（排序好的）放进去重的hashset即可\n没有想到用排序+双指针法 O(n^2)\n优化：剪枝\nps：遇到数组多往排序想 还有双指针别忘记了 好好理解双指针！注意两个指针移动的条件！\n8.连续子数组的和满足某个条件显然不能排序\n由于都大于零 写成前缀和 就变成递增数组了 转化成找差值已知的两个元素 二分查找O(nlogn)\n滑动窗口：两个指针同向移动 如果不够end右移 多了 start左移  (本质是优化二重循环) O(n^2) -&gt; O(n)\n注意区分滑动窗口和双指针\n9.连续子数组乘积满足某个条件注意这里的滑窗和一般的求最长最短滑窗不一样 而是在求满足条件的个数\n注意满足条件时的滑窗长度就是新增的个数\n10.连续子数组和为k连续子数组-&gt;不考虑排序\n注意数组里是整数 可能为负数 滑动窗口无法实现\n考虑前缀和 只需求出两个位置做差为k的所有对 O(n^2)\n注意没有要求出具体的index 只用求出个数 \nHash表优化 直接查需要的值存不存在有几个 注意前缀和从0开始 Hash表中初始有0：1 （前缀和to个数）\n如果求完前缀和再建Hash表 再统计就必须要判断这个数对应的index是否合法（可能出现当前位置之后的index 因为num可能为负）\n因此考虑边求前缀和 边建表 边统计 这样每次看到的Hash表都是前面的前缀和了（index 一定在前面）\n11.连续子数组满足某个条件这好像和求和没有什么关系啊！\n麻了　把０转成－１再求和就变成上一题了\n注意这里要求的是最长的长度　不是求个数　因此hash_map中记录的是index 并且是最小的index　所以hash_map中初始为０：０\n注意hash_map中的项一旦填了就不用改了，因为不会出现更小的index了\n也是从左到右on-the-fly地建立hashmap\n12.数组的中心下标 显然需要对两边求和 暴力法需要O(n^2)\n注意考虑两端都是0 且两边都没有元素的情况\n由于存在很多重复求和 \n首先求出sum(array), 然后遍历的过程中记录左边的和（exclude 当前元素），然后right &#x3D; sum(array) - cur - left, 判断right &#x3D;&#x3D; left， return index即可（已是最左） 空间复杂度O(1) 时间复杂度O(n)\n13.二维子矩阵的和显然如果直接求很简单 \n显然用前缀和 避免重复计算\n一般的按行或列进行前追求和，每次查询还是要进行一次求和 不能变成O(1)\n进阶版 用二维前缀和 实际上有点类似动态规划了 可证 递推式\n可以求出每次查询(row1,col1,row2,col2)的表达式\n对于面积f(i,j) 需要用动态规划先求出，面积f(i,j)也可以用递推式写出\n每次查询为O(1)\n链表数组相加链表数相加，很多坑！（感觉我写的太复杂了）\n1.要注意carry进位处理需要循环 \n2.注意如果在原来链表上改的话 需要将短链接到长链上\n3.感觉新操作一条链表可能不容易出错些 （保持循环有三个条件 carry l1 l2 当前是否为空）\n？？ 为什么新开链内存更小了？ 不懂\n14.字符串变位词仔细想变位的含意 意思是s1中的字符顺序无所谓 （反正可以自己随便调顺序） 那么转化位在s2中找连续字串 各字符个数和s1中相等\n每个index开始的子串与s1的hashmap进行比较 当对应kv相等时满足条件 (key:字符， value：字符个数)\n由于是连续字串 考虑滑动窗口即可(小优化) 只用改变对应的hashmap\n时间复杂度O(n + nL + m) L表示hashmap的entry数（L&lt;&#x3D;26) m表示s1的长度\n注意由于上述key是字符，也可以用数组充当hashmap\n差分优化 对应的值相减 用diff来统计不同的字符的个数（注意即使一个字符数量差大于1 diff也只算一次） 这样每次就不用重新比较一遍\n同理可以利用双指针：找到一个区间 长为n 并且使cnt &#x3D;&#x3D; 0 (cnt2 -cnt1 &#x3D; cnt) 维持cnt &lt;&#x3D;0 一旦长为n 则所有cnt &#x3D;&#x3D; 0\n15. 变位词出现的index和上一题基本相同 上一题是判断有无 这一题是算出有哪些 用p在s里面滑动\n优化：差分优化hashmap&#x2F;array的比较\n时间复杂度O(n)\n上面两题对hashmap的比较提出了一种利用差分构造的优化\n16. 不含重复字符的字串双指针 都从左端起始， 用hashset记录， 一旦有重复的， left不断向右靠 (注意还需要满足left &lt;&#x3D; right)\n17. 含有所有字符的最短字符串变位词变种 需要注意的是现在是包含而不是相等关系 双指针破题即可 注意cnt中只用记录在变位字符串中出现的字符\nleft和right指针从左开始 right先右移 满足条件之后left右移缩小\n对于出去的x和进入的y 只关心xy是否在t中出现过\n优化：diff优化 考虑对应个数和0的关系 （常规hashmap比较优化） 注意diff的定义是：不一致的字符种类\n18.回文串先过滤 然后数\n优化空间复杂度：\n双指针在原string上操作\n19.允许删除1个字符的回文串双指针直接判断即可 允许一次对不上 但究竟是移动左边还是右边？ 都试一下就好了 \n时间复杂度O(n)\n20.回文子串的个数暴力法 O(n^3) 确定start end；检查是否符合回文串\ntips：如果一个字串已经是回文串，该如何扩展？ 只需观察两边的字符即可\n定中心法 但是需要考虑奇数偶数 奇数单中心 偶数双中心 从左到右一次遍历 复杂度O(n^2)\n但是分奇数偶数两种情况很麻烦\n可以进行统一 观察发现对于n \n奇数：n个中心位置\n偶数：将两个点绑起来看 n - 1个位置\n共有2n - 1个情况 只用遍历2n-1次即可 写个表找规律 得出:\n中心右边 ri &#x3D; i &#x2F; 2 + i mod 2\n中心左边li &#x3D; i &#x2F;2\n不断向右扩展并记数即可\nmanacher算法：在O(n)时间复杂度里面求最长的回文子串\nhttps://www.bilibili.com/video/BV1Ks4y1t7c6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a9063a720abf17fbbf6c9b9f77914e66\n现在已经知道了每个回文中心的回文半径-&gt;每个回文中心的回文串长度-&gt;每个回文中心的回文串个数 \n累加求和即可\n有人提到R和i的追逐 确实很形象 如果R  &lt; i就和没优化前纯暴力的情况一样 如果R &gt;&#x3D; i 则会有优化\nKMP顺便学下另一个经典字符串匹配算法 KMP 时间复杂度O(n+m) m表示模式串的长度\n如果暴力匹配需要O(mn)的时间复杂度 可以发现每次在主串的i指针都需要向前移 有没有办法保证i不前移呢？这说明之前不前移的部分都不满足\n注意目前匹配到第几个字符完全取决于模式串上的j指针\n注意如果i指针不迁移 说明i之前有前缀 考虑之前的位置 这块是后缀 发现是公共前后缀\n如果限制为最长的公共前后缀 那么说明这次激进的滑动不会漏掉答案\n但是具体滑多远呢？ 或者说j变成多少呢？\n用next数组记录前一个位置的最长前后缀长度即可 这个数就是j需要去的位置j  &#x3D; next[j - 1]\n计算next数组i用来遍历next数组, j用来指向模式串（刚好也是最长前后缀的长度）\n如果相等 j++\nnext[i] &#x3D; j\n如果不等，由于已经累计了一部分公共前后缀，可以利用（动态规划）\nj &#x3D; next[j - 1] \nclass Solution &#123;\npublic:\n    int strStr(string haystack, string needle) &#123;\n        //KMP算法\n        //首先计算next\n        int n = haystack.length(), m = needle.length();\n        //注意这里不能直接初始化 cpp编译不过\n        int next[m];\n        for (int i = 0; i &lt; m; ++i) &#123;\n            next[i] = 0;\n        &#125;\n        int j = 0;\n        for (int i = 1; i &lt; m; ++i) &#123;\n            //动态规划找前缀\n            if (j > 0 &amp;&amp; needle[i] != needle[j]) &#123;\n                j = next[j - 1];\n            &#125;\n            //j实际上也等于前缀长度\n            if (needle[i] == needle[j]) &#123;\n                j++;\n            &#125;\n            next[i] = j;\n        &#125;\n        //开始匹配\n        int i = 0;\n        j = 0;\n        while (i &lt; n) &#123;\n            if (haystack[i] == needle[j]) &#123;\n                i++;\n                j++;\n            &#125; else if (j > 0) &#123;\n                //如果不等 j要去哪？ 由next数组告知 实际上next中寸的就是当前位置（包括）的最长前后缀\n                j = next[j - 1];\n            &#125; else &#123;\n                //j == 0说明退不了了 只能i进到下一个\n                i++;\n            &#125;\n            //只有j++的时候有用\n            if (j == m) &#123;\n                return i - j;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;;\n\n21.删除链表倒数第n个注意具体操作的时候在头上加一个根节点可以避免讨论 简称哨兵节点 O(n)\n前后两个指针相隔n个，后面的指针为空的时候，前面的指针就是倒数第n个\nO(n)\n22.链表环的入口hashset记录即可  遇到重复的节点就是入口节点 否则无环\n空间复杂度:O(n) \n快慢指针发现当在C点相遇时，y &#x3D;&#x3D; L，此时A点重新出发一个慢指针即可与C点的慢指针相遇在B\n\n23.双链表的交点set法 一个分支先走完 记下所有节点；第二个分支开始走 遇到相同节点就是交点\n时间空间复杂度都是O(max(m,n))\n两个节点分别从各自分支出发，走完了之后就从对方的分支再次出发\n如果有重合节点 两个指针会在交点相遇\n如果不相交 则会同时为null 两个分支都走完一遍\n\n双指针法时间复杂度O(m+n) 空间复杂度O(1) \n24.反转链表递归法： 每次拆一个节点 然后接起来\n时间空间复杂度O(n)\n迭代法：可以使用pre post存前后节点 然后迭代反转\n时间复杂度O(n) 空间复杂度O(1)\n25.链表两数相加（需要反转型）压栈 每次弹栈（本质上还是 用了list）\n反转之后硬做 加完后再反转回来 时间复杂度常数巨高 ！\n26.重排链表主要恶心在后半部分链表是倒着来的\n数组取巧法\n1.寻找链表中间节点 然后拆开\n2.反转链表\n3.合并链表\n快慢指针 拆分然后合并 注意如果是奇数节点一定要将中间的节点归在前面\n27.回文链表数组取巧法 时间空间复杂度为O(n)\n和26类似\n第3步是顺序比较\n先正向统计val 顺便反转 然后再重新统计一遍 时间复杂度为O(n)（但是C很大 超时了） 空间复杂度为O(n) ：存各个val的值\n28.多级双向列表扁平化注意题目意思是递归题 DFS即可\n注意：\n\n两处节点的连接处理\n节点是null的情况\n\n29.排序的循环链表注意None情况 跑一遍 维护int记录大小 注意非递减 时间O(n) 空间O(1)\n循环一遍注意找到$v_1 \\le p \\le v_2$的位置插入即可\n注意：\n\n空链表\np大于所有v的情况 则 $v_1 \\le p,p \\ge v_2$\n\n30.插入 删除 随机访问都是O(1)的容器插入删除通过hashset可以实现O(1)\n但是随机访问不行\n考虑使用list，通过随机index实现随机访问\n因此 hashmap中寸(v,index) \n注意删除的时候 为了实现O(1)\n在list中操作时 要pop list末端的v，并用v覆盖删除的元素\n31.LRU容器的构造hashmap (key, node)\n双向链表\nget和put的时候注意把node更新到队首\n根据hashmap看容量 如果超了就从末尾开始pop\n32.变位词的判断遍历一遍 在比较的同时 统计map 最后再比较map 时间复杂度O(n) 注意变位词的定义 需要至少有一个字符不一样\n如果要求不能有额外的空间复杂度，可以将源字符串按字典序排序 然后一一比较 时间复杂度O(nlogn) 注意排序前就要先比较一下是否相等\n33.变位词分组核心问题就是一眼判断出两个不同的词是否为变位词 （迭代map比较麻烦）：\n\n用字符拼接次数 e.g., apple -&gt; a1e1l1p2 作为token\n对词进行排序作为token\n\n最后收集到map里\n34.外星语言1.任意两个字符需要在O(1)时间复杂度下比较出大小\n​\t先把order搞成hash表 或者使用array；统一比较value,时间： $$O(|\\Sigma|)$$\n2.验证是否有序 $$O(nL),L为最长单词字符个数$$\n 注意验证的时间复杂度($$O(n)$$)$$\\le$$求解($$O(nlogn)$$)\n 注意空集的优先级 比首字母还小\n35.最小时间差不排序：O(n^2)\n先排序O(nlogn) 然后O(n)遍历 计算最小的diff  注意最后一项要和首项比较\n鸽巢原理 优化：注意到只有1440个时间点 如果长度超过则必然有两个相同的时间 所以返回0 \n代码优化：将首元素再加到末尾 可以避免冗余代码 （一个循环搞定）\n36.逆波兰表达式很简单的stack题 就是要注意是保留整数部分\n每次遇到符号 弹出两个数字\n37.小行星相撞从左向右将元素加入栈中，实际上每次只用处理栈顶的两个元素：\n\n如果反向则不处理\n如果对撞 则都先pop 然后append剩下的\n\n最多相撞O(n)次 循环O(n)时间复杂度是O(n)\n38.上升温度就是找当天之后最短距离几天温度会上升 观察发现用单调栈解决即可：\n单调递减栈\n每次拿到新的温度 如果更大那么就可以将栈顶弹掉 保持单调栈；小于等于就入栈 \n注意输出的时候需要找到对应的index 所以index和value要打包入栈\nturple （for Python）\nint[] (for java)\n观察可知 index之差就是对应要求的天数\n单调栈的题目 先确定是上升还是下降 什么情况下开始弹栈\n39.最大的矩阵面积暴力法：\n\n枚举中心，固定高，两边扩 O(n^2)\n\n固定两边 取最短的高 O(n^2)\n针对第二种方法 优化，优化选取最左最右边的过程\n使用单调栈可以快速定位到对应最远的index\n单调栈可以在$$O(N)$$的时间复杂度里求出里每一个元素最远的元素 (如果用list纯遍历就需要$$O(N^2)$$)\n利用单调栈求出最左和最右list\n最后遍历一遍 得到答案\n\n\n注意可以优化常数：\n不用求右边界，当一个index被弹出时，一定是遇到了第一个比它矮的index了，这就是它的右边界，也就是说弹出的时候计算面积就行了；入栈的时候有左边界\n时空O(n)\n40.矩阵中最大的矩形将二维转化成一维，按行看：\n以该行为基础统计该行以上的总数，转化成柱形求最大面积的问题\n时间复杂度$$O(mn)$$ 空间$$O(mn)$$\n41.滑动窗口平均值1.用队列 size维护好\n2.将求和的值维护好\n时间O(1) 空间O(n)\n42.最近请求次数队列\n\n每次无脑入队\nwhile 不符合条件出队\n\n43.二叉树添加节点两个队列处理，分别存放l-1, l层的节点：本质上就是层序遍历\n\n插入l层节点的时候 父节点为l -1\n挂满了就pop 直到为空\n更新两个layer队列\n\n注意返回的是val 不是node\n44.二叉树每层的最大值层序遍历 双队列解决 （bfs）\ndfs：二叉树层数就是ans的个数 用depth记录深度 当来到该深度时就对ans[depth]更新最大值\n二叉树先中后序遍历 取决于想知道的信息\n前中后序遍历递归很简单 可能考迭代\n注意使用stack前中 基本一样 遇到新节点就入栈 优先左边 区别在于访问的时间 前序在入栈前访问 中在出栈时访问 入栈是为了访问该节点的的右节点\n注意后续遍历弹栈弹根的时候有两种情况，prev记录上一个节点即可 1.右子树有但还没遍历（prev是当前节点的左子节点） 2.右子树没有或者已经遍历了 （prev不是当前节点的左子节点）\n45.最左最深的节点的val\n层序 bfs\n\ndfs 每层最先遇到的就是最左的\n\n\n46. 二叉树的右侧视图和上一题一样 只是换成了右侧\n时空复杂度$$O(n)$$\n47.二叉树剪枝后序遍历 不断拿走val&#x3D;&#x3D;0的叶节点\n48.序列化和反序列化题目序列化的意思是要转化成字符串\n\n层序遍历 + 空节点\nDFS + 空节点\n前中 （不含空节点）\n后中 （不含空节点）\n\n一个deque处理BFS ans放答案\n时空复杂度都是O(n)\n注意bfs dfs时空复杂度都是O(n)\n49.根节点到叶节点的和\nDFS\nBFS\n\n时空复杂度都是O(n)\n注意规定好累加值的求法！ 规定扔下去的累加值已经 乘10了 如果还需要进下一层需要自己再乘10  \n50.向下的路径节点之和DFS即可 一路求和；以每个顶点为起点开始递归 \n时间复杂度$$O(N^2)$$\n因为规定了路径只能向下，考虑使用前缀和\n答案只会与已经经过的路径上的点相关 求前缀和做差&#x3D;&#x3D;target_sum即可\ndfs: \n\n进入的时候的处理，ret是否++\n处理左右子树\n左右子树处理完毕 出去的时候注意抹去（右子树和左子树的节点不能有关系）\n\n51.节点之和最大的路径DFS，返回包括该节点的最大值，处理当前节点的时候可以跨越中间节点，注意DFS过程中记录整棵树的最大结果\n返回的时候不能跨越中间节点\n52.展平二叉树\n中序遍历之后 存在list中 然后重新组合 空间复杂度$$O(N)$$\n不用额外的list 中序遍历实际上就是node的顺序 注意在递归的规程中连接prev和cur节点\n\n思路一样老de不出来 关键需要讨论左孩子位考虑使用dummy（简单多了！保证了prev永不为null）\n中序遍历存列表 时空O(n)\n不用链表 但是有递归 空间复杂度也是O(n)\n53.二叉搜索树中序后继\n中序遍历 遇到给定p flag 亮 然后返回下一个节点\n注意是 二叉搜索树\n先查p的右子树 找最左侧的 \n如果没有右子树 从根节点找 如果cur.val &gt; p.val 就找最左侧的；反之 向右走\n\n\n\n如果当前cur.val &gt; p 就向左子树找 并且将res 指向当前节点 反之 向右子树找\n54.二叉搜索树中大于等于某节点的所有节点值之和二叉搜索树中序遍历得到的结果是升序序列\n二叉搜索树反序中序遍历得到降序序列，反序遍历求和即可满足题目要求\n时空复杂度都是O(n)\n优化空间复杂度至O(1) Morris遍历：\n本质上是把回到根节点的的指针存在了叶节点的空右指针里，而不是栈里\n\n如果左子数为空 cur &#x3D; cur.right\n否则，找到最右节点mostright:\n如果mostright.right &#x3D;&#x3D; null , mostright.right&#x3D;cur,cur &#x3D; cur.left\n如果mostright.right &#x3D;&#x3D; cur ，mostright.right &#x3D; null, cur &#x3D; cur.right\n\n\n\n55.树迭代器（中序）\n中序遍历的结果存在list中\n迭代stack实现中序遍历\n\n每次next就是内部的while不断压栈然后pop的框架\nwhile (node != null || !stack.isEmpty()) &#123; --> hasNext函数\n    while (node != null) &#123; --> next 函数\n        push;\n    &#125;\n    node = pop;\n    node = node.right();\n&#125;\n\nnext均摊时间复杂度为O(1) hasNext为O(1)\n56.二叉搜索树两数之和\n对每个节点 搜索剩下的target - val 时间复杂度$$O(N^2)$$\n中序遍历 构建list 转化成两数之和\n中序遍历 维护map\n\n57.值和index差小于limitation\n根据index确认大小为k + 1的窗口，再找出符合 $$x - t \\le y \\le x + t $$的y，用TreeSet ceilling找到y即可\n还是根据index确认窗口 利用桶思想 桶大小为$$t+ 1$$\n\n利用TreeSet 本质红黑树 动态维护min(n,k)空间大小的红黑树\n插入删除查找的时间复杂度都是logc c为容量\n一次遍历 总时间复杂度O(nlogk)\n桶 划分n个桶（区间） 注意桶大小应该是最大差+ 1 注意正负数的处理 正数直接用x &#x2F; w w为桶大小 负数为 (x - 1) &#x2F;w - 1\n例如t &#x3D; 9; 则 0 ~ 9 是一组，10 ~19是一组，所以x &gt;&#x3D; 0 时 id &#x3D; x &#x2F; 10\n-10 ~ -1，-20~-11是一组,id &#x3D; (x + 1) &#x2F; 10  -1;\n每遇到一个数标记对应区间 再次遇到就说明满足条件 没再次遇到就检查左右两个桶 如果有一个被标记也满足条件\n空间复杂度也是O(c) c为容量\n时间复杂度为O(n)\n小心类型转换 按照顺序来 看每一步有无隐式转换\n58.日程表$$[l_1,r_1),[s,e),[l_2,r_2)$$\n$$r_1\\le s &lt; e\\le l_2$$\n用TreeMap 包含KV的红黑树(与TreeSet的关系类似于HashMap 和 HashSet), start作Key，end作value，找到左右相邻的区间\n单次时间复杂度O(logn) 空间复杂度O(n)\n59.返回第K大的数用小顶堆，堆大小为K，堆顶的元素就是答案\n优先队列解决\n60.频率最高的topK注意此题不会一直更新\n先统计HashMap 然后 堆排序复杂度O(nlogk) 空间O(n)\n堆里面怎么放Entry：用int[] {1,2,3} 进行模拟!\n注意排序的实现方式java:PriorityQueue\n时间复杂度$$O(nlogK)$$\n61.和最小的K个数对注意两个数组有序\n二叉堆 暴力做法 时间复杂度O(k^2logk) 堆容量为k 两个数组都只用管前K个\n 如果(0,0)是最小的index对 那么(1,0) 或(0,1)一定是倒数第二小的 以此类推 可以利用 类似bfs的方式不断搜索 每轮poll一次 这个一定是该轮最小的 k轮结束 每轮不断扩散 本质是贪心\n可能有重复 有两种去重方式：\n1.hashset做标记$$(index1, index2)$$ pair –&gt;这种方法比较好理解\n2.规定加入顺序 先把$$(index1, 0)$$全部加入，之后每次只在index2的地方++\n时间复杂度O(klogk) 空间复杂度$$O(k)$$\n注意由于规定了heap排序方式需要使用nums1 nums2 offer之前需要考虑index是否越界\n只要涉及到给prefix 求出具体的相关单词的就需要用前缀树\n否则可以考虑hash 暴力\n62.前缀树字典树 26个字母节点 字母节点可以用数组存\n为了区分前缀app 单词app 单词apple 单词用isEnd对末节点进行标记\n时间复杂度 O(S) S为当次操作字符串长度\n空间复杂度$$O(|T|)$$ T为所有字符串的长度和 \n63.替换单词用前缀树 先建树 注意设置isEnd \n遇到isEnd就替换 没遇到节点就结束 不替换\n注意用StringBuilder 不要自己去拼接 可以快3倍\n相比于使用hash可以提前结束，使用hash必须全部遍历\n64.神奇字典\n暴力存字符串 $$O(qnl)$$,每次用当前带查询的串和n个比较\n字典树 $$O(nl + ql|\\Sigma|)$$\n\ndfs(node,pos,modified)\n！modified：所有的子节点都可以走\nmodified：只能走相同的子节点\n最终的结束条件是pos为length,modified为true,isEnd\n否则为false\n65.最短单词编码观察题目可知 就是要把单词合并 合并的规则是：如果单词A是单词B的后缀，那么A可以被删除\n\nhashset 将原字符串存起来，然后看每个word的后缀，如果hashset中有某个后缀，表示hashset中的该word可以去掉 时间复杂度$$O(\\Sigma w_i)$$ 空间复杂度$$O(n)$$\n字典树 反序建立字典树 找字典树中最长的单词 时间复杂度$$O(\\Sigma w_i)$$ 空间复杂度 $$O(S \\times \\Sigma w_i)$$\n\n66.根据前缀返回相关单词和\n暴力 每个单词比较前缀 然后value求和  每次sum时间复杂度$$O(nl)$$ insert$$O(1)$$\n字典树 每个节点存value总和 insert的时候注意更新value$$O(l)$$ search的时候直接返回节点value 时间复杂度$$O(l)$$\n\n综上所述 字典树解决了遍历n个words的时候相同前缀反复遍历的问题\ne.g., app apple append， 如果不用字典树app这三个会反复进行遍历\n67.最大异或$$x &#x3D; a_i\\space xor \\space a_j, a_i &#x3D; x\\space xor \\space a_j$$\n要求x的最大值 将x的高位到低位不断试1即可\n\n将$$a_0, … a_{i-1}$$构造成字典树，$$a_i$$测试x全1，看字典树中是否能走，记下能走通的最大x 贪心遍历$$a_i$$ 时空$$O(nlogC)$$\n不断考虑x的高位到低位 如果高位可以为1，答案中该位一定为1\n关于判断是否可以为1，将所有num右移后加入set，然后x xor 每个num 再检查是否可以\n注意不需要关注是否为同一个$$a_i, a_j$$！ 比如1可以那下一位如果1也可以就是11，如果不行就是10，怎么都是1开头的，不可能是0开头的（比如01） 空间$$O(n)$$ 时间$$O(nlogC)$$\n\n\n\n68.查找插入位置二分查找：\n如果一开始不知道问题的解是什么，但是知道解的范围是多少，则\t可以尝试在这个范围内应用二分查找；应用这种思路的关键在于两点：\n\n确定解的范围，即解的可能的最小值和最大值；\n在发现中间值不是解之后如何判断接下来应该在解的范围的前半部分还是后半部分查找。只有每次将查找范围减少一半时才能应用二分查找算法\n\n边界有点恶心 注意区分区间定义情况[a,b) 注意if\n迭代法实现如下，递归法类似：\n总的来说就是找到答案先别急返回两种收缩：\n\n收缩上界\n收缩下界\n\ne.g., 3,3,3 插入3 index是0，是3，还是2\n&#x2F;&#x2F;[a,b)闭区间法 官方推荐\n&#x2F;&#x2F;收缩上界 lowerbound 找target该插入的头部位置 （最左侧）\nclass Solution &#123;\n    public int searchInsert(int[] nums, int target) &#123;\n        &#x2F;&#x2F;迭代法 [a,b) &amp;&amp; 收缩上界\n        int left &#x3D; 0;\n        int right &#x3D; nums.length;\n        while (left &lt; right) &#123;\n            int mid &#x3D; left + ((right - left) &gt;&gt; 1);\n            &#x2F;&#x2F;等于的时候不要着急返回！ 将上界向下收缩\n            if (nums[mid] &gt;&#x3D; target) &#123;\n                right &#x3D; mid;\n            &#125; else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;\n&#x2F;&#x2F;收缩下界\n&#x2F;&#x2F;1找第一个大于target的index （末尾的下一个最右侧）\nclass Solution &#123;\n    public int searchInsert(int[] nums, int target) &#123;\n        &#x2F;&#x2F;迭代法 [a,b) &amp;&amp; 收缩下界\n        int left &#x3D; 0;\n        int right &#x3D; nums.length;\n        while (left &lt; right) &#123;\n            int mid &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] &gt; target) &#123;\n                right &#x3D; mid;\n            &#125; else &#123;\n                &#x2F;&#x2F;等于的时候不要反回！ 将下界向上收缩\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;\n&#x2F;&#x2F;2找target该插入的末尾位置\nclass Solution &#123;\n    public int searchInsert(int[] nums, int target) &#123;\n        &#x2F;&#x2F;迭代法 [a,b) &amp;&amp; 收缩下界\n        int left &#x3D; 0;\n        int right &#x3D; nums.length;\n        while (left &lt; right) &#123;\n            int mid &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] &gt; target) &#123;\n                right &#x3D; mid;\n            &#125; else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left - 1;\n    &#125;\n&#125;\n\n69.山峰数组二分查找：如果位于上坡l右移，下坡r左移 时间复杂度O(logn)\n当然O(n)遍历一遍也可\n70.排序数组只出现一次的数字已经有序！ 需要使用二分查找满足时间复杂度O(logn)\n$$a_0,a_0,a_1,a_1,a_2,a_3,a_3,a_4,a_4$$\n$$0,1,2,3,4,5,6,7,8$$\ntarget:$$a_2$$左边，如果index是偶数则$$a_i &#x3D;&#x3D; a_{i+1}$$;如果是奇数$$a_i &#x3D;&#x3D; a_{i-1}$$ 否则就是在target右侧\n因此就可以二分了\ntrick:偶数和1异或为偶数+1 奇数和1异或为奇数-1\n以上判断可以合并为$$a_i&#x3D;&#x3D;a_i \\space xor \\space 1$$\n71.加权随机index看到随机数 联想到几何分布 由于和权重有关 考虑数轴\ne.g.,: [1,3,4,5] -&gt; [1,4,8,13] 写成前缀和\n某次randint为5 对应的index为2 如果和临界值相等 取临界值的index -&gt; 收缩上界 二分查找并返回对应的index即可\n初始化O(n) 二分时间复杂度O(logn)\n空间O(n) 如果可以修改原数组为O(1)\n72.求平方根直观思路是遍历$$1,2,3,…sqrt(n)$$  时间复杂度$$O(\\sqrt{n})$$\n在1~n范围内进行二分查找$$O(logn)$$\n看复杂度是sqrt(n)?和二分查找有关？\n小心溢出 \n73.狒狒吃香蕉关键是确定k的最小值，k的范围在$$1, max(piles)$$之间 给定了范围 查找值，可用二分查找\n确定$max(piles)$的时间复杂度$O(n)$ 二分查找的时间复杂度为$O(logm)$,每次移动左右界需要$O(n)$时间复杂度\n74.合并区间按照start排序，如果$a_i[1] &gt; a_{i+1}[0]$则可以合并，更新末端端点为$max(a_i[1],a_{i+1}[1])$\n然后利用栈，遍历合并  \n排序时间复杂度$O(nlogn)$ 合并的时间复杂度$O(n)$\n75.数组相对排序arr2中元素各不相同，遍历arr1，用hashmap记录arr2中出现的元素个数，同时对未在arr2中出现的元素进行插入排序\n最终利用hashmap将arr2扩展后的数组拼在头上\n$arr1.length &#x3D; m,arr2.length&#x3D;n$\n时间复杂度$O(m+(m-n)log(m-n)+n)$\n注意上述方法其实已经提示了可以用计数排序了\n剩下在arr2中没出现的元素也一并计数，之后按照次数拼接在末尾即可\n时间复杂度$O(m+upper+n)，upper表示最大的元素的值$ \n实际上以上过程可以统一到排序中，hashmap记录(k,v) &#x3D; (val,index)\n都出现在hashmap中，比较index；都不在map中，正常比较；否则，在hashmap中的元素较小\n时间复杂度$O(mlogm+n)$ 空间复杂度$O(logm + n)$\n76.数组中第K大的数字TopK问题 堆排序即可\n堆的容量为K，小顶堆，堆排序\n时间复杂度$O(nlogk)$\n堆排序即可\n快速选择,快排启发：\n快排对当前数组排完后$a_0,a_1,…,a_i,,…,a_n$\n$a_i$前面的元素都小于$a_i$，后面的元素都大于$a_i$,根据数量即可确定下一轮递归在左半部分还是右半部分\n$T(n)&#x3D;T(n&#x2F;2) + O(n)$  时间复杂度为O(n),空间复杂度O(logn)，递归O(logn)层\n77.单链表排序逃课就存节点 快排\n在链表上操作的话可以用冒泡、堆排序（有点类似把节点存下来了）\n感觉选择排序 快排都不好在链表上操作\n时间复杂度O(nlogn) 空间复杂度O(n)\n归并排序O(nlogn) 空间复杂度O(logn)\n时间复杂度要求O(nlogn) 空间复杂度O(1)\n针对归并排序优化递归层数，自底向上操作，比较复杂，通过subLength控制每次合并的节点数量\n78.合并有序链表遍历两条链表即可 时间复杂度O(n)\n合成新的链表比较简单 为O(n)\n否则就是在远链表上改，比较麻烦 但为O(1)\n79.所有子集取或者不取 时间复杂度O(2^n)\n回溯模板解即可\n可以剪枝优化\n可以记忆化搜索\n80.求组合数$$C_n^k$$型，对每一位进行遍历，注意记录已选数字个数\n回溯\n可以进行剪枝（如果所有数字都选了还是不能到k个这种情况）\n允许重复选择元素用DFS回溯 暴力遍历\n去重？\n不允许重复选择元素注意idx的处理\n数组元素全排列(含重复元素&#x2F;不含重复元素)不含重复元素：注意flag做标记 注意每次进入dfs都是顺序选取元素如果被flag标记 就找下一个 直到找满\n含重复元素：set去重 效率很低（还要内部排序）\n对元素集合进行排序，相同元素会聚集在一起，对于这些相同元素每次保证如果前面的没选取 后面的就不选取 （如果选取会重复）即可去重\n生成匹配的括号按照左右括号的数量回溯 想不到…\nleft &lt; n,right &lt; left\n分割回文子串用一个函数判字符串是否为回文串 可以做记忆化搜索\n固定头部 移动尾部进行回溯即可 （答案不用去重）\n按条件分割字符串按index分割 注意剪枝\nTopK问题1.大小为K的堆\n2.快速选择法 注意pivot的选取需要随机 每次选一个后和最后的那个元素交换 然后按照正常的partition做\n三、Top1001.两数之和暴力n^2 \n排序 二分查找 nlogn 但是index已经变了 不是很好搞\nhash表 O(n) S(n)\n2.链表求和开个新链表 以最长的为基准 求和进位即可\n3.无重复最长子串双指针+HashSet O(n) S(n)\n用滑动窗口 ：本质实在优化index的枚举 本来是n^2 -&gt; n\n注意可能进入不了else while循环外面要套一次更新\n4.两个正序数组中位数暴力合并O(m+n)\n中位数为 m+n+1 &#x2F;2  m+n+2&#x2F;2 对应的数的平均数\n设为K\n在两个数组里寻找第K个数 分别看第K&#x2F;2个 如果num1小于num2说明 第K个绝对不可能在num1的K&#x2F;2个里 可以删除 不断折半K 最终K为1的时候比较首元素即可 某个数组已经被剔完了 直接找另一个数组的第K个即可(为了统一 优雅可以直接另被剔完的数组对应的元素为无穷大)\n5.回文串动态规划\ndp[i,j] 记录的是能不能成为回文串 不能记录最大长度\n因为如果记录最大长度的话不能确定是否是子串（相邻）\n6.Z串直接模拟 注意不要越界 while秒\n7.整数反转用最大的MAX_VALUE的1&#x2F;10进行判断 (Integer.MAX_VALUE:2147483647)\n感觉只能暂存 然后特判\n51.52.N皇后bitmap状态压缩空间复杂度不过还是O(n）因为要递归\n105.106.二叉树重构已知前中 后中都能唯一确定二叉树\n但是已知前后不能 因为最后叶节点的时候不能确定到底是左孩子还是右孩子\n两种不同的关键是当作左子树还是右子树找根\n由于不会有重复元素 可以用hashmap加速\n注意：\n三种题都可以每次取一个元素 (L &lt; R) 终止条件L &#x3D;&#x3D; R \n如果相等说明没有子树节点了 该节点就是根节点 直接返回就好\n注意下标的变化\n四、Leetcode75205. 同构字符串Hashmap遍历 O(n) O(l) l:字符集的大小\n290. 单词规律与205完全相同 需要用空格分割t\n290. 单词规律II缺少了空格分隔 暴力\n暴力回溯 （自己划分空格） 1h\n很恶心:\n1.结束条件 必须同时结束 p 和 s\n2.注意区分两个map if else写详细 p-&gt;s是强制的 s-&gt;p s是可变的\n392. 判断子序列1.两个指针 O(n+m)  如果有k个就是O(k(n+m))\n2.DP 优化为O(kn + m) 空间O(m)\n21. 合并两个有序链表1.正常拼接就好 3个while 都要注意p的移动O(m+n)\n2.注意立哨兵 注意判断开始的情况\n206. 反转链表迭代：\n1.注意while条件cur !&#x3D; null 说明之后还有一个 进while再next\n递归：\n1.注意每次拆分一个节点 递归解法会天然用栈储存\n2.注意解环\n3.返回值就是最终答案\n876. 链表的中间结点快慢指针：这个题就不要用dummy 因为对于偶数点要靠后的Node\n142. 环形链表 II快慢指针：如果有环就在里面转 总能遇到\n求出入口节点:有个很巧的公式 注意环的性质\n121. 买卖股票的最佳时机注意记录遍历过的数中最大的实际上就是动态规划 \n实际上不用动态规划 时间复杂度O(n) 空间O(1)\n409. 最长回文串遍历 收集 再来一个最大的基数 O(n) O(L)\n注意字符可以不用完\n用数组可以加速\n589. N 叉树的前序遍历感觉iter做法比较麻烦 每个node都要打标记 (用hashmap帮忙打标记)\n注意弹出的时候要抹掉所有children的标记\n或者倒序入栈\nrecur有context帮忙打标记\n常用算法二分查找1.注意规定[l,r) 考虑每次lr的能否取到端点\n2.如果存在相同的值注意收缩上界\npublic class BinarySearch &#123;\n    //迭代递归的时间复杂度都是O(logn)\n    //递归的空间复杂度为O(logn) 迭代为O(1)\n    public static void main(String[] args) &#123;\n        int[] array = new int[]&#123;1, 2, 3, 4, 5, 5, 6&#125;;\n        class Search &#123;\n            //[l,r)\n            public int searchIndexIter(int[] array, int l, int r, int tar) &#123;\n                int mid;\n                while (l &lt; r) &#123;\n                    mid = l + ((r - l) >> 1);\n                    if (array[mid] >= tar) &#123;\n                        r = mid;\n                    &#125; else &#123;\n                        // arrya[mid] &lt; tar\n                        //at least mid + 1\n                        l = mid + 1;\n                    &#125;\n                &#125;\n                return l;\n            &#125;\n\n            public int searchIndexRec(int[] array, int l, int r, int tar) &#123;\n                if (l >= r) &#123;\n                    return l;\n                &#125;\n                int mid = l + ((r - l) >> 1);\n                if (array[mid] >= tar) &#123;\n                    return searchIndexRec(array, l, mid, tar);\n                &#125; else &#123;\n                    return searchIndexRec(array,mid + 1,r,tar);\n                &#125;\n            &#125;\n        &#125;\n        Search search = new Search();\n        int ans = search.searchIndexIter(array,0,array.length,5);\n        System.out.println(ans);\n        ans = search.searchIndexRec(array, 0, array.length, 4);\n        System.out.println(ans);\n    &#125;\n&#125;\n\n八大排序冒泡排序1.两重循环\n2.冒泡次数 n\n3.交换次数 n - 1 - i\npublic class BubbleSort &#123;\n    public static void main(String[] args) &#123;\n        int[] array = new int[]&#123;1, 2, 2,4, 5,5,7,7 , 67,3&#125;;\n        class Sort &#123;\n            public void bubbleSort(int[] array) &#123;\n                for (int i = 0; i &lt; array.length; i++) &#123;\n                    boolean changed = false;\n                    for (int j = 0; j &lt; array.length - i - 1; j++) &#123;\n                        //千万注意这里j的条件\n                        if (array[j] > array[j + 1]) &#123;\n                            int tmp = array[j];\n                            array[j] = array[j + 1];\n                            array[j + 1] = tmp;\n                            changed = true;\n                        &#125;\n                    &#125;\n                    if (!changed) &#123;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        Sort s = new Sort();\n        s.bubbleSort(array);\n        for (int i = 0; i &lt; array.length; i++) &#123;\n            System.out.println(array[i]);\n        &#125;\n    &#125;\n&#125;\n\n选择排序1.两重循环\n2.选择次数 n\n3.比较次数 n - i\npublic class SelectionSort &#123;\n    public static void main(String[] args) &#123;\n        int[] nums = &#123;3,5,1,2,3,6,5&#125;;\n        chooseSort(nums);\n        for (int num:nums) &#123;\n            System.out.println(num);\n        &#125;\n    &#125;\n\n    public static void chooseSort(int[] nums) &#123;\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            int max = Integer.MIN_VALUE;\n            int maxIndex = -1;\n            for (int j = 0; j &lt; nums.length - i; j++) &#123;\n                if (nums[j] >= max) &#123;\n                    max = nums[j];\n                    maxIndex = j;\n                &#125;\n            &#125;\n            nums[maxIndex] = nums[nums.length - i - 1];\n            nums[nums.length - i - 1] = max;\n        &#125;\n    &#125;\n&#125;\n\n插入排序1.两重循环\n2.插入次数 n - 1\n3.前移注意break \npublic class InsertionSort &#123;\n    public static void main(String[] args) &#123;\n        int[] array = new int[]&#123;1, 2, 2,4, 5,5,7,7 , 67,3&#125;;\n        insertionSort(array);\n        for (int num : array) &#123;\n            System.out.println(num);\n        &#125;\n    &#125;\n\n    public static void insertionSort(int[] nums) &#123;\n        for (int i = 1; i &lt; nums.length; i++) &#123;\n            for (int j = i; j >= 0; j--) &#123;\n                if (nums[j] &lt; nums[j - 1]) &#123;\n                    //比前面的小 要往前挪\n                    int tmp = nums[j - 1];\n                    nums[j - 1] = nums[j];\n                    nums[j] = tmp;\n                &#125; else &#123;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n归并排序1.注意规定[l,r]\n2.先直接分割 然后再合并\npublic class MergeSort &#123;\n    public static void main(String[] args) &#123;\n        int[] nums = &#123;3,5,1,2,3,6,5&#125;;\n        mergerSort(nums,0, nums.length - 1);\n        for (int num:nums) &#123;\n            System.out.println(num);\n        &#125;\n    &#125;\n\n    public static void mergerSort(int[] nums, int i, int j) &#123;\n        if (i >= j) &#123;\n            return;\n        &#125;\n        int mid = i + ((j - i) >> 1);\n        mergerSort(nums, i, mid);\n        mergerSort(nums, mid + 1, j);\n        merge(nums, i, mid, j);\n    &#125;\n\n    public static void merge(int[] nums, int i, int mid, int j) &#123;\n        int[] tmp = nums.clone();\n        int p1 = i;\n        int p2 = mid + 1;\n        int k = i;\n        while (p1 &lt;= mid &amp;&amp; p2 &lt;= j) &#123;\n            if (tmp[p1] &lt; tmp[p2]) &#123;\n                nums[k++] = tmp[p1++];\n            &#125; else &#123;\n                nums[k++] = tmp[p2++];\n            &#125;\n        &#125;\n        while (p1 &lt;= mid) &#123;\n            nums[k++] = tmp[p1++];\n        &#125;\n        while (p2 &lt;= j) &#123;\n            nums[k++] = tmp[p2++];\n        &#125;\n    &#125;\n&#125;\n\n快速排序1.注意规定[l,r]\n2.双指针法:最后循环停的时候i &#x3D;&#x3D; j 填入pivot\n3.可以改成迭代 用stack辅助即可\n4.切割即可（注意切割过程中归类） 不用合\n深度是logn 空间复杂度是logn\npublic class QuickSort &#123;\n    public static void main(String[] args) &#123;\n        int[] array = new int[]&#123;1, 2, 2,4, 5,5,7,7 , 67,3&#125;;\n        class Sort &#123;\n            public int partition(int[] array,int l,int r) &#123;\n                int pivot = array[r];\n                int i = l;\n                int j = r;\n                while (i &lt; j) &#123;\n                    while (array[i] &lt; pivot) &#123;\n                        i++;\n                    &#125;\n                    array[j] = array[i];\n                    while (array[j] >= pivot) &#123;\n                        //千万注意这里要写等号不然两边没法靠拢\n                        j--;\n                    &#125;\n                    array[i] = array[j];\n                &#125;\n                array[i] = pivot;\n                return i;\n            &#125;\n\n            public void quickSortRec(int[] array,int l,int r) &#123;\n                if (l >= r) &#123;\n                    return;\n                &#125;\n                int mid = partition(array, l,r);\n                quickSortRec(array, l, mid - 1);\n                quickSortRec(array, mid + 1, r);\n            &#125;\n\n            public void quickSortIter(int[] array,int l,int r) &#123;\n                Stack&lt;int[]> stack = new Stack&lt;>();//用栈模拟 递归拆分\n                stack.push(new int[] &#123;l,r&#125;);\n                while (!stack.isEmpty()) &#123;\n                    int[] range = stack.pop();//[l,r]\n                    if (range[0] >= range[1]) &#123;\n                        continue;\n                    &#125; else &#123;\n                        int index = partition(array, range[0],range[1]);\n                        stack.push(new int[]&#123;range[0], index - 1&#125;);\n                        stack.push(new int[]&#123;index + 1, range[1]&#125;);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        Sort s = new Sort();\n//        s.quickSortRec(array,0,array.length - 1);\n//        for (int i = 0; i &lt; array.length; i++) &#123;\n//            System.out.println(array[i]);\n//        &#125;\n        s.quickSortIter(array,0,array.length - 1);\n        for (int i = 0; i &lt; array.length; i++) &#123;\n            System.out.println(array[i]);\n        &#125;\n    &#125;\n&#125;\n\n计数排序1.基于统计\n2.注意理解cnt的意义 包括本身前面还有多少个数\n3.注意倒序填写 因为每次填的是最后一个\npublic class CountingSort &#123;\n    public static void main(String[] args) &#123;\n        int[] array = new int[]&#123;1, 2, 2,4, 5,5,7,7 , 67,3&#125;;\n        array = countingSort(array);\n        for (int i = 0; i &lt; array.length; i++) &#123;\n            System.out.println(array[i]);\n        &#125;\n    &#125;\n\n    public static int[] countingSort(int[] nums) &#123;\n        //先找最大的数 决定count数组的大小\n        int k = Integer.MIN_VALUE;\n        for (int num : nums) &#123;\n            if (num > k) &#123;\n                k = num;\n            &#125;\n        &#125;\n        int[] count = new int[k];\n        for (int num : nums) &#123;\n            count[num - 1] += 1;\n        &#125;\n        for (int i = 1; i &lt; k; i++) &#123;\n            count[i] += count[i - 1];\n        &#125;\n        //注意这里的count包括本身 比如如果某个元素对应的count是4 那么表示前面有3个元素比4大\n        int[] ans = new int[nums.length];\n        for (int i = nums.length - 1; i >= 0; i--) &#123;\n            ans[count[nums[i] - 1] - 1] = nums[i];\n            count[nums[i] - 1] -= 1;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n希尔排序1.希尔增量 n, n&#x2F;2 … 1 希尔增量序列 增量是多少就可以分成多少组\n2.每组组内采用插入排序\n3.shell增量一层while 插入排序实现起始点一层for 终点一层while\npublic class ShellSort &#123;\n    public static void main(String[] args) &#123;\n        int[] array = &#123;3, 5, 1, 2, 3, 6, 5&#125;;\n        shellSort(array);\n        Arrays.stream(array).forEach(System.out::println);\n    &#125;\n\n    public static void shellSort(int[] array) &#123;\n        //shell 增量\n        //初始希尔增量取n / 2\n        int shell = array.length / 2;\n        while (shell > 0) &#123;\n            //插入排序实现\n            for (int i = shell; i &lt; array.length; i += shell) &#123;\n                for (int j = i; j > 0; j -= shell) &#123;\n                    if (array[j] &lt; array[j - shell]) &#123;\n                        int tmp = array[j - shell];\n                        array[j - shell] = array[j];\n                        array[j] = tmp;\n                    &#125; else &#123;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n            //更新shell 增量\n            shell /= 2;\n        &#125;\n    &#125;\n&#125;\n\n堆排序优先队列\n二叉树上浮下潜 \n限定容量即可实现topk\nJava一般用PriorityQueue实现\npublic class HeapSort &#123;\n    public static void main(String[] args) &#123;\n        int[] array = &#123;3, 5, 1, 2, 3, 6, 5&#125;;\n        array = heapSort(array);\n        Arrays.stream(array).forEach(System.out::println);\n    &#125;\n\n    static class Heap &#123;\n        //小顶堆 根节点&lt;=左右子节点的值\n        private List&lt;Integer> array = new ArrayList&lt;>();\n\n        public void insert(int element) &#123;\n            //放入末尾\n            array.add(element);\n            //不断上浮\n            int index = array.size() - 1;\n            while (index > 0) &#123;\n                int parentIndex = (index - 1) / 2;\n                if (array.get(parentIndex) > array.get(index)) &#123;\n                    //swap\n                    swap(parentIndex, index);\n                &#125;\n                index = parentIndex;\n            &#125;\n        &#125;\n\n        public void removeTop() &#123;\n            //交换首末\n            swap(0, array.size() - 1);\n            //移除\n            array.remove(array.size() - 1);\n            //不断下沉\n            int index = 0;\n            int left = index * 2 + 1;\n            int right = index * 2 + 2;\n            while (true) &#123;\n                //要么比左节点大 要么比右节点大 否则说明已经符合小顶堆要求\n                if (left &lt; array.size() &amp;&amp; array.get(index) > array.get(left)) &#123;\n                    swap(index, left);\n                    index = left;\n                &#125; else if (right &lt; array.size() &amp;&amp; array.get(index) > array.get(right)) &#123;\n                    swap(index, right);\n                    index = right;\n                &#125; else &#123;\n                    break;\n                &#125;\n                left = index * 2 + 1;\n                right = index * 2 + 2;\n            &#125;\n        &#125;\n\n        public int top() &#123;\n            if (array.size() > 0) &#123;\n                return array.get(0);\n            &#125; else &#123;\n                return -Integer.MIN_VALUE;\n            &#125;\n        &#125;\n\n        private void swap(int index1, int index2) &#123;\n            int tmp = array.get(index1);\n            array.set(index1, array.get(index2));\n            array.set(index2, tmp);\n        &#125;\n    &#125;\n\n    public static int[] heapSort(int[] array) &#123;\n        Heap heap = new Heap();\n        //建堆\n        for (int i = 0; i &lt; array.length; i++) &#123;\n            heap.insert(array[i]);\n        &#125;\n        int[] ans = new int[array.length];\n        for (int i = 0; i &lt; ans.length; i++) &#123;\n            ans[i] = heap.top();\n            heap.removeTop();\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n基数排序按照位数进行排序 本质是多轮排序\npublic class RadixSort &#123;\n    public static void main(String[] args) &#123;\n        int[] array = &#123;1, 2, 2,4, 5,5,7,7 , 67,3&#125;;\n        array = radixSort(array);\n        Arrays.stream(array).forEach(System.out::println);\n    &#125;\n\n    public static int[] radixSort(int[] array) &#123;\n        //初始化radix\n        List&lt;List&lt;Integer>> radix = new ArrayList&lt;>();\n        int k = 10;\n        for (int i = 0; i &lt; k; i++) &#123;\n            radix.add(new ArrayList&lt;>());\n        &#125;\n        //找到最大的位数\n        int max = Arrays.stream(array).reduce(Integer.MIN_VALUE, Integer::max);\n        //收集轮数\n        int t = String.valueOf(max).length();\n        int divisor = 1;\n        //int[] -> List\n        List&lt;Integer> ans = Arrays.stream(array).boxed().collect(Collectors.toList());\n        for (int i = 0; i &lt; t; i++) &#123;\n            divisor *= 10;\n            //投入\n            for (int j = 0; j &lt; ans.size(); j++) &#123;\n                radix.get(ans.get(j) % divisor).add(ans.get(j));\n            &#125;\n            //清空\n            ans = new ArrayList&lt;>();\n            //收集\n            for (int j = 0; j &lt; radix.size(); j++) &#123;\n                ans.addAll(radix.get(j));\n            &#125;\n            t--;\n        &#125;\n        //List -> int[]\n        return ans.stream().mapToInt(Integer::intValue).toArray();\n    &#125;\n&#125;\n\n\n\n桶排序1.使用映射将N个数分到K个有序桶中\n2.每个桶各自排序\n桶排序是一种思想 分桶之后，每个桶里的排序方法可以任选\npublic class BucketSort &#123;\n    public static void main(String[] args) &#123;\n        int[] array = &#123;3, 5, 1, 2, 3, 6, 5&#125;;\n        array = bucketSort(array);\n        Arrays.stream(array).forEach(System.out::println);\n    &#125;\n\n    public static int[] bucketSort(int[] array) &#123;\n        //桶序号2元素\n        HashMap&lt;Integer, List&lt;Integer>> buckets = new HashMap&lt;>();\n        //桶大小\n        int bucketSize = 10;\n        //入桶\n        for (int i = 0; i &lt; array.length; i++) &#123;\n            //桶序号\n            int index = 0;\n            //正负元素计算桶序号的方法不同\n            if (array[i] >= 0) &#123;\n                index = array[i] / bucketSize;\n            &#125; else &#123;\n                index = (array[i] + 1) / bucketSize - 1;\n            &#125;\n            if (buckets.containsKey(index)) &#123;\n                buckets.get(index).add(array[i]);\n            &#125; else &#123;\n                List&lt;Integer> bucket = new ArrayList&lt;>();\n                bucket.add(array[i]);\n                buckets.put(index, bucket);\n            &#125;\n        &#125;\n        //对每个桶排序\n        //为了保证桶的顺序\n        List&lt;Integer> keyOrder = new ArrayList&lt;>();\n        Iterator iterator = buckets.entrySet().iterator();\n        while (iterator.hasNext()) &#123;\n            Map.Entry&lt;Integer, List&lt;Integer>> entry = (Map.Entry&lt;Integer, List&lt;Integer>>) iterator.next();\n            keyOrder.add(entry.getKey());\n            //对bucket进行排序\n            entry.getValue().sort(Comparator.comparing(Integer::intValue));\n        &#125;\n        keyOrder.sort(Comparator.comparing(Integer::intValue));\n        List&lt;Integer> ans = new ArrayList&lt;>();\n        for (int i = 0; i &lt; keyOrder.size(); i++) &#123;\n            int key = keyOrder.get(i);\n            ans.addAll(buckets.get(key));\n        &#125;\n        return ans.stream().mapToInt(Integer::intValue).toArray();\n    &#125;\n&#125;\n\n复杂度表冒泡 插入最好的情况就是本身已经有序了 t\n\n上表部分有误 本人不太确定！\ntips:\n\n冒泡排序：通过flag看是否本身有序\n插入排序：注意插入的地方 稳定 最好就是本身有序 扫一遍即可\n希尔排序：增量选n &#x2F; 2 大概是$O(nlogn)$ 每次跳着排 不稳定\n归并排序：由于合并数组的时候新开了数组 所以空间复杂度O(n)\n快速排序：跳着排 不稳定\n堆排序：左右子节点交换的时候默认左边，不一定有序\n计数排序：需要扫原数组O(n)和计数数组O(k) 最终结果数组和技术数组总空间复杂度O(n+k)\n桶排序：桶排序实际上是分治的思想 平均时间复杂度$O(r\\times mglogm), m &#x3D; n &#x2F;r$ r是桶数 空间复杂度$O(nr)$ 并且与桶内排序算法的选择有关\n基数排序：k表示位数 两重循环 时间复杂度$O(n\\times k)$ 空间复杂度应该是$O(n\\times r)$ r为桶的个数\n\ndp自底向上！\n线性dp经常考虑末尾元素！！！\n单数组（一维）和最大的子串(MCSP)dp[i]定义为包含a[i]的最大子串和 空间复杂度可优化为O(1) 时间复杂度O(n)\n双数组（二维）最长公共子序列(LCS)dp[i,j]定义为两个字符串中index分别以i，j结尾的情况，分别考虑最后x_i y_j是否相等\n注意相等时其实有三种情况 但是dp[i-1,j-1] + 1可包括另外两种情况\n时间复杂度O(mn) mn为字符串长度\n最长公共子串（LCSP)相比MCSP要求连续\ndp[i,j]定义为以两字符串中分别以i，j结尾的字符串的最长公共子串的长度 如果不等肯定为0 等则可由dp[i-1,j-1] + 1转移\n复杂度O(mn)\n编辑距离考虑删除 插入 替换操作\ndp[i,j] 表示从s_i 转换为 t_j需要的次数\n满足条件的最长子序列dp[i] 包含第i个字符且满足条件的最长子序列\n注意答案可能不是最后一个 需要遍历一次找到最大值\n背包dp01背包问题dp[i,c]考虑前i个物品 使用c容量总共的价格 \ndp[i,c] &#x3D; max(dp[i-1,c] ,dp[i-1,c-v[i]] + p[i])\n只与上一行 以及前面的dp值有关 可以考虑优化空间复杂度 倒着遍历空间容量\n完全背包物品可以取多次\ndp[i,j] &#x3D; max(dp[i-1,j],dp[i-1,j - k v[i]] + k p[i]) \nw从左到右遍历 这样就是可以取多次 （对于第i行 不断考察取不取i物品）\n区间dp钢条切割dp[i]表示切割长度为i的钢条能获得的最大收益\ndp[i] &#x3D; dp[i - j] +p[j] (j \\in [1,i])\n矩阵链乘法两个矩阵(pq,qr)相乘进行的乘法次数pqr\ndp[i,j]表示第i到第j个矩阵顺序运算需要的次数\ndp[i,j] &#x3D; min(dp[i,k] + dp[k + 1,j] + p_i-1p_kp_j)\ni &lt;&#x3D; k &lt; j\n树形dp一般是二叉树后序遍历\n状压dp状态压缩 一般用二进制表示 这就要求状态转移的选择尽量少\n图论DFS&#x2F;BFS注意染色color\nbfs需要使用队列\n时间复杂度都是O(V+E)\n环路检测利用DFS看是否会遇到队列里的节点（已经遍历过）\nO(V+E)\n拓扑排序BFS拿走入度为0的节点 拿走的同时注意修改邻接点的入度\nDFS 按照完成时刻逆序\nO(V+E)\n强连通分量点之间可达 注意一个点也是强连通分量\nkosaraju算法：\n\n反向\nDFS做拓扑排序 完成时间逆序 L\n按照L再进行一次DFS 每次得到的分量就是一个强连通分量\n\n时间复杂度O(V+E)\n最小生成树(MST)Prim优先队列,将节点带着边入队 不断取最小的边\n注意每次poll之后要更新\nO(ElogV + VlogV)\nKruscal并查集 union_set O(logV)\nfind_set O(logV)\ncreate O(1)\nO(ElogE + ElogV)\n单源最短路径(dijkstra)dijkstra指定顶点\n本质上是贪心 也用了优先队列 不断更新累计权值\n权值必须非负\nO（VlogV + ElogV) \n注意 dijkstra和prim注意区分\nbellman-ford指定顶点\n执行V轮松弛 每次检查E条边 顺序无所谓 （最多V - 1轮 可以全部松弛完）\n如果第n轮还能松弛 说明存在负环 否则求解完毕\nO(VE)\nFloyd所有顶点\n可以有负权\n$$dp[k,i,j] &#x3D; min {dp[k - 1,i,j],dp[k - 1,i,k] + dp[k - 1,k,j] }$$\n二分图技巧HashSet、HashMap去重&#x2F;判重 空间换时间 遇到需要时间复杂度位O(1)的操作即可用\n前缀和 （一维 二维）\n双指针1.对向双指针\n避免判断余数sum +&#x3D; (pile+speed-1)&#x2F;speed;\n&#x2F;&#x2F;如果pile % speed &#x3D;&#x3D; 0 那么 speed - 1 &#x2F; speed &#x3D; 0\n&#x2F;&#x2F;如果pile % speed !&#x3D; 0 那么 speed 再贡献一个speed 相当于商 +  1\n&#x2F;&#x2F;相比求余数快的离谱\n\n位运算\n去掉最右边的1 x &amp; (x-1)\n找出最右边的1 x &amp; (-x)\n","slug":"leetcode","date":"2020-09-02T02:41:45.000Z","categories_index":"learning","tags_index":"leetcode","author_index":"Sihan Chen"}]