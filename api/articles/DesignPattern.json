{"title":"DesignPattern","uid":"d98f1fb29d1fa4ad9eb741861fb28e94","slug":"DesignPattern","date":"2022-03-14T10:36:34.000Z","updated":"2023-03-20T15:16:59.479Z","comments":true,"path":"api/articles/DesignPattern.json","keywords":null,"cover":"/post/DesignPattern/cover.jpg","content":"<h1 id=\"Design-Pattern\"><a href=\"#Design-Pattern\" class=\"headerlink\" title=\"Design Pattern\"></a>Design Pattern</h1><p>22种设计模式的学习 以java为实现语言</p>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><p><img src=\"/post/DesignPattern/image-20230313211445508.png\" alt=\"image-20230313211445508\"></p>\n<h3 id=\"关系\"><a href=\"#关系\" class=\"headerlink\" title=\"关系\"></a>关系</h3><h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><p><img src=\"/post/DesignPattern/image-20230313212941345.png\" alt=\"image-20230313212941345\"></p>\n<p>修改课程会导致教授发生变化</p>\n<h4 id=\"关联\"><a href=\"#关联\" class=\"headerlink\" title=\"关联\"></a>关联</h4><p><img src=\"/post/DesignPattern/image-20230313212956528.png\" alt=\"image-20230313212956528\"></p>\n<p>教授总是能访问学生</p>\n<h4 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h4><p><img src=\"/post/DesignPattern/image-20230313214159024.png\" alt=\"image-20230313214159024\"></p>\n<p>院系作为容器装着教授</p>\n<h4 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h4><p><img src=\"/post/DesignPattern/image-20230313215016576.png\" alt=\"image-20230313215016576\"></p>\n<p>大学由院系组成，院系不存在了 大学就不存在了</p>\n<p><img src=\"/post/DesignPattern/image-20230313215418905.png\" alt=\"image-20230313215418905\"></p>\n<h2 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h2><h3 id=\"SOLID原则\"><a href=\"#SOLID原则\" class=\"headerlink\" title=\"SOLID原则\"></a>SOLID原则</h3><ul>\n<li>Single Responsibility Principle:单一职责，相关的功能封装在一起</li>\n<li>Open&#x2F;Closed Principle:开闭原则,对新增开放，对修改封闭</li>\n<li>Liskov Substitution Principle：里氏替换原则, 子类能替代超类</li>\n<li>Interface Segregation Principle：接口隔离原则 拆分接口</li>\n<li>Dependency Inversion Principle：依赖倒置原则</li>\n</ul>\n<h3 id=\"创建型（5）\"><a href=\"#创建型（5）\" class=\"headerlink\" title=\"创建型（5）\"></a>创建型（5）</h3><p>提供创建对象的机制，增加已有代码的灵活性和可复用性</p>\n<h4 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h4><p><img src=\"/post/DesignPattern/image-20230313222508822.png\" alt=\"image-20230313222508822\"></p>\n<p>实际上不用区分AB工厂 将createA和createB放入工厂内部即可</p>\n<h4 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h4><p><img src=\"/post/DesignPattern/image-20230313224019275.png\" alt=\"image-20230313224019275\"></p>\n<p>开始出现二维，例如风格，p1风格和p2风格都有createA和createB</p>\n<h4 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h4><p><img src=\"/post/DesignPattern/image-20230313224605156.png\" alt=\"image-20230313224605156\"></p>\n<p>当创建一个非常繁琐的嵌套类时，用director当主控逻辑，用不同的具体builder建造</p>\n<h4 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h4><p><img src=\"/post/DesignPattern/image-20230313224845713.png\" alt=\"image-20230313224845713\"></p>\n<p>就是深拷贝 调用clone返回完全相同的实例</p>\n<h4 id=\"单例\"><a href=\"#单例\" class=\"headerlink\" title=\"单例\"></a>单例</h4><p><img src=\"/post/DesignPattern/image-20230313225040720.png\" alt=\"image-20230313225040720\"></p>\n<ul>\n<li>实例必须是static final的</li>\n<li>构造器必须是private的 只能从内部调用</li>\n</ul>\n<h3 id=\"结构型（7）\"><a href=\"#结构型（7）\" class=\"headerlink\" title=\"结构型（7）\"></a>结构型（7）</h3><p>介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效</p>\n<h4 id=\"适配器\"><a href=\"#适配器\" class=\"headerlink\" title=\"适配器\"></a>适配器</h4><p><img src=\"/post/DesignPattern/image-20230313225425234.png\" alt=\"image-20230313225425234\"></p>\n<p>本质上是对第三方接口进行包装，在里面将data转化成specialData 然后传入第三方接口</p>\n<h4 id=\"桥接\"><a href=\"#桥接\" class=\"headerlink\" title=\"桥接\"></a>桥接</h4><p><img src=\"/post/DesignPattern/image-20230313225701225.png\" alt=\"image-20230313225701225\"></p>\n<p>抽象由具体实现聚合而成，具体实现作为抽象的成员变量，抽象有对实现的引用，这个引用就是桥</p>\n<p>本来可以由继承解决 但是为了避免$$N\\times N $$类数量爆炸的问题，通过引用改成了$$N + N $$个类</p>\n<p>不要继承要组合</p>\n<h4 id=\"组合-1\"><a href=\"#组合-1\" class=\"headerlink\" title=\"组合\"></a>组合</h4><p><img src=\"/post/DesignPattern/image-20230313230119562.png\" alt=\"image-20230313230119562\"></p>\n<p>此组合非彼组合：桥接模式的组合指的是 不要继承要组合；这里的组合指的是容器意义上的包含</p>\n<p>容器和元素都有execute方法</p>\n<h4 id=\"装饰\"><a href=\"#装饰\" class=\"headerlink\" title=\"装饰\"></a>装饰</h4><p><img src=\"/post/DesignPattern/image-20230313230321138.png\" alt=\"image-20230313230321138\"></p>\n<p>decorator包含多个具体的组件嵌套，有点类似组合模式</p>\n<h4 id=\"外观\"><a href=\"#外观\" class=\"headerlink\" title=\"外观\"></a>外观</h4><p><img src=\"/post/DesignPattern/image-20230313230730426.png\" alt=\"image-20230313230730426\"></p>\n<p>facade暴露了一个调用API,内部子系统自行工作，将复杂的子系统包一层，然后暴露一个简单的输入输出API+简单的主控逻辑</p>\n<h4 id=\"享元\"><a href=\"#享元\" class=\"headerlink\" title=\"享元\"></a>享元</h4><p><img src=\"/post/DesignPattern/image-20230313231144258.png\" alt=\"image-20230313231144258\"></p>\n<p>将共有的属性提出来称为一个单例类</p>\n<p>Context中flyweight是共享类 uniqueState是区别属性</p>\n<h4 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h4><p><img src=\"/post/DesignPattern/image-20230313231901207.png\" alt=\"image-20230313231901207\"></p>\n<p>和外观模式很相似：代理对服务有引用</p>\n<h3 id=\"行为（10）\"><a href=\"#行为（10）\" class=\"headerlink\" title=\"行为（10）\"></a>行为（10）</h3><p>负责对象间的高效沟通和职责委派</p>\n<h4 id=\"责任链\"><a href=\"#责任链\" class=\"headerlink\" title=\"责任链\"></a>责任链</h4><p><img src=\"/post/DesignPattern/image-20230313232154765.png\" alt=\"image-20230313232154765\"></p>\n<p>每个handler都有对下一个handler的引用，将request传入第一个handler</p>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><p><img src=\"/post/DesignPattern/image-20230313232740720.png\" alt=\"image-20230313232740720\"></p>\n<p>将具体请求封装成一个command，传入invoker，invoker自行execute，execute相关的信息已经包在command里了</p>\n<h4 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h4><p><img src=\"/post/DesignPattern/image-20230313233053813.png\" alt=\"image-20230313233053813\"></p>\n<p>Java典型的Iterator</p>\n<h4 id=\"中介者\"><a href=\"#中介者\" class=\"headerlink\" title=\"中介者\"></a>中介者</h4><p><img src=\"/post/DesignPattern/image-20230313233308318.png\" alt=\"image-20230313233308318\"></p>\n<p>构建中枢，所有的component和中枢交流，避免component互相交流</p>\n<h4 id=\"备忘录\"><a href=\"#备忘录\" class=\"headerlink\" title=\"备忘录\"></a>备忘录</h4><p><img src=\"/post/DesignPattern/image-20230313234618832.png\" alt=\"image-20230313234618832\"></p>\n<p>Originator中的状态不想让外界知道(private)，将属性抽入Memento,Memento也不能让外界知道，但是Memento作为Originator的内部类，Originator可以随意访问</p>\n<h4 id=\"观察者\"><a href=\"#观察者\" class=\"headerlink\" title=\"观察者\"></a>观察者</h4><p><img src=\"/post/DesignPattern/image-20230313234845585.png\" alt=\"image-20230313234845585\"></p>\n<p>包含多个订阅对象的引用</p>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><p><img src=\"/post/DesignPattern/image-20230313235235349.png\" alt=\"image-20230313235235349\"></p>\n<p>context含有state，do通过调用内部state实现，context可以改变state</p>\n<h4 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h4><p><img src=\"/post/DesignPattern/image-20230313235327935.png\" alt=\"image-20230313235327935\"></p>\n<p>和状态模式基本一样，状态模式的状态之间有转化关系，策略模式的策略之间毫无关系</p>\n<h4 id=\"模板方法\"><a href=\"#模板方法\" class=\"headerlink\" title=\"模板方法\"></a>模板方法</h4><p><img src=\"/post/DesignPattern/image-20230313235604061.png\" alt=\"image-20230313235604061\"></p>\n<p>将一件事抽象为步骤1234的模板类，具体实现类可以重写不同的步骤</p>\n<h4 id=\"访问者\"><a href=\"#访问者\" class=\"headerlink\" title=\"访问者\"></a>访问者</h4><p><img src=\"/post/DesignPattern/image-20230314000025058.png\" alt=\"image-20230314000025058\"></p>\n<p>不修改原来的代码，将待解析对象作为参数传入visitor</p>\n<p>为了区别不同的类，需要在visitor中判断具体的类</p>\n<p>为了避免visitor中频繁的if instance of，可以使用双分派技巧，让element传入visitor的时候就自动知道自己的类：将visitor传入element，再调用visitor，将this作为参数传入，就会自动选择对应的重载方法</p>\n","text":"Design Pattern22种设计模式的学习 以java为实现语言 UMLclass 关系依赖 修改课程会导致教授发生变化 关联 教授总是能访问学生 聚合 院系作为容器装着教授 组合 大学由院系组成，院系不存在了 大学就不存在了 模式SOLID原则 Single Respon...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"learning","slug":"learning","count":12,"path":"api/categories/learning.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"DesignPattern","slug":"DesignPattern","count":1,"path":"api/tags/DesignPattern.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Design-Pattern\"><span class=\"toc-text\">Design Pattern</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UML\"><span class=\"toc-text\">UML</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#class\"><span class=\"toc-text\">class</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">依赖</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94\"><span class=\"toc-text\">关联</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%81%9A%E5%90%88\"><span class=\"toc-text\">聚合</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88\"><span class=\"toc-text\">组合</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SOLID%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">SOLID原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%9E%8B%EF%BC%885%EF%BC%89\"><span class=\"toc-text\">创建型（5）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">工厂方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">抽象工厂</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E5%99%A8\"><span class=\"toc-text\">生成器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">原型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%BE%8B\"><span class=\"toc-text\">单例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%9E%8B%EF%BC%887%EF%BC%89\"><span class=\"toc-text\">结构型（7）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%82%E9%85%8D%E5%99%A8\"><span class=\"toc-text\">适配器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A1%A5%E6%8E%A5\"><span class=\"toc-text\">桥接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BB%84%E5%90%88-1\"><span class=\"toc-text\">组合</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%A5%B0\"><span class=\"toc-text\">装饰</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%96%E8%A7%82\"><span class=\"toc-text\">外观</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%AB%E5%85%83\"><span class=\"toc-text\">享元</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">代理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%8C%E4%B8%BA%EF%BC%8810%EF%BC%89\"><span class=\"toc-text\">行为（10）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B4%A3%E4%BB%BB%E9%93%BE\"><span class=\"toc-text\">责任链</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">迭代器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E4%BB%8B%E8%80%85\"><span class=\"toc-text\">中介者</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%87%E5%BF%98%E5%BD%95\"><span class=\"toc-text\">备忘录</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%82%E5%AF%9F%E8%80%85\"><span class=\"toc-text\">观察者</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">策略</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">模板方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E8%80%85\"><span class=\"toc-text\">访问者</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"RedisLearning","uid":"0ada6c4f5edc36649f58988ffaf9b8b2","slug":"RedisLearning","date":"2022-08-02T08:40:39.000Z","updated":"2023-03-20T15:17:50.079Z","comments":true,"path":"api/articles/RedisLearning.json","keywords":null,"cover":"/post/RedisLearning/cover.jpg","text":"RedisLearningRedis是一个很重要非关系型数据库(NoSQL)，速度极快（KV型数据库），常用来做缓存或数据库 环境配置 直接下载windows版的redis 通过docker拉取redis镜像，在容器中使用redis 注意如果开着VPN，docker deskto...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"learning","slug":"learning","count":12,"path":"api/categories/learning.json"}],"tags":[{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}],"author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CppLearning","uid":"043ea5846f4ce7e1aaad5107c0f5a6a3","slug":"CppLearning","date":"2021-06-21T02:55:58.000Z","updated":"2023-03-02T08:57:11.752Z","comments":true,"path":"api/articles/CppLearning.json","keywords":null,"cover":"/post/CppLearning/cover.jpg","text":"C++learning1.基本语法1.命名空间在C&#x2F;C++中，变量、函数和类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染。 定义：namespace name1...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"learning","slug":"learning","count":12,"path":"api/categories/learning.json"}],"tags":[{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}