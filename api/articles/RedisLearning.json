{"title":"RedisLearning","uid":"0ada6c4f5edc36649f58988ffaf9b8b2","slug":"RedisLearning","date":"2023-03-02T08:40:39.000Z","updated":"2023-03-15T07:28:01.530Z","comments":true,"path":"api/articles/RedisLearning.json","keywords":null,"cover":"/post/RedisLearning/cover.jpg","content":"<h1 id=\"RedisLearning\"><a href=\"#RedisLearning\" class=\"headerlink\" title=\"RedisLearning\"></a>RedisLearning</h1><p>Redis是一个很重要非关系型数据库(NoSQL)，速度极快（KV型数据库），常用来做缓存或数据库</p>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><ul>\n<li>直接下载windows版的redis</li>\n<li>通过docker拉取redis镜像，在容器中使用redis</li>\n</ul>\n<p>注意如果开着VPN，docker desktop不一定能启动, 提示WSL2出错，可以尝试重制网络</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">netsh winsock reset<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ul>\n<li>string</li>\n<li>hash</li>\n<li>list</li>\n<li>set</li>\n<li>zset</li>\n</ul>\n<p>对于没有返回值的指令，成功了返回1，失败了返回0</p>\n<p><strong>注意理解key的含义，redis中key指的是不同数据类型的名字(实例的名字)</strong></p>\n<p><code>del k</code>:删除k(实例)</p>\n<h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><ul>\n<li><code>keys pattern</code>:找出所有符合模式的key，相比scan会阻塞主线程，因为redis是单线程的，只能一次返回所有的keys</li>\n<li><code>scan cursor pattern count</code>：返回所有符合模式的key  可以和其他线程同步进行，可以多次分批返回</li>\n</ul>\n<h3 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h3><ul>\n<li><p><code>set k v</code>:设置kv</p>\n</li>\n<li><p><code>get k</code>:根据k获取v</p>\n</li>\n<li><p><code>mget k1, k2...</code>:一次性获得多个k对应的v</p>\n</li>\n<li><p><code>setex k seconds v</code>:设置对应的kv和生效时间</p>\n</li>\n<li><p><code>strlen k</code>:获取k对应的v的长度</p>\n</li>\n<li><p><code>incr k</code>:k对应的v++</p>\n</li>\n<li><p><code>incrby k v</code>:k对应的值+v</p>\n</li>\n<li><p><code>decr k</code>:k对应的v–</p>\n</li>\n<li><p><code>decrby k v</code>:k对应的值-v</p>\n</li>\n<li><p><code>append k v</code>:k对应的值拼接v</p>\n</li>\n</ul>\n<h3 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h3><ul>\n<li><p><code>hset key k1 v1...</code>:创建hash</p>\n</li>\n<li><p><code>hmset key k1 v1 k2 v2</code>:一次性设置多个kv</p>\n</li>\n<li><p><code>hget key k</code>:根据k获取v</p>\n</li>\n<li><p><code>hmget key k1, k2...</code>:一次性根据多个k获取v</p>\n</li>\n<li><p><code>hgetall key</code>：获取所有的kv对</p>\n</li>\n<li><p><code>hkeys key</code>:获取所有的k</p>\n</li>\n<li><p><code>hvals key</code>:获取所有的v</p>\n</li>\n<li><p><code>hlen key</code>:返回k的个数</p>\n</li>\n<li><p><code>hdel key k1,k2,...</code>:删除kv对</p>\n</li>\n<li><p><code>hexists key k</code>:检查k是否存在</p>\n</li>\n<li><p><code>hincrby key k v</code>:k对应的值+v</p>\n</li>\n</ul>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><ul>\n<li><code>lpush key v1 v2</code>:在左边插入v</li>\n<li><code>lpop key</code>:左边pop</li>\n<li><code>blpop key seconds</code>:左边pop，最多阻塞seconds</li>\n<li><code>rpush key v1 v2</code>:在右边插入v</li>\n<li><code>rpop key:</code>右边pop</li>\n<li><code>brpop key seconds</code>:右边pop，最多阻塞seconds</li>\n<li><code>brpoplpush l1 l2 seconds</code>:从l1右边pop插入l2左边，最多阻塞seconds</li>\n<li><code>brpoplpush l1 l2 seconds</code>:从l1右边pop插入l2左边</li>\n<li><code>lrem key count v</code>:移除与v相等的元素 count个 （count符号表示查找顺序 0表示所有）</li>\n<li><code>lindex l1 i</code>:根据index返回元素</li>\n<li><code>lrange key start stop</code>:返回范围内的元素</li>\n<li><code>linsert key before/after pivot v</code>:在pivot前&#x2F;后插入v</li>\n<li><code>llen key</code>:返回元素个数</li>\n<li><code>lset key i v</code>:根据index设置v</li>\n</ul>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><ul>\n<li><code>sadd key e</code>:向集合中增加元素e</li>\n<li><code>scard key:</code>返回集合元素个数</li>\n<li><code>smembers key</code>:返回所有元素</li>\n<li><code>sisemember key e</code>:检查是否存在</li>\n<li><code>srem key e1 e2</code>:移除元素</li>\n<li><code>sdiff key1 key2</code>:返回key1与key2的差集</li>\n<li><code>sdiffstore destination key1 key2</code>:将差集存入destination</li>\n<li><code>sinter key1 key2</code>:返回key1与key2的交集</li>\n<li><code>sinterstore destination key1 key2</code>:将交集存入destination</li>\n<li><code>sunion key1 key2</code>:返回key1与key2的并集</li>\n<li><code>sunionstore destination key1 key2</code>:将并集存入destination</li>\n<li><code>smembers key</code>:返回所有成员</li>\n</ul>\n<h3 id=\"zset\"><a href=\"#zset\" class=\"headerlink\" title=\"zset\"></a>zset</h3><p><strong>score是数字</strong></p>\n<ul>\n<li><p><code>zadd key score1 e1 score2 e2</code>:向有序集合添加元素</p>\n</li>\n<li><p><code>zcard key</code>:返回元素个数</p>\n</li>\n<li><p><code>zcount key min max</code>:返回指定分数区间的成员个数</p>\n</li>\n<li><p><code>zlexcount key min max</code>:返回指定字典区间的成员个数 注意字符用[a表示</p>\n</li>\n<li><p><code>zrange key start stop</code>:返回指定索引区间的成员</p>\n</li>\n<li><p><code>zrevrange key max min</code>:返回指定索引区间的成员(倒序)</p>\n</li>\n<li><p><code>zrevrangebyscore key max min</code>:返回指定索引区间的成员(倒序)</p>\n</li>\n<li><p><code>zrevrangebylex key max min</code>:返回字典索引区间的成员(倒序)</p>\n</li>\n<li><p><code>zrangebyscore key min max</code>:返回指定分数区间的成员</p>\n</li>\n<li><p><code>zrangebylex key min max</code>:返回指定字典区间的成员</p>\n</li>\n<li><p><code>zincrby key v e</code>:e对应的score+v</p>\n</li>\n<li><p><code>zrank key e</code>:返回成员的索引</p>\n</li>\n<li><p><code>zscore key e:</code>返回成员的分数</p>\n</li>\n<li><p><code>zrem key e1 e2</code>:移除元素</p>\n</li>\n<li><p><code>zremrangebylex key min max</code>:移除指定字典区间的成员</p>\n</li>\n<li><p><code>zremrangebyscore key min max</code>:移除指定分数区间的成员</p>\n</li>\n<li><p><code>zinterstore destination number key1 key2</code>:将交集存入destination</p>\n</li>\n<li><p><code>zunionstore destination number key1 key2</code>:将并集存入destination</p>\n</li>\n</ul>\n<h2 id=\"用作缓存\"><a href=\"#用作缓存\" class=\"headerlink\" title=\"用作缓存\"></a>用作缓存</h2><ul>\n<li>缓存穿透：总是查询缓存中不存在的key 就可以绕过缓存直接打后端<ul>\n<li>将不存在的key对应的空值也缓存</li>\n<li>布隆过滤器：将key映射到多个index，查询是否存在的时候看对应的index是否为1，若全为1说明<strong>可能</strong>存在；若不全为1，则一定不存在</li>\n</ul>\n</li>\n<li>缓存击穿：某个key失效导致后端接口压力增大<ul>\n<li>加分布式锁</li>\n</ul>\n</li>\n<li>缓存雪崩：大量的缓存同时失效 <ul>\n<li>加分布式锁</li>\n<li>多级缓存</li>\n<li>随机过期</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据一致性\"><a href=\"#数据一致性\" class=\"headerlink\" title=\"数据一致性\"></a>数据一致性</h3><p>redis作为缓存，MySQL作为数据库</p>\n<p>现在要更新数据，如何保证缓存和数据库的一致性？</p>\n<ol>\n<li>先删除缓存，再更新数据库；但是可能还没更新之前就有线程要读，从数据库中读出脏数据</li>\n<li>先更新数据库，再删除缓存：更新数据库的过程中如果有线程读数据会直接从缓存读脏数据</li>\n</ol>\n<p>缓存策略的最佳实践:Cache Aside Pattern</p>\n<p><img src=\"/post/RedisLearning/1460000041998617.png\" alt=\"img\"></p>\n<ul>\n<li><p>读取最佳实践：先读取Cache 如果没有则从DB中读取，然后更新Cache</p>\n</li>\n<li><p>写入最佳实践：先删除Cache 再更新DB （如果DB更新失败，读出来的数据还是和DB一致）</p>\n</li>\n<li><p>有问题的写入机制：</p>\n<ul>\n<li>先更新Cache 再更新DB （如果DB更新失败 则Cache为脏数据）</li>\n<li>先更新DB 再更新Cache （如果Cache更新失败，则数据不一致）</li>\n<li>先更新DB再删除Cache（如果Cache删除失败，则数据不一致）</li>\n</ul>\n<p>但是如果更新DB失败，在重试的过程中有查询，则会读出还没更新的数据，导致暂时的不一致，顺便更新了cache（脏数据）</p>\n<p>所以引入延迟双删机制，先删除Cache，然后更新DB，再删除Cache（清楚脏数据），sleep保证删除Cache完成</p>\n<p>保证了最终一致性</p>\n<p>综上 不要更新Cache，容易导致不一致，优先删除Cache，再从DB同步</p>\n<p>注意：</p>\n<ul>\n<li>如果删除Cache一直失败需要报警，同时可以通过消息队列重试保证Cache一定删除成功</li>\n<li>将删除Cache与业务解耦，通过订阅binlog实现</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"用作消息队列\"><a href=\"#用作消息队列\" class=\"headerlink\" title=\"用作消息队列\"></a>用作消息队列</h2><ul>\n<li>异步消息队列：list, rpush, lpop；可以自行sleep然后再lpop，当然也可以blpop，阻塞地pop</li>\n<li>延时队列：zset,用时间戳作score，然后用zrangebyscore获取特定时间戳的元素</li>\n</ul>\n<h2 id=\"用作分布式锁\"><a href=\"#用作分布式锁\" class=\"headerlink\" title=\"用作分布式锁\"></a>用作分布式锁</h2><ul>\n<li><code>setnx key</code>:抢锁</li>\n<li><code>expire seconds</code>：定期释放锁</li>\n</ul>\n","text":"RedisLearningRedis是一个很重要非关系型数据库(NoSQL)，速度极快（KV型数据库），常用来做缓存或数据库 环境配置 直接下载windows版的redis 通过docker拉取redis镜像，在容器中使用redis 注意如果开着VPN，docker deskto...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"learning","slug":"learning","count":12,"path":"api/categories/learning.json"}],"tags":[{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#RedisLearning\"><span class=\"toc-text\">RedisLearning</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">环境配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#key\"><span class=\"toc-text\">key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#string\"><span class=\"toc-text\">string</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#hash\"><span class=\"toc-text\">hash</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#list\"><span class=\"toc-text\">list</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#set\"><span class=\"toc-text\">set</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#zset\"><span class=\"toc-text\">zset</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E4%BD%9C%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">用作缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\"><span class=\"toc-text\">数据一致性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E4%BD%9C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">用作消息队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E4%BD%9C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">用作分布式锁</span></a></li></ol></li></ol>","author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"DesignPattern","uid":"d98f1fb29d1fa4ad9eb741861fb28e94","slug":"DesignPattern","date":"2023-03-14T10:36:34.000Z","updated":"2023-03-14T10:41:07.462Z","comments":true,"path":"api/articles/DesignPattern.json","keywords":null,"cover":"/post/DesignPattern/cover.jpg","text":"Design Pattern22种设计模式的学习 以java为实现语言 UMLclass 关系依赖 修改课程会导致教授发生变化 关联 教授总是能访问学生 聚合 院系作为容器装着教授 组合 大学由院系组成，院系不存在了 大学就不存在了 模式SOLID原则 Single Respon...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"learning","slug":"learning","count":12,"path":"api/categories/learning.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"DesignPattern","slug":"DesignPattern","count":1,"path":"api/tags/DesignPattern.json"}],"author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MarkupLanLearning","uid":"0aca10cea344fa1aabb90a273c674d58","slug":"MarkupLanguageLearning","date":"2023-03-02T08:38:00.000Z","updated":"2023-03-02T08:52:05.412Z","comments":true,"path":"api/articles/MarkupLanguageLearning.json","keywords":null,"cover":"/post/MarkupLanguageLearning/cover.jpg","text":"XMLLearningeXtensible Markup Language（XML） XML 被设计用来传输和存储数据，不用于表现和展示数据，HTML 则用来表现数据。 demo&lt;bookstore> &lt;book category=\"COOKING\"> &lt;tit...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"learning","slug":"learning","count":12,"path":"api/categories/learning.json"}],"tags":[{"name":"XML","slug":"XML","count":1,"path":"api/tags/XML.json"},{"name":"YAML","slug":"YAML","count":1,"path":"api/tags/YAML.json"},{"name":"JSON","slug":"JSON","count":1,"path":"api/tags/JSON.json"}],"author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}