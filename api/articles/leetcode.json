{"title":"leetcode","uid":"1cac424653694fd0abd1397c14df4e06","slug":"leetcode","date":"2020-09-02T02:41:45.000Z","updated":"2022-11-08T07:56:16.899Z","comments":true,"path":"api/articles/leetcode.json","keywords":null,"cover":"/post/leetcode/cover.jpg","content":"<h1 id=\"leetcode\"><a href=\"#leetcode\" class=\"headerlink\" title=\"leetcode\"></a>leetcode</h1><p>本文主要用来记录自己刷lc的成长过程， 希望大家都能收获理想的offer 😊</p>\n<hr>\n<p><img src=\"/post/leetcode/image-20220404153500414.png\" alt=\"image-20220404153500414\"></p>\n<table>\n<thead>\n<tr>\n<th>input size</th>\n<th>时间复杂度</th>\n<th>常见算法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1~10</td>\n<td>n!</td>\n<td>排列</td>\n</tr>\n<tr>\n<td>15~20</td>\n<td>2^n</td>\n<td>组合</td>\n</tr>\n<tr>\n<td>10~50</td>\n<td>n^4</td>\n<td></td>\n</tr>\n<tr>\n<td>100~200</td>\n<td>n^3</td>\n<td></td>\n</tr>\n<tr>\n<td>1000~2000</td>\n<td>n^2</td>\n<td>DP 图问题</td>\n</tr>\n<tr>\n<td>10^6</td>\n<td>nlogn</td>\n<td>贪心 堆 分治 排序</td>\n</tr>\n<tr>\n<td>10^7</td>\n<td>n</td>\n<td>DP 图问题</td>\n</tr>\n<tr>\n<td>2^31   10^9</td>\n<td>sqrt(n)</td>\n<td>数论问题</td>\n</tr>\n<tr>\n<td>2^31  10^9</td>\n<td>logn</td>\n<td>二分查找 分治</td>\n</tr>\n<tr>\n<td>10^9</td>\n<td>1</td>\n<td>数学归纳</td>\n</tr>\n</tbody></table>\n<h1 id=\"一-基本数据结构熟悉（简单题）\"><a href=\"#一-基本数据结构熟悉（简单题）\" class=\"headerlink\" title=\"一.基本数据结构熟悉（简单题）\"></a>一.基本数据结构熟悉（简单题）</h1><h2 id=\"1-栈\"><a href=\"#1-栈\" class=\"headerlink\" title=\"1.栈\"></a>1.栈</h2><p>5.19</p>\n<h3 id=\"1-括号匹配\"><a href=\"#1-括号匹配\" class=\"headerlink\" title=\"1.括号匹配\"></a>1.括号匹配</h3><p>1.简单做法 操作栈</p>\n<p>注意stack为空的情况</p>\n<p>不匹配直接结束</p>\n<p><strong>hint</strong> 可以进行奇偶判断</p>\n<h3 id=\"2-两个stack实现queue\"><a href=\"#2-两个stack实现queue\" class=\"headerlink\" title=\"2.两个stack实现queue\"></a>2.两个stack实现queue</h3><p>inStack和outStack作用：倒腾</p>\n<p>如果连续两次入队(出队)，即连续两次操作相同，不用倒腾</p>\n<p>一旦产生变化需要换stack</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\">inStack &#x3D; [1,2]\nfor item in inStack:\n\toutStack.append(inStack.pop())\n#错误 loop1：item &#x3D; 1 pop出2 不会进行第二次loop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>5.20</p>\n<h3 id=\"3-两个queue实现stack\"><a href=\"#3-两个queue实现stack\" class=\"headerlink\" title=\"3.两个queue实现stack\"></a>3.两个queue实现stack</h3><ul>\n<li>我的做法：注意flag的维护即可 定义主队列 ？？？</li>\n</ul>\n<p>push O(1)</p>\n<p>peek 与 pop复杂度相同 O(n)</p>\n<p>emptyO(1)</p>\n<ul>\n<li>1.单队列循环实现栈</li>\n<li>2.规定主队列辅助队列 辅助队列用来存最新入栈的元素 实现队列与栈同顺序</li>\n</ul>\n<p>pop的时候换队列即可</p>\n<h3 id=\"4-最小栈\"><a href=\"#4-最小栈\" class=\"headerlink\" title=\"4.最小栈\"></a>4.最小栈</h3><ul>\n<li>我的思路：维护最小元素的指针 × 连续pop找不到上一个最小的</li>\n<li>1.最小index栈 如果a下面有bcd a对应的minIndex为x<br>看了题解才知道的trick 如果位于栈上面的元素不动 下面的性质则和之前一样<br>因此每个元素可以对应一个最小的index 元素改变之后刚好对应index更新<br>另外 len忘-1 导致bug</li>\n</ul>\n<p>辅助栈</p>\n<p>将每个地方对应的最小值存起来</p>\n<p>5.21</p>\n<hr>\n<h3 id=\"5-比较退格字符串\"><a href=\"#5-比较退格字符串\" class=\"headerlink\" title=\"5.比较退格字符串\"></a>5.比较退格字符串</h3><p>  5.26</p>\n<hr>\n<h4 id=\"1-用stack实现-压栈出栈\"><a href=\"#1-用stack实现-压栈出栈\" class=\"headerlink\" title=\"1.用stack实现 压栈出栈\"></a>1.用stack实现 压栈出栈</h4><h4 id=\"2-双指针法\"><a href=\"#2-双指针法\" class=\"headerlink\" title=\"2.双指针法\"></a>2.双指针法</h4><p>注意两个字符串都要遍历完，如果写的while条件是</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\">while i &gt;&#x3D; 0 and j &gt;&#x3D; 0:\n    pass\n# bb# bb 执行错误<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>指针是-1 退格符过多已经把所有的前面的字符都清了</p>\n<p>如果两个都是 -1 说明相等（后面的字符串已经相等了）</p>\n<h3 id=\"1021-删除最外层的括号\"><a href=\"#1021-删除最外层的括号\" class=\"headerlink\" title=\"1021.删除最外层的括号\"></a>1021.删除最外层的括号</h3><p>单纯的入栈弹栈括号匹配，只是要去掉最外层的括号，如果只有一层就不能去，有些坑</p>\n<p>python没有找到比较好的直接替换两端括号的方法：</p>\n<p>1.str-&gt;list-&gt;str</p>\n<p>2.特判选对index</p>\n<p>hint：入栈出栈其实还可以用count来表示，入栈count++，出栈count–，以计数器来模拟栈的出入操作</p>\n<h3 id=\"461-汉明距离\"><a href=\"#461-汉明距离\" class=\"headerlink\" title=\"461. 汉明距离\"></a>461. 汉明距离</h3><p>5.28</p>\n<hr>\n<p>hint：海明码</p>\n<p>朴素想法：化成二进制逐位判断</p>\n<p>正常想法：做异或，判断1的个数，有几个1就有多少位不同</p>\n<p>优化：Brian Kernighan 统计x中1的个数每次用x&amp;&#x3D;（x-1） 循环多少次就有多少个1 每次循环把最右端的1变为0</p>\n<p>Brian Kernighan应用：</p>\n<ul>\n<li><p>判断一个数是否是2的幂次方 用 return x &amp; (x-1) &#x3D;&#x3D; 0</p>\n</li>\n<li><p>把某个区间的数全部&amp;起来，可以把右端的数不断去1，直到小于左端：如果去掉1还在范围内，说明此位位0（&amp;），如果不是，那么我只关心最新的在区间中存不存在这位是0的数，如果存在那么全部&amp;起来的结果就是这个数，显然是存在的。因为左端大于等于这个数，等于则显然，如果大于，那么此位一定是0</p>\n<p>比如如果最后的数是1000 那么区间中一定存在1100 左端一定小于1100 所以一定是10xx</p>\n</li>\n</ul>\n<h3 id=\"477-汉明距离总和\"><a href=\"#477-汉明距离总和\" class=\"headerlink\" title=\"477.汉明距离总和\"></a>477.汉明距离总和</h3><p>暴力两遍循环TLE O（n^2）</p>\n<p>trick：一个数组里面按位来统计，如果是1就统计其他元素对应位有多少个0，反之亦然。这样就只有一次循环O(n)</p>\n<p>另外还有位数的循环O(L)忽略</p>\n<p>另外10^3 &lt; 2^10 &#x3D;&gt; 10^9 &lt; 2&lt;^30</p>\n<p>hint:</p>\n<p>101</p>\n<p>101</p>\n<p>100</p>\n<p>100</p>\n<p>000 </p>\n<p>则第0位 一共贡献3 &#x3D; 2 * 3</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">c <span class=\"token operator\">=</span> <span class=\"token builtin\">sum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>val <span class=\"token operator\">>></span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span> <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n\n<h2 id=\"2-堆\"><a href=\"#2-堆\" class=\"headerlink\" title=\"2.堆\"></a>2.堆</h2><p>  5.28</p>\n<hr>\n<h3 id=\"offer-40-最小k的个数\"><a href=\"#offer-40-最小k的个数\" class=\"headerlink\" title=\"offer 40.最小k的个数\"></a>offer 40.最小k的个数</h3><p>朴素算法，直接排序取最小k个</p>\n<p>hint：去最小k个可以直接切片 切片相比于朴素的重新构造数列直接快了一半，个人觉得因为切片只需要移动指针，但是重新构建list需要重新append &amp;&amp; pop（）一遍，特别是对于原数组pop（0）是对头进行操作，所有的元素都要进行移动</p>\n<p>堆 </p>\n<p>python的优先队列库：</p>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\">import heapq\nhp &#x3D; []\nheapq.heapify(hp)\n#是具有堆的性质 pyhton默认是小顶堆\nheapq.heappush(hp)\n#加入到队列 头部hp[0]始终位堆顶\nheapq.heappop(hp)\n#pop出头部的元素\nheapq.heappushpop(hp,item)\n#将新元素加入队列 并pop出头部的元素\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>5.30</p>\n<hr>\n<h3 id=\"231-2的幂\"><a href=\"#231-2的幂\" class=\"headerlink\" title=\"231.2的幂\"></a>231.2的幂</h3><p>就是上周的trick数1</p>\n<p>要注意负数，负数直接返回<strong>False</strong> (和heap有什么关系？)</p>\n<p>newTrick：</p>\n<p>如果是2的幂次：</p>\n<p>n &#x3D; n &amp;(-n)</p>\n<h3 id=\"1046-最后一块石头的重量\"><a href=\"#1046-最后一块石头的重量\" class=\"headerlink\" title=\"1046. 最后一块石头的重量\"></a><a href=\"https://leetcode-cn.com/problems/last-stone-weight/\">1046. 最后一块石头的重量</a></h3><p>简单的python堆 应用</p>\n<p>找个机会练下手写堆:</p>\n<p>5.31</p>\n<hr>\n<pre class=\"line-numbers language-Python\" data-language=\"Python\"><code class=\"language-Python\">class heap(object):\n    &#39;&#39;&#39;mode &#x3D;&#x3D; 0 means little heap mode &#x3D;&#x3D; 1 means big heap&#39;&#39;&#39;\n    def __init__(self,heap,mode):\n        self.__heap &#x3D; []\n        self.__mode &#x3D; mode\n        for element in heap:\n            self.push(element)\n\n    def get_size(self):\n        return len(self.__heap)\n\n    def get_top(self):\n        if not heap:\n            raise IndexError()\n        return self.__heap[0]\n\n    def push(self,element):\n        p &#x3D; self.get_size()\n        self.__heap.append(element)\n        if self.__mode &#x3D;&#x3D; 0:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &gt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        else:\n            while p !&#x3D; 0 and self.__heap[(p - 1) &#x2F;&#x2F; 2] &lt; self.__heap[p]:\n                self.__heap[(p - 1) &#x2F;&#x2F; 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[(p - 1) &#x2F;&#x2F; 2]\n                p &#x3D; (p - 1) &#x2F;&#x2F; 2\n        ##up\n\n    def pop(self):\n        p &#x3D; self.get_size() - 1\n        self.__heap[0],self.__heap[p] &#x3D; self.__heap[p],self.__heap[0]\n        top &#x3D; self.__heap.pop()\n        p &#x3D; 0\n        size &#x3D; self.get_size()\n        if self.__mode &#x3D;&#x3D; 0:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &lt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &lt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &gt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                ##down handle index out of range\n        else:\n            while p * 2 + 1 &lt; size and p * 2 + 2 &lt; size:\n                if self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 1] and self.__heap[p] &gt;&#x3D; self.__heap[p * 2 + 2]:\n                    return top\n                elif self.__heap[p * 2 + 1] &gt; self.__heap[p * 2 + 2]:\n                        self.__heap[p * 2 + 1],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 1]\n                        p &#x3D; p * 2 + 1\n                else:\n                    self.__heap[p * 2 + 2],self.__heap[p] &#x3D; self.__heap[p],self.__heap[p * 2 + 2]\n                    p &#x3D; p * 2 + 2\n            if p * 2 + 1 &lt; size and self.__heap[p] &lt; self.__heap[p * 2 + 1]:\n                self.__heap[p * 2 + 1], self.__heap[p] &#x3D; self.__heap[p], self.__heap[p * 2 + 1]\n                #down handle index out of range\n        return top<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>由于涉及到大小根堆的模式 多了很多冗余代码暂时没有想到怎么处理，只是单纯的copy了一下 毕竟原理相同</p>\n<p>写的时候要特别注意python类的语法 还有堆排序的要点（上浮下沉)</p>\n<h2 id=\"3-队列\"><a href=\"#3-队列\" class=\"headerlink\" title=\"3.队列\"></a>3.队列</h2><p>6.1</p>\n<hr>\n<h3 id=\"346-数据流中的移动平均值\"><a href=\"#346-数据流中的移动平均值\" class=\"headerlink\" title=\"346. 数据流中的移动平均值\"></a><a href=\"https://leetcode-cn.com/problems/moving-average-from-data-stream/\">346. 数据流中的移动平均值</a></h3><p>题目意思看不懂</p>\n<p>朴素做法：</p>\n<p>直接用python的list&amp;&amp;自带的方法维护队列 相当于手动构造</p>\n<p>由于list是单向的 实际上就是一个数组 强行搞成双端 每次pop（0）都需要涉及到一堆元素的移动 </p>\n<p>不需要维护list</p>\n<p>记录最前面的数、size、sum就好了 O(1)</p>\n<h3 id=\"1744-你能在你最喜欢的那天吃到你最喜欢的糖果吗？\"><a href=\"#1744-你能在你最喜欢的那天吃到你最喜欢的糖果吗？\" class=\"headerlink\" title=\"1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？\"></a><a href=\"https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/\">1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</a></h3><p>儿童节快乐！！！！！！</p>\n<p>怪的不得了</p>\n<p>自己手写的算法没有做记忆化 导致超时</p>\n<p>先求前缀和</p>\n<p>然后求范围， 看是否match</p>\n<p>9.4</p>\n<h2 id=\"4-二叉树\"><a href=\"#4-二叉树\" class=\"headerlink\" title=\"4.二叉树\"></a>4.二叉树</h2><p>递归只涉及到三条语句 前中后序遍历只涉及到语句的不同位置</p>\n<h3 id=\"递归实现\"><a href=\"#递归实现\" class=\"headerlink\" title=\"递归实现\"></a>递归实现</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">preorderTraversal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TreeNode</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> results <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> results<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token function\">preorderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token function\">preorderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> results<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\t\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">inorderTraversal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TreeNode</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> results <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> results<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token function\">inorderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token function\">inorderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> results<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">postorderTraversal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TreeNode</span> root<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> results <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>root <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span> results<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token function\">postorderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span><span class=\"token function\">postorderTraversal</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> results<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"迭代实现\"><a href=\"#迭代实现\" class=\"headerlink\" title=\"迭代实现\"></a>迭代实现</h3><p>前中后序遍历的迭代实现</p>\n<p>迭代有考究：需要用到stack ，node非空是为了避免root为空的情况吗，都需要判断当前节点是否为空</p>\n<ul>\n<li>1.pre 如果stack和node非空，就一直找左子节点，不断访问信息 然后压栈，压栈是为了之后能够回去找到右子节点；如果节点为空，说明没有左子节点，开始访问右子节点，这时就要弹上次压入的节点，然后找到右子节点</li>\n<li>2.in 做法同pre 知识访问的地方在弹栈之后：如果stack和node非空,压入该节点然后找到左子节点；如果节点空，则弹栈，访问该节点信息，然后通过该节点找到右子节点</li>\n<li>3.post 做法和前两者不同：先判断当前是否为空，如果不空，则压入，如果左子节点不空则找到左子节点，反之找到右子节点；如果空，则弹栈（此时两子节点都空），访问信息，然后peek一下，看是否是这个节点的左子节点，如果是，那么则找到该peek节点的右子节点，如果不是，说明现在已经是右子节点了，已经访问完了，所以就直接令为None 以便下一次循环直接再pop一次</li>\n</ul>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">  &#x2F;&#x2F;迭代中序\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n       List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();\n       Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n       TreeNode cur &#x3D; root;\n       while (cur !&#x3D; null || !stack.isEmpty()) &#123;\n           while (cur !&#x3D; null) &#123;\n               ans.add(cur.val);\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;\n           cur &#x3D; stack.pop();\n           cur &#x3D; cur.right;\n       &#125;\n       return ans;\n   &#125;\n\n   &#x2F;&#x2F;迭代中序\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n       List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();\n       Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n       TreeNode cur &#x3D; root;\n       while (cur !&#x3D; null || !stack.isEmpty()) &#123;\n           while (cur !&#x3D; null) &#123;\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;\n           cur &#x3D; stack.pop();\n           ans.add(cur.val);\n           cur &#x3D; cur.right;\n       &#125;\n       return ans;\n   &#125;\n\n   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n       TreeNode cur &#x3D; root;\n       Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n       List&lt;Integer&gt; ans &#x3D; new ArrayList&lt;&gt;();\n       while (cur !&#x3D; null || !stack.isEmpty()) &#123;\n           while (cur !&#x3D; null) &#123;\n               stack.push(cur);\n               if (cur.left !&#x3D; null) &#123;\n                   cur &#x3D; cur.left;\n               &#125; else &#123;\n                   cur &#x3D; cur.right;\n               &#125;\n           &#125;\n           cur &#x3D; stack.pop();\n           &#x2F;&#x2F;说明这个node的左右子节点都是null 直接visit\n           ans.add(cur.val);\n           &#x2F;&#x2F;该节点是上个节点的左节点\n           if (!stack.isEmpty() &amp;&amp; stack.peek().left &#x3D;&#x3D; cur) &#123;\n               &#x2F;&#x2F;说明当前节点是上一个节点的左子节点不能弹出\n               cur &#x3D; stack.peek().right;\n           &#125; else &#123;\n               &#x2F;&#x2F;这里其实可以直接pop上一个节点\n               &#x2F;&#x2F;赋null 也可以 就是多走一次循环\n               cur &#x3D; null;\n           &#125;\n       &#125;\n       return ans;\n   &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"二、剑指offer\"><a href=\"#二、剑指offer\" class=\"headerlink\" title=\"二、剑指offer\"></a>二、剑指offer</h1><h2 id=\"3-17\"><a href=\"#3-17\" class=\"headerlink\" title=\"3.17\"></a>3.17</h2><h3 id=\"位运算除法\"><a href=\"#位运算除法\" class=\"headerlink\" title=\"位运算除法\"></a>位运算除法</h3><p>最直观的思路就是用减法做循环 但是会超时 </p>\n<p>考虑位运算 每次用最接近的数做减法即可（二进制意义）</p>\n<p>注意唯一可能会出现的溢出情况：不存在小数 除法不会溢出 </p>\n<p>但是正负的最大值差1  除-1可能溢出 </p>\n<p>另外注意python倒序遍历的写法 最后两个写-1 </p>\n<h3 id=\"二进制加法\"><a href=\"#二进制加法\" class=\"headerlink\" title=\"二进制加法\"></a>二进制加法</h3><p>累加器：a b c </p>\n<p>当前bit : a ^ b ^ c 所有bit异或表示计算1的奇偶性 如果是奇数个 结果是1 反之是0</p>\n<p>carry : (a &amp; b) | (a | b &amp; c) 或者 (a &amp; b) | (a ^ b &amp; c) </p>\n<h3 id=\"count-1\"><a href=\"#count-1\" class=\"headerlink\" title=\"count 1\"></a>count 1</h3><ol>\n<li>BK &amp;算法：求x有多少个1 循环x &#x3D; x &amp; (x-1) 直到x &#x3D;&#x3D; 0 每做一次就末尾少一个1 （-1 减掉了末尾的1 原来1后面都是0 自然&amp;掉）</li>\n<li>最高有效位 动态规划 x &#x3D; y + z,bit[x] &#x3D; 1 + bit[z] y对应的二进制只有最高位为1 从1遍历到n 这个y为最接近x的以1开头的二进制数 需要不断更新</li>\n<li>最低设置位 可以看成最高有效位的变种 从低位开始 拿走1之后找关系</li>\n<li>最低有效位 考虑低位 只有两种可能要么有1要么无 bit[x] &#x3D; bit[x &gt;&gt; 2] + x &amp; 1 ，注意x&amp;1表示对2取余</li>\n</ol>\n<p>总的来说后三种都是动态规划,考虑当前x和之前的数的关系,要么从头拿走1 要么从尾拿走1</p>\n<p>O(n)说明了只能走一遍循环</p>\n<p>注意位运算优先级</p>\n<h2 id=\"3-18\"><a href=\"#3-18\" class=\"headerlink\" title=\"3.18\"></a>3.18</h2><h3 id=\"只出现一次的数字\"><a href=\"#只出现一次的数字\" class=\"headerlink\" title=\"只出现一次的数字\"></a>只出现一次的数字</h3><p>很简单的Hashmap法 时间复杂度O(n) 但是需要额外空间</p>\n<h4 id=\"不用额外的空间复杂度\"><a href=\"#不用额外的空间复杂度\" class=\"headerlink\" title=\"不用额外的空间复杂度\"></a>不用额外的空间复杂度</h4><p>对于32位的int，如果每个数字出现了3次，那么他的第i位二进制求和mod3余0，如果只出现一次那个该位就是mod3后的值，因此只需要对所有位求和然后mod3即可</p>\n<p>但是这样需要遍历32位，时间复杂度位O(nlogC) C为位数</p>\n<p>由于只可能出现0 1 2三种数 每次更新由下一个数的该位决定，本质上是一个状态机，由于二进制位只能表示2个状态所以需要2bit 用 a b两个数表示 ai bi共同表示当前第i位的状态</p>\n<p><img src=\"/post/leetcode/image-20220318195227290.png\" alt=\"image-20220318195227290\"></p>\n<p><img src=\"/post/leetcode/image-20220318195256372.png\" alt=\"image-20220318195256372\"></p>\n<p><img src=\"/post/leetcode/image-20220318195300585.png\" alt=\"image-20220318195300585\"></p>\n<p>最后的结果中不可能出现2这种情况 要么是0 要么是1 刚好和b相对应 return b</p>\n<h3 id=\"单词长度的最大乘积\"><a href=\"#单词长度的最大乘积\" class=\"headerlink\" title=\"单词长度的最大乘积\"></a>单词长度的最大乘积</h3><p>首先想到的就是两两比较 二重循环 然后用hashset看是否包含</p>\n<p>实际上应该先排序 只要求最长乘积 应该先排序 再判断是否有交集（O(L^2)) 每次判断两个最多n次 加上排序的(O(nlogn)) </p>\n<p>改进 用int32 存储每个单词的信息 如果没有交集 那么两个int相交为0 算int32的时间复杂度为O(L) L为单词长度 这个优化是最厉害的 降到了一次</p>\n<p>按理说最后一种最快O(nL + nlogn)  总的来说两处优化 一个是交集的优化 一个是排序优化 都降幂了</p>\n<h3 id=\"排序数组中两个数字的和\"><a href=\"#排序数组中两个数字的和\" class=\"headerlink\" title=\"排序数组中两个数字的和\"></a>排序数组中两个数字的和</h3><p>暴力n^2 </p>\n<p>遍历+二分查找 O(nlogn) 这里自己动手实现了二分查找 </p>\n<p>用hashmap （num,index）但是题目有点问题 不好搞 XXXX</p>\n<p>双指针法 O(n)</p>\n<h2 id=\"3-19\"><a href=\"#3-19\" class=\"headerlink\" title=\"3.19\"></a>3.19</h2><h3 id=\"数组中和为定值的若干个数\"><a href=\"#数组中和为定值的若干个数\" class=\"headerlink\" title=\"数组中和为定值的若干个数\"></a>数组中和为定值的若干个数</h3><p>初步思想为用hash表 但是很占内存 并且涉及到很多次去重 时间爆了</p>\n<p>没有想到用排序+双指针法 O(n^2)</p>\n<p>ps：遇到数组多往排序想 还有双指针别忘记了 好好理解双指针！注意两个指针移动的条件！</p>\n<h3 id=\"连续子数组的和满足某个条件\"><a href=\"#连续子数组的和满足某个条件\" class=\"headerlink\" title=\"连续子数组的和满足某个条件\"></a>连续子数组的和满足某个条件</h3><p>由于必须是连续的 显然可以写成前缀和 注意本题前缀和数组的第一项需要从0开始 因为可能需要有整个数组的和才满足条件的情况 注意前缀和要求元素是正值</p>\n<p>屮 竟然不是用双指针 是二分查找 复杂度logn 总共nlogn 注意lo可以减少搜索范围 适当加快速度</p>\n<p>滑动窗口：两个指针同向移动 如果不够end右移 多了 start左移 </p>\n<p>end遍历 start每次从头开始缩保证遍历 正确性</p>\n<p>通过滑动窗口可以加速 O(n^2) -&gt; O(n)</p>\n<p>千万注意滑动窗口无法解决负例</p>\n<h3 id=\"连续子数组乘积满足某个条件\"><a href=\"#连续子数组乘积满足某个条件\" class=\"headerlink\" title=\"连续子数组乘积满足某个条件\"></a>连续子数组乘积满足某个条件</h3><p>注意可能出现单个元素的值大于k的情况 这时可能出现i &gt; j 应该避免 最多只允许i &lt;&#x3D; j</p>\n<h2 id=\"3-20\"><a href=\"#3-20\" class=\"headerlink\" title=\"3.20\"></a>3.20</h2><h3 id=\"连续数组和为k\"><a href=\"#连续数组和为k\" class=\"headerlink\" title=\"连续数组和为k\"></a>连续数组和为k</h3><p>注意数组里是整数 可能为负数 滑动窗口肯定不好用 显然用前缀和（注意第一项从0开始）</p>\n<p>这样复杂度是O(n^2) 直接超时！</p>\n<p>观察发现题目只要求求出数量 并不要求具体组合 考虑优化</p>\n<p>Hash表优化 直接查需要的值存不存在有几个 注意前缀和从0开始 Hash表中初始有0：1</p>\n<p>如果求完前缀和再建Hash表 再统计就必须要判断这个数对应的index是否合法</p>\n<p>因此考虑边求前缀和 边建表 边统计 这样每次看到的Hash表都是前面的前缀和了（index 一定在前面）</p>\n<h3 id=\"连续子数组满足某个条件\"><a href=\"#连续子数组满足某个条件\" class=\"headerlink\" title=\"连续子数组满足某个条件\"></a>连续子数组满足某个条件</h3><p>这好像和求和没有什么关系啊！</p>\n<p>麻了　把０转成－１再求和就变成上一题了</p>\n<p>注意这里要求的是最长的长度　不是求个数　因此hash_map中记录的是最小的index（这样能够使长度最长）　所以hash_map中初始为０：０</p>\n<p>注意hash_map中的项一旦填了就不用改了　因为不会出现更小的index了</p>\n<h3 id=\"数组的中心下标\"><a href=\"#数组的中心下标\" class=\"headerlink\" title=\"数组的中心下标\"></a>数组的中心下标</h3><p> 显然需要对两边求和 暴力法需要O(n^2)</p>\n<p>由于存在很多重复求和 选择前缀和 观察发现只需要满足某一项与前一项和与最后一项想等即可（由于必须使砍成两截 最后一个必须在末尾 前面和中间必须相邻） 不需要用hash_map </p>\n<p>注意考虑两端都是0 且两边都没有元素的情况</p>\n<h3 id=\"二维子矩阵的和\"><a href=\"#二维子矩阵的和\" class=\"headerlink\" title=\"二维子矩阵的和\"></a>二维子矩阵的和</h3><p>显然如果直接求很简单 很难想象使简单题 肯定需要优化 </p>\n<p>显然用前缀和 避免重复计算</p>\n<p>进阶版 用二维前缀和 实际上有点类似动态规划了 可证 递推式</p>\n<p>每次查询为O(1)</p>\n<p>这个脚标太难调了 真恶心</p>\n<h2 id=\"3-21\"><a href=\"#3-21\" class=\"headerlink\" title=\"3.21\"></a>3.21</h2><h3 id=\"链表数组相加\"><a href=\"#链表数组相加\" class=\"headerlink\" title=\"链表数组相加\"></a>链表数组相加</h3><p>链表数相加，很多坑！（感觉我写的太复杂了）</p>\n<p>1.要注意carry进位处理需要循环 </p>\n<p>2.注意如果在原来链表上改的话 需要将短链接到长链上</p>\n<p>3.感觉新操作一条链表可能不容易出错些 （保持循环有三个条件 carry l1 l2 当前是否为空）</p>\n<p>？？ 为什么新开链内存更小了？ 不懂</p>\n<h3 id=\"字符串变位词-x2F-出现的index\"><a href=\"#字符串变位词-x2F-出现的index\" class=\"headerlink\" title=\"字符串变位词&#x2F;出现的index\"></a>字符串变位词&#x2F;出现的index</h3><p>没思路</p>\n<p>仔细想变位的含意 意思是s1中的字符顺序无所谓 （反正可以自己随便调顺序） 那么转化位在s2中找连续字串 各字符个数和s1中相等</p>\n<p>由于是连续字串 考虑滑动窗口即可 注意考虑s1长度小于s2的情况</p>\n<p>正常思路是用两个hashmap 当对应kv相等时满足条件 </p>\n<p>差分优化 对应的值相见 用diff来统计不同的地方 这样每次就不用重新比较一遍</p>\n<p>同理可以利用双指针 注意双指针做差后需要+1</p>\n<h3 id=\"不含重复字符的字串\"><a href=\"#不含重复字符的字串\" class=\"headerlink\" title=\"不含重复字符的字串\"></a>不含重复字符的字串</h3><p>双指针 思路类似</p>\n<h2 id=\"3-22\"><a href=\"#3-22\" class=\"headerlink\" title=\"3.22\"></a>3.22</h2><h3 id=\"含有所有字符的最短字符串\"><a href=\"#含有所有字符的最短字符串\" class=\"headerlink\" title=\"含有所有字符的最短字符串\"></a>含有所有字符的最短字符串</h3><p>变位词变种 需要注意的是现在是包含而不是相等关系 双指针破题即可 注意cnt中只用记录在变位字符串中出现的字符</p>\n<h3 id=\"回文串-x2F-允许删除n个字符的回文串-x2F-回文子串\"><a href=\"#回文串-x2F-允许删除n个字符的回文串-x2F-回文子串\" class=\"headerlink\" title=\"回文串&#x2F;允许删除n个字符的回文串&#x2F;回文子串\"></a>回文串&#x2F;允许删除n个字符的回文串&#x2F;回文子串</h3><p>双指针直接判断即可</p>\n<p>发现题解有用Python库函数的做法 虽然简单 但不好</p>\n<p>允许去掉一个字符 最直观的就是一个个试 O(n^2)</p>\n<p>还是用双指针 允许一次出错O(n) 注意到底是移左指针还是右指针 好像不知道？</p>\n<p>思路是对的 但我的实现怎么这么丑啊(原来没看题)</p>\n<p>回文字串这题完全没思路 ，只想到暴力法 O(n^3)</p>\n<p>1.定中心法 但是需要考虑奇数偶数 奇数单中心 偶数双中心 从左到右一次遍历 复杂度O(n^2)</p>\n<p>可以进行统一 观察发现对于n 有2n - 1个情况 对应的li ri 可以找规律 也可以分情况两次循环 manacher算法放弃</p>\n<h3 id=\"删除链表倒数第n个\"><a href=\"#删除链表倒数第n个\" class=\"headerlink\" title=\"删除链表倒数第n个\"></a>删除链表倒数第n个</h3><p>不能随机访问 感觉只能扫一遍统计个数 再扫一遍找到那个删除 注意具体操作的时候在头上加一个根节点可以避免讨论 简称哨兵节点 O(n)</p>\n<p>前后双指针O(n)</p>\n<p>两个常数不一样</p>\n<h3 id=\"链表环的入口\"><a href=\"#链表环的入口\" class=\"headerlink\" title=\"链表环的入口\"></a>链表环的入口</h3><p>可以染色吗？hash_map或者set记录即可  O(n)  需要空间复杂度</p>\n<p>快慢指针(可以计算出圈中剩下的距离就是从开始到入环点的距离) 可以通过公式推出巧妙地结果（完全考数学观察）</p>\n<h3 id=\"双链表的交点\"><a href=\"#双链表的交点\" class=\"headerlink\" title=\"双链表的交点\"></a>双链表的交点</h3><p>set法 时间空间复杂度都是O(m+n)</p>\n<p>显然可以补环 然后转化成环找入口 快慢指针 最后要解环 空间复杂度O(1) 时间复杂度O(m+n)</p>\n<p>双指针法时间复杂度O(m+n) 空间复杂度O(1) </p>\n<h2 id=\"3-23\"><a href=\"#3-23\" class=\"headerlink\" title=\"3.23\"></a>3.23</h2><p>明显的取巧做法肯定就是用list存各个节点 然后分别操作</p>\n<h3 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h3><p>可以使用递归 每次拆一个节点 然后接起来</p>\n<p>可以使用pre post存前后节点 然后迭代反转</p>\n<h3 id=\"链表两数相加（需要反转型）\"><a href=\"#链表两数相加（需要反转型）\" class=\"headerlink\" title=\"链表两数相加（需要反转型）\"></a>链表两数相加（需要反转型）</h3><p>压栈 每次弹栈（本质上还是 用了list）</p>\n<p>反转之后硬做 加完后再反转回来 时间复杂度常数巨高 ！</p>\n<h3 id=\"重排链表\"><a href=\"#重排链表\" class=\"headerlink\" title=\"重排链表\"></a>重排链表</h3><p>快慢指针 拆分然后合并 注意如果是奇数节点一定要将中间的节点归在前面 否则很臭！</p>\n<h2 id=\"3-24\"><a href=\"#3-24\" class=\"headerlink\" title=\"3.24\"></a>3.24</h2><h3 id=\"回文链表\"><a href=\"#回文链表\" class=\"headerlink\" title=\"回文链表\"></a>回文链表</h3><p>可以通过使用list 转化成回文字符串 时间空间复杂度为O(n)</p>\n<p>先正向统计val 顺便反转 然后再重新统计一遍 时间复杂度为O(n)（但是C很大 超时了） 空间复杂度为O(1)</p>\n<p>使用快慢指针 降常数 空间复杂度不变 注意将中间节点放在前面半段 使用guard节点！ 注意特殊处理只有一个节点的情况</p>\n<h3 id=\"三叉链表扁平化\"><a href=\"#三叉链表扁平化\" class=\"headerlink\" title=\"三叉链表扁平化\"></a>三叉链表扁平化</h3><p>利用dfs即可 注意断开处的处理 father涉及到child next  child 涉及到pre 注意将最后的节点返回 递归考察！</p>\n<p>注意看清楚属性名 为什么我属性名写错了他不报错啊！！！</p>\n<h3 id=\"排序的循环链表\"><a href=\"#排序的循环链表\" class=\"headerlink\" title=\"排序的循环链表\"></a>排序的循环链表</h3><p>注意None情况 跑一遍 维护int记录大小 注意非递减 时间O(n) 空间O(1)</p>\n<p>好多坑啊 其实就两种情况 一种是中间能插入 能被夹起来 一种是小于等于&#x2F;大于等于所有的值 只需要在判第一种的时候记下最大的节点就好 第二种情况一定是在这个节点后面 注意一定是从头开始判断（而不是head.next开始） 第二次再到头的时候表示走了一个轮回</p>\n<h2 id=\"3-25\"><a href=\"#3-25\" class=\"headerlink\" title=\"3.25\"></a>3.25</h2><h3 id=\"插入-删除-随机访问都是O-1-的容器\"><a href=\"#插入-删除-随机访问都是O-1-的容器\" class=\"headerlink\" title=\"插入 删除 随机访问都是O(1)的容器\"></a>插入 删除 随机访问都是O(1)的容器</h3><p>显然插入删除可以通过hashmap解决 （显然有浪费内存 但是hashset不能解决） 随机访问肯定用randint 但是hashmap不能随机访问 这样就是O(n) getrandom</p>\n<p>答案是要借助list进行随机访问！</p>\n<p>可以在map中存入kv &#x3D; (val,index) 每次pop的时候将元素移入末尾 在pop 这样是O(1) 注意pop数组的时候被交换的元素的index要发生相应改变</p>\n<h3 id=\"LRU容器的构造\"><a href=\"#LRU容器的构造\" class=\"headerlink\" title=\"LRU容器的构造\"></a>LRU容器的构造</h3><p>map + list</p>\n<p>list当作队列使用 一旦被get或者put（更改值或者生成新的kv对） 该kv对应的k要到list末尾 另注意容量问题 建议分开写！ 不要怕代码重复 不然很容易出 bug 优化是写完之后的事情！</p>\n<p>list的remove key 复杂度是O(n) 字典remove O(1) listpop(0)O(n) 关键慢在queue删除元素上 </p>\n<p>考虑使用链表 map改为存储 key  ，node 删除queue节点 添加 移动都可以在O(1)内完成</p>\n<p>python 这个pre 和prev真的是有毒了! 多变量赋值 连续赋值遇到指针千万别用</p>\n<h3 id=\"变位词的判断\"><a href=\"#变位词的判断\" class=\"headerlink\" title=\"变位词的判断\"></a>变位词的判断</h3><p>遍历一遍 在比较的同时 统计map 最后再比较map 时间复杂度O(n) 注意变位词的定义 需要至少有一个字符不一样</p>\n<p>貌似还有排序的做法 算了吧至少O(nlogn)了</p>\n<h2 id=\"3-26\"><a href=\"#3-26\" class=\"headerlink\" title=\"3.26\"></a>3.26</h2><h3 id=\"变位词分组\"><a href=\"#变位词分组\" class=\"headerlink\" title=\"变位词分组\"></a>变位词分组</h3><p>只出现小写字母 应该用hashmap来表示kv 每次比较时间复杂度O(C) 空间复杂度O(n)</p>\n<p>需要分组 还需要建立kv表组 一次遍历O(n) group中比较需要O(n) 共O(n^2) 很麻烦</p>\n<p>原因就是不能一把看出 两个词是不是变位词 可以考虑对单个str排序（这样可以一次看出） 或是 使用char次数作为键</p>\n<h3 id=\"外星语言\"><a href=\"#外星语言\" class=\"headerlink\" title=\"外星语言\"></a>外星语言</h3><p>先把order搞成hash表 不要求输出答案 应该只用两两check O(n^2) （？？ 为什么要两两chekc 应该check一遍就够了 注意是验证是否有序！ 不是排序 验证怎么可能比排序时间复杂度还高？）</p>\n<p> 注意空集的优先级 比首字母还小</p>\n<h3 id=\"最小时间差\"><a href=\"#最小时间差\" class=\"headerlink\" title=\"最小时间差\"></a>最小时间差</h3><p>先排序O(nlogn) 然后O(n)遍历 计算最小的diff 注意最后可能会拼接起来注意首末 注意是个环 大于720 可以取另一半 （首元素到末尾可以避免讨论）</p>\n<p>优化 注意到只有1440个时间点 如果长度超过则返回0 将首元素再加到末尾 可以避免冗余代码</p>\n<h2 id=\"3-27\"><a href=\"#3-27\" class=\"headerlink\" title=\"3.27\"></a>3.27</h2><h3 id=\"逆波兰表达式\"><a href=\"#逆波兰表达式\" class=\"headerlink\" title=\"逆波兰表达式\"></a>逆波兰表达式</h3><p>很简单的stack题 就是要注意是保留整数部分</p>\n<h3 id=\"小行星相撞\"><a href=\"#小行星相撞\" class=\"headerlink\" title=\"小行星相撞\"></a>小行星相撞</h3><p>完全没有看出是单调栈 我的思路是从末尾开始处理 就很难看出是单调栈了 导致讨论很复杂很难做</p>\n<p>如果从左向右处理就是单调栈！看出来就结束了 注意给标记表示planet是否还需要append进去</p>\n<p>最多相撞O(n)次 循环O(n)时间复杂度是O(n)</p>\n<h3 id=\"上升温度\"><a href=\"#上升温度\" class=\"headerlink\" title=\"上升温度\"></a>上升温度</h3><p>就是找当天之后最短距离几天温度会上升 用单调栈解决即可 每次拿到新的温度 如果更小那么就可以将栈顶弹掉 保持单调栈 此处为单调递减 小于等于就入栈 注意输出的时候需要找到对应的index 所以index和value要打包为turple入栈 </p>\n<h2 id=\"3-28\"><a href=\"#3-28\" class=\"headerlink\" title=\"3.28\"></a>3.28</h2><p>单调栈的题目 先确定是上升还是下降 什么情况下开始弹栈</p>\n<h3 id=\"最大的矩阵面积\"><a href=\"#最大的矩阵面积\" class=\"headerlink\" title=\"最大的矩阵面积\"></a>最大的矩阵面积</h3><p>隐约感到是单调栈了 没想通原理 注意本质是在遍历高度 然后找两边最远的index 每次出现更小的就是最远距离 左边靠着的就是左边的最远index 可以反证</p>\n<p>时空O(n)</p>\n<h3 id=\"矩阵中最大的矩形\"><a href=\"#矩阵中最大的矩形\" class=\"headerlink\" title=\"矩阵中最大的矩形\"></a>矩阵中最大的矩形</h3><p>和单调栈有关系？</p>\n<p>遍历行 统计高度 就可以看成矩阵面积最大值了</p>\n<p>时间复杂度O(n^2) 空间O(n)</p>\n<h3 id=\"滑动窗口平均值\"><a href=\"#滑动窗口平均值\" class=\"headerlink\" title=\"滑动窗口平均值\"></a>滑动窗口平均值</h3><p>显然用队列 感觉这题好像都不用用队列啊</p>\n<p>写java的时间是python的十几倍 坑也是 </p>\n<p>注意要转化成double</p>\n<h3 id=\"最近请求次数\"><a href=\"#最近请求次数\" class=\"headerlink\" title=\"最近请求次数\"></a>最近请求次数</h3><p>简单 每次无脑offer 然后看首是否&lt; t - 3000循环poll</p>\n<h3 id=\"二叉树添加节点\"><a href=\"#二叉树添加节点\" class=\"headerlink\" title=\"二叉树添加节点\"></a>二叉树添加节点</h3><p>简单 队列处理 每次offer两个节点 队首的节点poll出去 cnt 区分左右节点</p>\n<p>如果某节点已经有两个子节点那么可以poll 再peek下一个节点 否则只能不处理</p>\n<p>注意返回的是val 不是node</p>\n<p>也可以不用双队列 用l记录需要pop出的节点个数 Python可以直接len(l)记录下循环次数</p>\n<p>dfs：二叉树层数就是ans的个数 用depth记录深度 当来到该深度时就对ans[depth]进行更新最大值</p>\n<h2 id=\"3-29\"><a href=\"#3-29\" class=\"headerlink\" title=\"3.29\"></a>3.29</h2><p>二叉树先中后序遍历 取决于想知道的信息</p>\n<p>前中后序遍历递归很简单 可能考迭代</p>\n<p>注意使用stack前中 基本一样 遇到新节点就入栈 优先左边 区别在于访问的时间 前序在入栈前访问 中在出栈时访问 入栈是为了访问该节点的的右节点</p>\n<p>注意后续遍历弹栈弹根的时候有两种情况 1.右子树有但还没遍历 2.右子树没有或者已经遍历了 prev记录上一个节点即可</p>\n<h3 id=\"最左最深的节点的val\"><a href=\"#最左最深的节点的val\" class=\"headerlink\" title=\"最左最深的节点的val\"></a>最左最深的节点的val</h3><p>简单 bfs 或者 dfs 如果用bfs注意不能poll 由于题目要求最左最下 显然符合dfs特征</p>\n<p>每一层只有一一个答案 先dfs左边 一旦填了答案就不能改了 显然dfs的速度是要更快的（每层val出现的位置是确定的） bfs要操作很多队列 但是bfs 不用递归很多层 空间复杂度应该小</p>\n<h3 id=\"二叉树剪枝\"><a href=\"#二叉树剪枝\" class=\"headerlink\" title=\"二叉树剪枝\"></a>二叉树剪枝</h3><p>感觉是后序遍历 下面的子树做标记 符合条件就扔掉</p>\n<p>1.注意flag的传递 （如果0藏在中间是不可以prune的）</p>\n<p>2.注意root的特殊处理</p>\n<h3 id=\"序列化和反序列化\"><a href=\"#序列化和反序列化\" class=\"headerlink\" title=\"序列化和反序列化\"></a>序列化和反序列化</h3><p>每太弄懂题目  BFS比较简单 由题目知只有第一个None才序列化 不是完全二叉树</p>\n<p>可以只要编码解码顺序堆起来即可 一共有四种做法</p>\n<p>一个deque处理BFS ans放答案</p>\n<p>时空复杂度都是O(n)</p>\n<p>注意bfs dfs时空复杂度都是O(n)</p>\n<p>！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！Todo 前序遍历实现</p>\n<h3 id=\"根节点到叶节点的和\"><a href=\"#根节点到叶节点的和\" class=\"headerlink\" title=\"根节点到叶节点的和\"></a>根节点到叶节点的和</h3><p>可以用dfs和bfs bfs要有暂存  要有双队列 或者用turple实现</p>\n<p>时空复杂度都是O(n)</p>\n<p>注意规定好累加值的求法！ 规定扔下去的累加值已经 乘10了 如果还需要进下一层需要自己再乘10  注意只要有一个子树 就不用加本身的value了 因为已经放到下一层计算了</p>\n<h2 id=\"3-30\"><a href=\"#3-30\" class=\"headerlink\" title=\"3.30\"></a>3.30</h2><h3 id=\"展平二叉树\"><a href=\"#展平二叉树\" class=\"headerlink\" title=\"展平二叉树\"></a>展平二叉树</h3><p>思路一样老de不出来 关键需要讨论左孩子位考虑使用dummy（简单多了！保证了prev永不为null）</p>\n<p>中序遍历存列表 时空O(n)</p>\n<p>不用链表 但是有递归 空间复杂度也是O(n)</p>\n<h3 id=\"二叉搜索树中序后继\"><a href=\"#二叉搜索树中序后继\" class=\"headerlink\" title=\"二叉搜索树中序后继\"></a>二叉搜索树中序后继</h3><p>直接装ArrayList 时空复杂度O(n) 时间常数更大</p>\n<p>中序遍历找到p flag亮 然后直接返回 主函数返回null</p>\n<p>注意是二叉搜索树！</p>\n<p>如果当前cur.val &gt; p 就向左子树找 并且将res 指向当前节点 反之 向右子树找</p>\n<h2 id=\"3-31\"><a href=\"#3-31\" class=\"headerlink\" title=\"3.31\"></a>3.31</h2><h3 id=\"连续子数组最大和\"><a href=\"#连续子数组最大和\" class=\"headerlink\" title=\"连续子数组最大和\"></a>连续子数组最大和</h3><p>dp 可以优化空间</p>\n<h3 id=\"大于等于节点的值之和\"><a href=\"#大于等于节点的值之和\" class=\"headerlink\" title=\"大于等于节点的值之和\"></a>大于等于节点的值之和</h3><p>看懂了就很简单 是一种中序遍历 反转过的 注意每个节点不一定用list存 记录sum即可（时空都变好 量级没变）</p>\n<p>时空O(n) 涉及到递归 很难优化空间了(morris？) 直接用链表存得了 </p>\n<h3 id=\"树迭代器（中序）\"><a href=\"#树迭代器（中序）\" class=\"headerlink\" title=\"树迭代器（中序）\"></a>树迭代器（中序）</h3><p>应该用stack实现中序遍历 stack最多含O(h)个节点 从左子树走一直到最深 hasNext直接查stack是否空 next弹栈 注意弹完还需要继续走左子树</p>\n<p>next均摊时间复杂度为O(1) hasNext为O(1)</p>\n<h3 id=\"二叉搜索树两数之和\"><a href=\"#二叉搜索树两数之和\" class=\"headerlink\" title=\"二叉搜索树两数之和\"></a>二叉搜索树两数之和</h3><p>最笨的做法扁平化(有序) 再遍历（可二分查找 也可hash 也可双指针） 双指针应该是最好的</p>\n<p>最快迭代中序遍历 维护hash （还是没有充分利用二叉搜索树的性质）</p>\n<h3 id=\"值和index差小于limitation\"><a href=\"#值和index差小于limitation\" class=\"headerlink\" title=\"值和index差小于limitation\"></a>值和index差小于limitation</h3><p>和树有关？只想到暴力法</p>\n<p>利用TreeSet 本质红黑树 动态维护min(n,k)空间大小的红黑树</p>\n<p>插入删除查找的时间复杂度都是logc c为容量</p>\n<p>一次遍历 总时间复杂度O(nlogc) c为容量</p>\n<p>桶 划分n个桶（区间） 注意桶大小应该是最大差+ 1 注意正负数的处理 正数直接用x &#x2F; w w为桶大小 负数为 (x - 1) &#x2F;w - 1</p>\n<p>每遇到一个数标记对应区间 再次遇到就说明满足条件 没再次遇到就检查左右两个桶 如果有一个被标记也满足条件</p>\n<p>空间复杂度也是O(c) c为容量</p>\n<p>时间复杂度为O(n)</p>\n<p>小心类型转换 按照顺序来 看每一步有无隐式转换</p>\n<h2 id=\"4-3\"><a href=\"#4-3\" class=\"headerlink\" title=\"4.3\"></a>4.3</h2><h3 id=\"日程表\"><a href=\"#日程表\" class=\"headerlink\" title=\"日程表\"></a>日程表</h3><p>区间怎么判重啊？ 没思路</p>\n<p>用TreeMap 包含KV的红黑树(与TreeSet的关系类似于HashMap 和 HashSet)</p>\n<p>单次时间复杂度O(logn) 空间复杂度O(n)</p>\n<h3 id=\"topK问题\"><a href=\"#topK问题\" class=\"headerlink\" title=\"topK问题\"></a>topK问题</h3><p>注意是最大流 需要一直更新</p>\n<p>优先队列解决</p>\n<h3 id=\"频率最高的topK\"><a href=\"#频率最高的topK\" class=\"headerlink\" title=\"频率最高的topK\"></a>频率最高的topK</h3><p>注意此题不会一直更新</p>\n<p>先统计HashMap 然后 堆排序复杂度O(nlogk) 空间O(n)</p>\n<p>堆里面怎么放Entry啊 用int[] {1,2,3} 进行模拟!</p>\n<p>注意排序的实现方式java</p>\n<p>还有一种方法是利用快排分治思想 时间复杂度为O(n) 最差O(n^2) 利用random取pivot </p>\n<h3 id=\"和最小的K个数对\"><a href=\"#和最小的K个数对\" class=\"headerlink\" title=\"和最小的K个数对\"></a>和最小的K个数对</h3><p>二叉堆 简单做法 暴力 时间复杂度O(k^2logk) 堆容量为k</p>\n<p>但是nums1 nums2 有序！</p>\n<p> 如果(0,0)是最小的index对 那么(1,0) 或(0,1)一定是倒数第二小的 以此类推 可以利用 类似bfs的方式不断搜索 每轮poll一次 这个一定是该轮最小的 k轮结束 每轮不断扩散 本质是贪心</p>\n<p>可能有重复 有两种去重方式：</p>\n<p>1.hashset做标记 （速度太慢）</p>\n<p>2.规定加入顺序 先把一侧全部加入 后面index只增加另一部分</p>\n<p>时间复杂度O(klogk) </p>\n<p>注意由于规定了heap排序方式需要使用nums1 nums2 offer之前需要考虑index是否越界</p>\n<h2 id=\"4-4\"><a href=\"#4-4\" class=\"headerlink\" title=\"4.4\"></a>4.4</h2><p>只要涉及到给prefix 求出具体的相关单词的就需要用前缀树</p>\n<p>否则可以考虑hash 暴力</p>\n<h3 id=\"前缀树\"><a href=\"#前缀树\" class=\"headerlink\" title=\"前缀树\"></a>前缀树</h3><p>字典树 26个字母节点 为了避免把某一单词的前缀认成单词 需要使用isEnd标记 字母节点可以用数组存</p>\n<p>时间复杂度 O(S) S为当次操作字符串长度</p>\n<p>空间复杂度O(T C) T为所有字符串的长度和 C为26 </p>\n<h3 id=\"替换单词\"><a href=\"#替换单词\" class=\"headerlink\" title=\"替换单词\"></a>替换单词</h3><p>模板题</p>\n<p>字典树 注意设置isEnd 遇到isEnd就替换 没遇到节点就结束 不替换</p>\n<p>注意用StringBuilder 不要自己去拼接 可以快3倍</p>\n<h3 id=\"神奇字典\"><a href=\"#神奇字典\" class=\"headerlink\" title=\"神奇字典\"></a>神奇字典</h3><p>没思路 不知道hello hallo怎么处理</p>\n<p>DFS暴搜 记录flag 好难写啊 DFS这么搜 感觉复杂度好高啊 还没有暴力好O(nC) C为字符串长度 （DFS一个节点会被访问多次 暴力比较最多访问一次）</p>\n<p>暴力时用cnt统计不同的字符 cnt &#x3D;&#x3D; 1满足</p>\n<h3 id=\"最短单词编码\"><a href=\"#最短单词编码\" class=\"headerlink\" title=\"最短单词编码\"></a>最短单词编码</h3><p>压缩空间 编码要最短</p>\n<p>注意返回的是编码长度 暴力hashset 时间O(\\sum wi^2) hash值计算考虑 C为字符串长度 空间O(\\sum wi)</p>\n<p>前缀树也可用 注意可能重复经过叶节点 要不断修改flag 最终统计叶节点长度 时间O(\\sum wi) 空间O(26 \\sum wi)</p>\n<h3 id=\"根据前缀返回相关单词和\"><a href=\"#根据前缀返回相关单词和\" class=\"headerlink\" title=\"根据前缀返回相关单词和\"></a>根据前缀返回相关单词和</h3><p>暴力肯定能做 时间复杂度O(\\sum wi) 空间O(n)</p>\n<p>前缀树 接近O(\\sum wi) O(26 \\sum wi) 感觉时间上可能会快</p>\n<h3 id=\"最大异或\"><a href=\"#最大异或\" class=\"headerlink\" title=\"最大异或\"></a>最大异或</h3><p>果然超时了hhh 多了一个数量级</p>\n<ul>\n<li><p>肯定最高位是1要好 利用前缀树遍历从高位到低位放进树中 如果该位是1 去找0 如果没有就只能去1 注意 如果存在路径 说明存在这个数 小心遍历方式 不要重复 本质是利用分支加速 贪心</p>\n</li>\n<li><p>利用公式 a ^ b &#x3D; c &lt;–&gt; a ^ c &#x3D; b 假设答案中该位为1 看成不成立 贪心</p>\n<p>时间都是O(nlogC) logC &#x3D;&#x3D; 31</p>\n<p>空间hash为O(n) 前缀树为O(nlogC)</p>\n</li>\n</ul>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><p>如果一开始不知道问题的解是什么，但是知道解的范围是多少，则\t可以尝试在这个范围内应用二分查找；<br>应用这种思路的关键在于两点：<br>确定解的范围，即解的可能的最小值和最大值；<br>在发现中间值不是解之后如何判断接下来应该在解的范围的前半部分还是后半部分查找。<br>只有每次将查找范围减少一半时才能应用二分查找算法。</p>\n<p>必须要是有序的！！！！！！！</p>\n<p>边界有点恶心 注意区分区间定义情况[a,b) 注意if</p>\n<p>迭代法实现类似</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">&#x2F;&#x2F;[a,b)闭区间法 官方推荐\n&#x2F;&#x2F;收缩上界 lowerbound 找target该插入的头部位置\nclass Solution &#123;\n    public int searchInsert(int[] nums, int target) &#123;\n        &#x2F;&#x2F;迭代法 [a,b) &amp;&amp; 收缩上界\n        int left &#x3D; 0;\n        int right &#x3D; nums.length;\n        while (left &lt; right) &#123;\n            int mid &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] &gt;&#x3D; target) &#123;\n                right &#x3D; mid;\n            &#125; else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;\n&#x2F;&#x2F;收缩下界\n&#x2F;&#x2F;1找第一个大于target的index\nclass Solution &#123;\n    public int searchInsert(int[] nums, int target) &#123;\n        &#x2F;&#x2F;迭代法 [a,b) &amp;&amp; 收缩下界\n        int left &#x3D; 0;\n        int right &#x3D; nums.length;\n        while (left &lt; right) &#123;\n            int mid &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] &gt; target) &#123;\n                right &#x3D; mid;\n            &#125; else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;\n&#x2F;&#x2F;2找target该插入的末尾位置\nclass Solution &#123;\n    public int searchInsert(int[] nums, int target) &#123;\n        &#x2F;&#x2F;迭代法 [a,b) &amp;&amp; 收缩下界\n        int left &#x3D; 0;\n        int right &#x3D; nums.length;\n        while (left &lt; right) &#123;\n            int mid &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] &gt; target) &#123;\n                right &#x3D; mid;\n            &#125; else &#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left - 1;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"山峰数组\"><a href=\"#山峰数组\" class=\"headerlink\" title=\"山峰数组\"></a>山峰数组</h3><p>O(n)遍历一遍</p>\n<p>O(logn)二分查找</p>\n<h3 id=\"排序数组只出现一次的数字\"><a href=\"#排序数组只出现一次的数字\" class=\"headerlink\" title=\"排序数组只出现一次的数字\"></a>排序数组只出现一次的数字</h3><p>已经有序！ 二分check两边即可 分情况 隐隐感觉有关系 但没想到分奇偶…</p>\n<p>trick:偶数和1异或为偶数+1 奇数和1异或为奇数-1</p>\n<h3 id=\"加权随机index\"><a href=\"#加权随机index\" class=\"headerlink\" title=\"加权随机index\"></a>加权随机index</h3><p>和二分查找有什么关系？</p>\n<p>划分区间 几何分布 随机出的x快速判定区间index可以利用二分法（区间可以用前缀和表示 前缀和有序）这个地方前缀和没有0</p>\n<p>初始化O(n) 二分O(logn)</p>\n<p>空间O(n)</p>\n<h3 id=\"求平方根\"><a href=\"#求平方根\" class=\"headerlink\" title=\"求平方根\"></a>求平方根</h3><p>看复杂度是sqrt(n)?和二分查找有关？</p>\n<p>暴力法小心溢出</p>\n<p>数轴上二分查找 注意三套模板用哪个 （注意都需要将&#x3D;&#x3D;合并进去 即只有两个branch)</p>\n<h3 id=\"吃香蕉\"><a href=\"#吃香蕉\" class=\"headerlink\" title=\"吃香蕉\"></a>吃香蕉</h3><p>肯定需要先排序 至少O(nlogn)</p>\n<p>注意left从1开始</p>\n<h2 id=\"4-5\"><a href=\"#4-5\" class=\"headerlink\" title=\"4.5\"></a>4.5</h2><p>排序10种排序方法</p>\n<h3 id=\"排序区间\"><a href=\"#排序区间\" class=\"headerlink\" title=\"排序区间\"></a>排序区间</h3><p>按照start和end顺序排列 然后遍历合并 不断更换当前check的区间</p>\n<p>注意检查末尾是否超过cur末尾 排序 时间 O(nlogn) 排序空间递归用了O(logn)</p>\n<h3 id=\"特殊condition排序\"><a href=\"#特殊condition排序\" class=\"headerlink\" title=\"特殊condition排序\"></a>特殊condition排序</h3><p>暴力做即可 可以堆排序或者快排</p>\n<h3 id=\"TopK\"><a href=\"#TopK\" class=\"headerlink\" title=\"TopK\"></a>TopK</h3><p>堆排序即可</p>\n<h3 id=\"单链表排序\"><a href=\"#单链表排序\" class=\"headerlink\" title=\"单链表排序\"></a>单链表排序</h3><p>逃课就存节点 快排</p>\n<p>要空间感觉可以用冒泡</p>\n<h3 id=\"合并有序链表\"><a href=\"#合并有序链表\" class=\"headerlink\" title=\"合并有序链表\"></a>合并有序链表</h3><p>归并</p>\n<p>回溯！！！！！！！！！！！！！！！！！！！！！</p>\n<p>数据量小的直接暴搜DFS</p>\n<p>可以剪枝优化</p>\n<p>可以记忆化搜索</p>\n<h3 id=\"所有子集\"><a href=\"#所有子集\" class=\"headerlink\" title=\"所有子集\"></a>所有子集</h3><p>取或者不取 时间复杂度O(2^n)</p>\n<h3 id=\"求组合数\"><a href=\"#求组合数\" class=\"headerlink\" title=\"求组合数\"></a>求组合数</h3><p>$$C_n^k$$型，对每一位进行遍历，注意记录已选数字个数</p>\n<p>可以进行剪枝（如果所有数字都选了还是不能到k个这种情况）</p>\n<h3 id=\"允许重复选择元素\"><a href=\"#允许重复选择元素\" class=\"headerlink\" title=\"允许重复选择元素\"></a>允许重复选择元素</h3><p>用DFS回溯 暴力遍历</p>\n<p>去重？</p>\n<h3 id=\"不允许重复选择元素\"><a href=\"#不允许重复选择元素\" class=\"headerlink\" title=\"不允许重复选择元素\"></a>不允许重复选择元素</h3><p>注意idx的处理</p>\n<h3 id=\"数组元素全排列-含重复元素-x2F-不含重复元素\"><a href=\"#数组元素全排列-含重复元素-x2F-不含重复元素\" class=\"headerlink\" title=\"数组元素全排列(含重复元素&#x2F;不含重复元素)\"></a>数组元素全排列(含重复元素&#x2F;不含重复元素)</h3><p>不含重复元素：注意flag做标记 注意每次进入dfs都是顺序选取元素如果被flag标记 就找下一个 直到找满</p>\n<p>含重复元素：set去重 效率很低（还要内部排序）</p>\n<p>对元素集合进行排序，相同元素会聚集在一起，对于这些相同元素每次保证如果前面的没选取 后面的就不选取 （如果选取会重复）即可去重</p>\n<h3 id=\"生成匹配的括号\"><a href=\"#生成匹配的括号\" class=\"headerlink\" title=\"生成匹配的括号\"></a>生成匹配的括号</h3><p>按照左右括号的数量回溯 想不到…</p>\n<p>left &lt; n,right &lt; left</p>\n<h3 id=\"分割回文子串\"><a href=\"#分割回文子串\" class=\"headerlink\" title=\"分割回文子串\"></a>分割回文子串</h3><p>用一个函数判字符串是否为回文串 可以做记忆化搜索</p>\n<p>固定头部 移动尾部进行回溯即可 （答案不用去重）</p>\n<h3 id=\"按条件分割字符串\"><a href=\"#按条件分割字符串\" class=\"headerlink\" title=\"按条件分割字符串\"></a>按条件分割字符串</h3><p>按index分割 注意剪枝</p>\n<h2 id=\"4-17\"><a href=\"#4-17\" class=\"headerlink\" title=\"4.17\"></a>4.17</h2><h3 id=\"TopK问题\"><a href=\"#TopK问题\" class=\"headerlink\" title=\"TopK问题\"></a>TopK问题</h3><p>1.大小为K的堆</p>\n<p>2.快速选择法 注意pivot的选取需要随机 每次选一个后和最后的那个元素交换 然后按照正常的partition做</p>\n<h1 id=\"三、Top100\"><a href=\"#三、Top100\" class=\"headerlink\" title=\"三、Top100\"></a>三、Top100</h1><h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h2><p>暴力n^2 </p>\n<p>排序 二分查找 nlogn 但是index已经变了 不是很好搞</p>\n<p>hash表 O(n) S(n)</p>\n<h2 id=\"2-链表求和\"><a href=\"#2-链表求和\" class=\"headerlink\" title=\"2.链表求和\"></a>2.链表求和</h2><p>开个新链表 以最长的为基准 求和进位即可</p>\n<h2 id=\"3-无重复最长子串\"><a href=\"#3-无重复最长子串\" class=\"headerlink\" title=\"3.无重复最长子串\"></a>3.无重复最长子串</h2><p>双指针+HashSet O(n) S(n)</p>\n<p>用滑动窗口 ：本质实在优化index的枚举 本来是n^2 -&gt; n</p>\n<p>注意可能进入不了else while循环外面要套一次更新</p>\n<h2 id=\"4-两个正序数组中位数\"><a href=\"#4-两个正序数组中位数\" class=\"headerlink\" title=\"4.两个正序数组中位数\"></a>4.两个正序数组中位数</h2><p>暴力合并O(m+n)</p>\n<p>中位数为 m+n+1 &#x2F;2  m+n+2&#x2F;2 对应的数的平均数</p>\n<p>设为K</p>\n<p>在两个数组里寻找第K个数 分别看第K&#x2F;2个 如果num1小于num2说明 第K个绝对不可能在num1的K&#x2F;2个里 可以删除 不断折半K 最终K为1的时候比较首元素即可 某个数组已经被剔完了 直接找另一个数组的第K个即可(为了统一 优雅可以直接另被剔完的数组对应的元素为无穷大)</p>\n<h2 id=\"5-回文串\"><a href=\"#5-回文串\" class=\"headerlink\" title=\"5.回文串\"></a>5.回文串</h2><p>动态规划</p>\n<p>dp[i,j] 记录的是能不能成为回文串 不能记录最大长度</p>\n<p>因为如果记录最大长度的话不能确定是否是子串（相邻）</p>\n<h2 id=\"6-Z串\"><a href=\"#6-Z串\" class=\"headerlink\" title=\"6.Z串\"></a>6.Z串</h2><p>直接模拟 注意不要越界 while秒</p>\n<h2 id=\"7-整数反转\"><a href=\"#7-整数反转\" class=\"headerlink\" title=\"7.整数反转\"></a>7.整数反转</h2><p>用最大的MAX_VALUE的1&#x2F;10进行判断 (Integer.MAX_VALUE:2147483647)</p>\n<p>感觉只能暂存 然后特判</p>\n<h2 id=\"51-52-N皇后\"><a href=\"#51-52-N皇后\" class=\"headerlink\" title=\"51.52.N皇后\"></a>51.52.N皇后</h2><p>bitmap状态压缩空间复杂度不过还是O(n）因为要递归</p>\n<h2 id=\"105-106-二叉树重构\"><a href=\"#105-106-二叉树重构\" class=\"headerlink\" title=\"105.106.二叉树重构\"></a>105.106.二叉树重构</h2><p>已知前中 后中都能唯一确定二叉树</p>\n<p>但是已知前后不能 因为最后叶节点的时候不能确定到底是左孩子还是右孩子</p>\n<p>两种不同的关键是当作左子树还是右子树找根</p>\n<p>由于不会有重复元素 可以用hashmap加速</p>\n<p>注意：</p>\n<p>三种题都可以每次取一个元素 (L &lt; R) 终止条件L &#x3D;&#x3D; R </p>\n<p>如果相等说明没有子树节点了 该节点就是根节点 直接返回就好</p>\n<p>注意下标的变化</p>\n<h1 id=\"四、Leetcode75\"><a href=\"#四、Leetcode75\" class=\"headerlink\" title=\"四、Leetcode75\"></a>四、Leetcode75</h1><h2 id=\"205-同构字符串\"><a href=\"#205-同构字符串\" class=\"headerlink\" title=\"205. 同构字符串\"></a>205. 同构字符串</h2><p>Hashmap遍历 O(n) O(l) l:字符集的大小</p>\n<h2 id=\"290-单词规律\"><a href=\"#290-单词规律\" class=\"headerlink\" title=\"290. 单词规律\"></a>290. 单词规律</h2><p>与205完全相同 需要用空格分割t</p>\n<h2 id=\"290-单词规律II\"><a href=\"#290-单词规律II\" class=\"headerlink\" title=\"290. 单词规律II\"></a>290. 单词规律II</h2><p>缺少了空格分隔 暴力</p>\n<p>暴力回溯 （自己划分空格） 1h</p>\n<p>很恶心:</p>\n<p>1.结束条件 必须同时结束 p 和 s</p>\n<p>2.注意区分两个map if else写详细 p-&gt;s是强制的 s-&gt;p s是可变的</p>\n<h2 id=\"392-判断子序列\"><a href=\"#392-判断子序列\" class=\"headerlink\" title=\"392. 判断子序列\"></a>392. 判断子序列</h2><p>1.两个指针 O(n+m)  如果有k个就是O(k(n+m))</p>\n<p>2.DP 优化为O(kn + m) 空间O(m)</p>\n<h2 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21. 合并两个有序链表\"></a>21. 合并两个有序链表</h2><p>1.正常拼接就好 3个while 都要注意p的移动O(m+n)</p>\n<p>2.注意立哨兵 注意判断开始的情况</p>\n<h2 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a>206. 反转链表</h2><p>迭代：</p>\n<p>1.注意while条件cur !&#x3D; null 说明之后还有一个 进while再next</p>\n<p>递归：</p>\n<p>1.注意每次拆分一个节点 递归解法会天然用栈储存</p>\n<p>2.注意解环</p>\n<p>3.返回值就是最终答案</p>\n<h2 id=\"876-链表的中间结点\"><a href=\"#876-链表的中间结点\" class=\"headerlink\" title=\"876. 链表的中间结点\"></a>876. 链表的中间结点</h2><p>快慢指针：这个题就不要用dummy 因为对于偶数点要靠后的Node</p>\n<h2 id=\"142-环形链表-II\"><a href=\"#142-环形链表-II\" class=\"headerlink\" title=\"142. 环形链表 II\"></a>142. 环形链表 II</h2><p>快慢指针：如果有环就在里面转 总能遇到</p>\n<p>求出入口节点:有个很巧的公式 注意环的性质</p>\n<h2 id=\"121-买卖股票的最佳时机\"><a href=\"#121-买卖股票的最佳时机\" class=\"headerlink\" title=\"121. 买卖股票的最佳时机\"></a>121. 买卖股票的最佳时机</h2><p>注意记录遍历过的数中最大的实际上就是动态规划 </p>\n<p>实际上不用动态规划 时间复杂度O(n) 空间O(1)</p>\n<h2 id=\"409-最长回文串\"><a href=\"#409-最长回文串\" class=\"headerlink\" title=\"409. 最长回文串\"></a>409. 最长回文串</h2><p>遍历 收集 再来一个最大的基数 O(n) O(L)</p>\n<p>注意字符可以不用完</p>\n<p>用数组可以加速</p>\n<h2 id=\"589-N-叉树的前序遍历\"><a href=\"#589-N-叉树的前序遍历\" class=\"headerlink\" title=\"589. N 叉树的前序遍历\"></a>589. N 叉树的前序遍历</h2><p>感觉iter做法比较麻烦 每个node都要打标记 (用hashmap帮忙打标记)</p>\n<p>注意弹出的时候要抹掉所有children的标记</p>\n<p>或者倒序入栈</p>\n<p>recur有context帮忙打标记</p>\n<h1 id=\"常用算法\"><a href=\"#常用算法\" class=\"headerlink\" title=\"常用算法\"></a>常用算法</h1><h2 id=\"二分查找-1\"><a href=\"#二分查找-1\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h2><p>1.注意规定[l,r) 考虑每次lr的能否取到端点</p>\n<p>2.如果存在相同的值注意收缩上界</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BinarySearch</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//迭代递归的时间复杂度都是O(logn)</span>\n    <span class=\"token comment\">//递归的空间复杂度为O(logn) 迭代为O(1)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">class</span> <span class=\"token class-name\">Search</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">//[l,r)</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">searchIndexIter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> tar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">int</span> mid<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">&lt;</span> r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    mid <span class=\"token operator\">=</span> l <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">-</span> l<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> tar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                        r <span class=\"token operator\">=</span> mid<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                        <span class=\"token comment\">// arrya[mid] &lt; tar</span>\n                        <span class=\"token comment\">//at least mid + 1</span>\n                        l <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">&#125;</span>\n                <span class=\"token punctuation\">&#125;</span>\n                <span class=\"token keyword\">return</span> l<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">searchIndexRec</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> l<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> tar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l <span class=\"token operator\">>=</span> r<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">return</span> l<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n                <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> l <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>r <span class=\"token operator\">-</span> l<span class=\"token punctuation\">)</span> <span class=\"token operator\">>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> tar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token function\">searchIndexRec</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> l<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> tar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token function\">searchIndexRec</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span>mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>r<span class=\"token punctuation\">,</span>tar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token class-name\">Search</span> search <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Search</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> ans <span class=\"token operator\">=</span> search<span class=\"token punctuation\">.</span><span class=\"token function\">searchIndexIter</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ans <span class=\"token operator\">=</span> search<span class=\"token punctuation\">.</span><span class=\"token function\">searchIndexRec</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"八大排序\"><a href=\"#八大排序\" class=\"headerlink\" title=\"八大排序\"></a>八大排序</h2><h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>1.两重循环</p>\n<p>2.冒泡次数 n</p>\n<p>3.交换次数 n - 1 - i</p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>1.两重循环</p>\n<p>2.选择次数 n</p>\n<p>3.比较次数 n - i</p>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>1.两重循环</p>\n<p>2.插入次数 n - 1</p>\n<p>3.前移注意break </p>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>1.注意规定[l,r]</p>\n<p>2.先直接分割 然后再合并</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>1.注意规定[l,r]</p>\n<p>2.双指针法:最后循环停的时候i &#x3D;&#x3D; j 填入pivot</p>\n<p>3.可以改成迭代 用stack辅助即可</p>\n<p>4.切割即可（注意切割过程中归类） 不用合</p>\n<p>深度是logn 空间复杂度是logn</p>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><p>1.基于统计</p>\n<p>2.注意理解cnt的意义 包括本身前面还有多少个数</p>\n<p>3.注意倒序填写 因为每次填的是最后一个</p>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>1.希尔增量 n &#x2F;2 … 1 希尔增量序列 增量是多少就可以分成多少组</p>\n<p>2.每组组内采用插入排序</p>\n<p>3.shell增量一层while 插入排序实现起始点一层for 终点一层while</p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>优先队列</p>\n<p>二叉树上浮下潜 </p>\n<p>限定容量即可实现topk</p>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><p>1.按照位数进行排序 本质是多轮排序</p>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><p>1.使用映射将N个数分到K个有序桶中</p>\n<p>2.每个桶各自排序</p>\n<h3 id=\"复杂度表\"><a href=\"#复杂度表\" class=\"headerlink\" title=\"复杂度表\"></a>复杂度表</h3><p>冒泡 插入最好的情况就是本身已经有序了</p>\n<p><img src=\"/post/leetcode/img.png\" alt=\"img\"></p>\n<p>基数排序空间复杂度不是O(nk)?</p>\n<h2 id=\"dp\"><a href=\"#dp\" class=\"headerlink\" title=\"dp\"></a>dp</h2><p>自底向上！</p>\n<h3 id=\"线性dp\"><a href=\"#线性dp\" class=\"headerlink\" title=\"线性dp\"></a>线性dp</h3><p>经常考虑末尾元素！！！</p>\n<h4 id=\"单数组（一维）\"><a href=\"#单数组（一维）\" class=\"headerlink\" title=\"单数组（一维）\"></a>单数组（一维）</h4><h5 id=\"和最大的子串-MCSP\"><a href=\"#和最大的子串-MCSP\" class=\"headerlink\" title=\"和最大的子串(MCSP)\"></a>和最大的子串(MCSP)</h5><p>dp[i]定义为包含a[i]的最大子串和 空间复杂度可优化为O(1) 时间复杂度O(n)</p>\n<h4 id=\"双数组（二维）\"><a href=\"#双数组（二维）\" class=\"headerlink\" title=\"双数组（二维）\"></a>双数组（二维）</h4><h5 id=\"最长公共子序列-LCS\"><a href=\"#最长公共子序列-LCS\" class=\"headerlink\" title=\"最长公共子序列(LCS)\"></a>最长公共子序列(LCS)</h5><p>dp[i,j]定义为两个字符串中index分别以i，j结尾的情况，分别考虑最后x_i y_j是否相等</p>\n<p>注意相等时其实有三种情况 但是dp[i-1,j-1] + 1可包括另外两种情况</p>\n<p>时间复杂度O(mn) mn为字符串长度</p>\n<h5 id=\"最长公共子串（LCSP\"><a href=\"#最长公共子串（LCSP\" class=\"headerlink\" title=\"最长公共子串（LCSP)\"></a>最长公共子串（LCSP)</h5><p>相比MCSP要求连续</p>\n<p>dp[i,j]定义为以两字符串中分别以i，j结尾的字符串的最长公共子串的长度 如果不等肯定为0 等则可由dp[i-1,j-1] + 1转移</p>\n<p>复杂度O(mn)</p>\n<h5 id=\"编辑距离\"><a href=\"#编辑距离\" class=\"headerlink\" title=\"编辑距离\"></a>编辑距离</h5><p>考虑删除 插入 替换操作</p>\n<p>dp[i,j] 表示从s_i 转换为 t_j需要的次数</p>\n<h4 id=\"满足条件的最长子序列\"><a href=\"#满足条件的最长子序列\" class=\"headerlink\" title=\"满足条件的最长子序列\"></a>满足条件的最长子序列</h4><p>dp[i] 包含第i个字符且满足条件的最长子序列</p>\n<p>注意答案可能不是最后一个 需要遍历一次找到最大值</p>\n<h3 id=\"背包dp\"><a href=\"#背包dp\" class=\"headerlink\" title=\"背包dp\"></a>背包dp</h3><h4 id=\"01背包问题\"><a href=\"#01背包问题\" class=\"headerlink\" title=\"01背包问题\"></a>01背包问题</h4><p>dp[i,c]考虑前i个物品 使用c容量总共的价格 </p>\n<p>dp[i,c] &#x3D; max(dp[i-1,c] ,dp[i-1,c-v[i]] + p[i])</p>\n<p>只与上一行 以及前面的dp值有关 可以考虑优化空间复杂度 倒着遍历空间容量</p>\n<h4 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h4><p>物品可以取多次</p>\n<p>dp[i,j] &#x3D; max(dp[i-1,j],dp[i-1,j - k v[i]] + k p[i]) </p>\n<p>w从左到右遍历 这样就是可以取多次 （对于第i行 不断考察取不取i物品）</p>\n<h3 id=\"区间dp\"><a href=\"#区间dp\" class=\"headerlink\" title=\"区间dp\"></a>区间dp</h3><h4 id=\"钢条切割\"><a href=\"#钢条切割\" class=\"headerlink\" title=\"钢条切割\"></a>钢条切割</h4><p>dp[i]表示切割长度为i的钢条能获得的最大收益</p>\n<p>dp[i] &#x3D; dp[i - j] +p[j] (j \\in [1,i])</p>\n<h4 id=\"矩阵链乘法\"><a href=\"#矩阵链乘法\" class=\"headerlink\" title=\"矩阵链乘法\"></a>矩阵链乘法</h4><p>两个矩阵(pq,qr)相乘进行的乘法次数pqr</p>\n<p>dp[i,j]表示第i到第j个矩阵顺序运算需要的次数</p>\n<p>dp[i,j] &#x3D; min(dp[i,k] + dp[k + 1,j] + p_i-1p_kp_j)</p>\n<p>i &lt;&#x3D; k &lt; j</p>\n<h3 id=\"树形dp\"><a href=\"#树形dp\" class=\"headerlink\" title=\"树形dp\"></a>树形dp</h3><p>一般是二叉树后序遍历</p>\n<h3 id=\"状压dp\"><a href=\"#状压dp\" class=\"headerlink\" title=\"状压dp\"></a>状压dp</h3><p>状态压缩 一般用二进制表示 这就要求状态转移的选择尽量少</p>\n<h1 id=\"图论\"><a href=\"#图论\" class=\"headerlink\" title=\"图论\"></a>图论</h1><h2 id=\"DFS-x2F-BFS\"><a href=\"#DFS-x2F-BFS\" class=\"headerlink\" title=\"DFS&#x2F;BFS\"></a>DFS&#x2F;BFS</h2><p>注意染色color</p>\n<p>bfs需要使用队列</p>\n<p>时间复杂度都是O(V+E)</p>\n<h2 id=\"环路检测\"><a href=\"#环路检测\" class=\"headerlink\" title=\"环路检测\"></a>环路检测</h2><p>利用DFS看是否会遇到队列里的节点（已经遍历过）</p>\n<p>O(V+E)</p>\n<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><p>BFS拿走入度为0的节点 拿走的同时注意修改邻接点的入度</p>\n<p>DFS 按照完成时刻逆序</p>\n<p>O(V+E)</p>\n<h2 id=\"强连通分量\"><a href=\"#强连通分量\" class=\"headerlink\" title=\"强连通分量\"></a>强连通分量</h2><p>点之间可达 注意一个点也是强连通分量</p>\n<p>kosaraju算法：</p>\n<ul>\n<li>反向</li>\n<li>DFS做拓扑排序 完成时间逆序 L</li>\n<li>按照L再进行一次DFS 每次得到的分量就是一个强连通分量</li>\n</ul>\n<p>时间复杂度O(V+E)</p>\n<h2 id=\"最小生成树-MST\"><a href=\"#最小生成树-MST\" class=\"headerlink\" title=\"最小生成树(MST)\"></a>最小生成树(MST)</h2><h3 id=\"Prim\"><a href=\"#Prim\" class=\"headerlink\" title=\"Prim\"></a>Prim</h3><p>优先队列,将节点带着边入队 不断取最小的边</p>\n<p>注意每次poll之后要更新</p>\n<p>O(ElogV + VlogV)</p>\n<h3 id=\"Kruscal\"><a href=\"#Kruscal\" class=\"headerlink\" title=\"Kruscal\"></a>Kruscal</h3><p>并查集 union_set O(logV)</p>\n<p>find_set O(logV)</p>\n<p>create O(1)</p>\n<p>O(ElogE + ElogV)</p>\n<h2 id=\"单源最短路径-dijkstra\"><a href=\"#单源最短路径-dijkstra\" class=\"headerlink\" title=\"单源最短路径(dijkstra)\"></a>单源最短路径(dijkstra)</h2><h3 id=\"dijkstra\"><a href=\"#dijkstra\" class=\"headerlink\" title=\"dijkstra\"></a>dijkstra</h3><p>指定顶点</p>\n<p>本质上是贪心 也用了优先队列 不断更新累计权值</p>\n<p>权值必须非负</p>\n<p>O（VlogV + ElogV) </p>\n<p>注意 dijkstra和prim注意区分</p>\n<h3 id=\"bellman-ford\"><a href=\"#bellman-ford\" class=\"headerlink\" title=\"bellman-ford\"></a>bellman-ford</h3><p>指定顶点</p>\n<p>执行V轮松弛 每次检查E条边 顺序无所谓 （最多V - 1轮 可以全部松弛完）</p>\n<p>如果第n轮还能松弛 说明存在负环 否则求解完毕</p>\n<p>O(VE)</p>\n<h3 id=\"Floyd\"><a href=\"#Floyd\" class=\"headerlink\" title=\"Floyd\"></a>Floyd</h3><p>所有顶点</p>\n<p>可以有负权</p>\n<p>$$<br>dp[k,i,j] &#x3D; min {dp[k - 1,i,j],dp[k - 1,i,k] + dp[k - 1,k,j] }<br>$$</p>\n<h3 id=\"二分图\"><a href=\"#二分图\" class=\"headerlink\" title=\"二分图\"></a>二分图</h3><h1 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h1><h2 id=\"HashSet、HashMap\"><a href=\"#HashSet、HashMap\" class=\"headerlink\" title=\"HashSet、HashMap\"></a>HashSet、HashMap</h2><p>去重&#x2F;判重 空间换时间 遇到需要时间复杂度位O(1)的操作即可用</p>\n<p>前缀和 （一维 二维）</p>\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><p>1.对向双指针</p>\n<h2 id=\"避免判断余数\"><a href=\"#避免判断余数\" class=\"headerlink\" title=\"避免判断余数\"></a>避免判断余数</h2><pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">sum +&#x3D; (pile+speed-1)&#x2F;speed;\n&#x2F;&#x2F;如果pile % speed &#x3D;&#x3D; 0 那么 speed - 1 &#x2F; speed &#x3D; 0\n&#x2F;&#x2F;如果pile % speed !&#x3D; 0 那么 speed 再贡献一个speed 相当于商 +  1\n&#x2F;&#x2F;相比求余数快的离谱<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p><img src=\"/post/leetcode/731089420_1588305614832_8B3B0DD3B151ADA9BD30FB8F52D155CB.png\" alt=\"img\"></p>\n<p>去掉最右边的1 x &amp; (x-1)</p>\n<p>找出最右边的1 x &amp; (-x)</p>\n","text":"leetcode本文主要用来记录自己刷lc的成长过程， 希望大家都能收获理想的offer 😊 input size 时间复杂度 常见算法 1~10 n! 排列 15~20 2^n 组合 10~50 n^4 100~200 n^3 1000~2000 n^2 DP 图问题 10^6...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"learning","slug":"learning","count":5,"path":"api/categories/learning.json"}],"tags":[{"name":"leetcode","slug":"leetcode","count":1,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#leetcode\"><span class=\"toc-text\">leetcode</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%86%9F%E6%82%89%EF%BC%88%E7%AE%80%E5%8D%95%E9%A2%98%EF%BC%89\"><span class=\"toc-text\">一.基本数据结构熟悉（简单题）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%A0%88\"><span class=\"toc-text\">1.栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">1.括号匹配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%B8%A4%E4%B8%AAstack%E5%AE%9E%E7%8E%B0queue\"><span class=\"toc-text\">2.两个stack实现queue</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%B8%A4%E4%B8%AAqueue%E5%AE%9E%E7%8E%B0stack\"><span class=\"toc-text\">3.两个queue实现stack</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%9C%80%E5%B0%8F%E6%A0%88\"><span class=\"toc-text\">4.最小栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%AF%94%E8%BE%83%E9%80%80%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">5.比较退格字符串</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%94%A8stack%E5%AE%9E%E7%8E%B0-%E5%8E%8B%E6%A0%88%E5%87%BA%E6%A0%88\"><span class=\"toc-text\">1.用stack实现 压栈出栈</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95\"><span class=\"toc-text\">2.双指针法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1021-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7\"><span class=\"toc-text\">1021.删除最外层的括号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\"><span class=\"toc-text\">461. 汉明距离</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C\"><span class=\"toc-text\">477.汉明距离总和</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%A0%86\"><span class=\"toc-text\">2.堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#offer-40-%E6%9C%80%E5%B0%8Fk%E7%9A%84%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">offer 40.最小k的个数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#231-2%E7%9A%84%E5%B9%82\"><span class=\"toc-text\">231.2的幂</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F\"><span class=\"toc-text\">1046. 最后一块石头的重量</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%98%9F%E5%88%97\"><span class=\"toc-text\">3.队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#346-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E5%80%BC\"><span class=\"toc-text\">346. 数据流中的移动平均值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1744-%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">4.二叉树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">递归实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">迭代实现</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%89%91%E6%8C%87offer\"><span class=\"toc-text\">二、剑指offer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-17\"><span class=\"toc-text\">3.17</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97%E9%99%A4%E6%B3%95\"><span class=\"toc-text\">位运算除法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95\"><span class=\"toc-text\">二进制加法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#count-1\"><span class=\"toc-text\">count 1</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-18\"><span class=\"toc-text\">3.18</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">只出现一次的数字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\"><span class=\"toc-text\">不用额外的空间复杂度</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF\"><span class=\"toc-text\">单词长度的最大乘积</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E5%92%8C\"><span class=\"toc-text\">排序数组中两个数字的和</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-19\"><span class=\"toc-text\">3.19</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA%E5%AE%9A%E5%80%BC%E7%9A%84%E8%8B%A5%E5%B9%B2%E4%B8%AA%E6%95%B0\"><span class=\"toc-text\">数组中和为定值的若干个数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E6%BB%A1%E8%B6%B3%E6%9F%90%E4%B8%AA%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">连续子数组的和满足某个条件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF%E6%BB%A1%E8%B6%B3%E6%9F%90%E4%B8%AA%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">连续子数组乘积满足某个条件</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-20\"><span class=\"toc-text\">3.20</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%BAk\"><span class=\"toc-text\">连续数组和为k</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%BB%A1%E8%B6%B3%E6%9F%90%E4%B8%AA%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">连续子数组满足某个条件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87\"><span class=\"toc-text\">数组的中心下标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BB%B4%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C\"><span class=\"toc-text\">二维子矩阵的和</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-21\"><span class=\"toc-text\">3.21</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84%E7%9B%B8%E5%8A%A0\"><span class=\"toc-text\">链表数组相加</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E4%BD%8D%E8%AF%8D-x2F-%E5%87%BA%E7%8E%B0%E7%9A%84index\"><span class=\"toc-text\">字符串变位词&#x2F;出现的index</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E4%B8%B2\"><span class=\"toc-text\">不含重复字符的字串</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-22\"><span class=\"toc-text\">3.22</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AB%E6%9C%89%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">含有所有字符的最短字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%96%87%E4%B8%B2-x2F-%E5%85%81%E8%AE%B8%E5%88%A0%E9%99%A4n%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2-x2F-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2\"><span class=\"toc-text\">回文串&#x2F;允许删除n个字符的回文串&#x2F;回文子串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA\"><span class=\"toc-text\">删除链表倒数第n个</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3\"><span class=\"toc-text\">链表环的入口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9\"><span class=\"toc-text\">双链表的交点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-23\"><span class=\"toc-text\">3.23</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">反转链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88%E9%9C%80%E8%A6%81%E5%8F%8D%E8%BD%AC%E5%9E%8B%EF%BC%89\"><span class=\"toc-text\">链表两数相加（需要反转型）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">重排链表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-24\"><span class=\"toc-text\">3.24</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">回文链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8%E6%89%81%E5%B9%B3%E5%8C%96\"><span class=\"toc-text\">三叉链表扁平化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">排序的循环链表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-25\"><span class=\"toc-text\">3.25</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%83%BD%E6%98%AFO-1-%E7%9A%84%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">插入 删除 随机访问都是O(1)的容器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LRU%E5%AE%B9%E5%99%A8%E7%9A%84%E6%9E%84%E9%80%A0\"><span class=\"toc-text\">LRU容器的构造</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%9A%84%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">变位词的判断</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-26\"><span class=\"toc-text\">3.26</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%98%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84\"><span class=\"toc-text\">变位词分组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%96%E6%98%9F%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">外星语言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE\"><span class=\"toc-text\">最小时间差</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-27\"><span class=\"toc-text\">3.27</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">逆波兰表达式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%9B%B8%E6%92%9E\"><span class=\"toc-text\">小行星相撞</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E5%8D%87%E6%B8%A9%E5%BA%A6\"><span class=\"toc-text\">上升温度</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-28\"><span class=\"toc-text\">3.28</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E9%98%B5%E9%9D%A2%E7%A7%AF\"><span class=\"toc-text\">最大的矩阵面积</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2\"><span class=\"toc-text\">矩阵中最大的矩形</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B9%B3%E5%9D%87%E5%80%BC\"><span class=\"toc-text\">滑动窗口平均值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E8%BF%91%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">最近请求次数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">二叉树添加节点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-29\"><span class=\"toc-text\">3.29</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B7%A6%E6%9C%80%E6%B7%B1%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84val\"><span class=\"toc-text\">最左最深的节点的val</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D\"><span class=\"toc-text\">二叉树剪枝</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">序列化和反序列化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C\"><span class=\"toc-text\">根节点到叶节点的和</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-30\"><span class=\"toc-text\">3.30</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%95%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">展平二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7\"><span class=\"toc-text\">二叉搜索树中序后继</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-31\"><span class=\"toc-text\">3.31</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C\"><span class=\"toc-text\">连续子数组最大和</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">大于等于节点的值之和</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88%E4%B8%AD%E5%BA%8F%EF%BC%89\"><span class=\"toc-text\">树迭代器（中序）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">二叉搜索树两数之和</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%80%BC%E5%92%8Cindex%E5%B7%AE%E5%B0%8F%E4%BA%8Elimitation\"><span class=\"toc-text\">值和index差小于limitation</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3\"><span class=\"toc-text\">4.3</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A5%E7%A8%8B%E8%A1%A8\"><span class=\"toc-text\">日程表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#topK%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">topK问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84topK\"><span class=\"toc-text\">频率最高的topK</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%E5%AF%B9\"><span class=\"toc-text\">和最小的K个数对</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4\"><span class=\"toc-text\">4.4</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BC%80%E6%A0%91\"><span class=\"toc-text\">前缀树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%BF%E6%8D%A2%E5%8D%95%E8%AF%8D\"><span class=\"toc-text\">替换单词</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A5%9E%E5%A5%87%E5%AD%97%E5%85%B8\"><span class=\"toc-text\">神奇字典</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%9F%AD%E5%8D%95%E8%AF%8D%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">最短单词编码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E6%8D%AE%E5%89%8D%E7%BC%80%E8%BF%94%E5%9B%9E%E7%9B%B8%E5%85%B3%E5%8D%95%E8%AF%8D%E5%92%8C\"><span class=\"toc-text\">根据前缀返回相关单词和</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96\"><span class=\"toc-text\">最大异或</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">二分查找</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">山峰数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">排序数组只出现一次的数字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BAindex\"><span class=\"toc-text\">加权随机index</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9\"><span class=\"toc-text\">求平方根</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%83%E9%A6%99%E8%95%89\"><span class=\"toc-text\">吃香蕉</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-5\"><span class=\"toc-text\">4.5</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E5%8C%BA%E9%97%B4\"><span class=\"toc-text\">排序区间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E6%AE%8Acondition%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">特殊condition排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TopK\"><span class=\"toc-text\">TopK</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">单链表排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">合并有序链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86\"><span class=\"toc-text\">所有子集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0\"><span class=\"toc-text\">求组合数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">允许重复选择元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">不允许重复选择元素</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%85%A8%E6%8E%92%E5%88%97-%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-x2F-%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">数组元素全排列(含重复元素&#x2F;不含重复元素)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E5%8C%B9%E9%85%8D%E7%9A%84%E6%8B%AC%E5%8F%B7\"><span class=\"toc-text\">生成匹配的括号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2\"><span class=\"toc-text\">分割回文子串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8C%89%E6%9D%A1%E4%BB%B6%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">按条件分割字符串</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-17\"><span class=\"toc-text\">4.17</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TopK%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">TopK问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Top100\"><span class=\"toc-text\">三、Top100</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">1.两数之和</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C\"><span class=\"toc-text\">2.链表求和</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2\"><span class=\"toc-text\">3.无重复最长子串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E4%BD%8D%E6%95%B0\"><span class=\"toc-text\">4.两个正序数组中位数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%9B%9E%E6%96%87%E4%B8%B2\"><span class=\"toc-text\">5.回文串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-Z%E4%B8%B2\"><span class=\"toc-text\">6.Z串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC\"><span class=\"toc-text\">7.整数反转</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#51-52-N%E7%9A%87%E5%90%8E\"><span class=\"toc-text\">51.52.N皇后</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#105-106-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%8D%E6%9E%84\"><span class=\"toc-text\">105.106.二叉树重构</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81Leetcode75\"><span class=\"toc-text\">四、Leetcode75</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">205. 同构字符串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B\"><span class=\"toc-text\">290. 单词规律</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8BII\"><span class=\"toc-text\">290. 单词规律II</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">392. 判断子序列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">21. 合并两个有序链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">206. 反转链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9\"><span class=\"toc-text\">876. 链表的中间结点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II\"><span class=\"toc-text\">142. 环形链表 II</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">121. 买卖股票的最佳时机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2\"><span class=\"toc-text\">409. 最长回文串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#589-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">589. N 叉树的前序遍历</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">常用算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-1\"><span class=\"toc-text\">二分查找</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">八大排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">冒泡排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">选择排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">归并排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">快速排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">计数排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">希尔排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">堆排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">基数排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">桶排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8\"><span class=\"toc-text\">复杂度表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#dp\"><span class=\"toc-text\">dp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%80%A7dp\"><span class=\"toc-text\">线性dp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%E7%BB%B4%EF%BC%89\"><span class=\"toc-text\">单数组（一维）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%AD%90%E4%B8%B2-MCSP\"><span class=\"toc-text\">和最大的子串(MCSP)</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%E7%BB%B4%EF%BC%89\"><span class=\"toc-text\">双数组（二维）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-LCS\"><span class=\"toc-text\">最长公共子序列(LCS)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%EF%BC%88LCSP\"><span class=\"toc-text\">最长公共子串（LCSP)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB\"><span class=\"toc-text\">编辑距离</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">满足条件的最长子序列</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%83%8C%E5%8C%85dp\"><span class=\"toc-text\">背包dp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">01背包问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85\"><span class=\"toc-text\">完全背包</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E9%97%B4dp\"><span class=\"toc-text\">区间dp</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2\"><span class=\"toc-text\">钢条切割</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95\"><span class=\"toc-text\">矩阵链乘法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%91%E5%BD%A2dp\"><span class=\"toc-text\">树形dp</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E5%8E%8Bdp\"><span class=\"toc-text\">状压dp</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E8%AE%BA\"><span class=\"toc-text\">图论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DFS-x2F-BFS\"><span class=\"toc-text\">DFS&#x2F;BFS</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">环路检测</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">拓扑排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F\"><span class=\"toc-text\">强连通分量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-MST\"><span class=\"toc-text\">最小生成树(MST)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Prim\"><span class=\"toc-text\">Prim</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Kruscal\"><span class=\"toc-text\">Kruscal</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra\"><span class=\"toc-text\">单源最短路径(dijkstra)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#dijkstra\"><span class=\"toc-text\">dijkstra</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bellman-ford\"><span class=\"toc-text\">bellman-ford</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Floyd\"><span class=\"toc-text\">Floyd</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E5%9B%BE\"><span class=\"toc-text\">二分图</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">技巧</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashSet%E3%80%81HashMap\"><span class=\"toc-text\">HashSet、HashMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E6%8C%87%E9%92%88\"><span class=\"toc-text\">双指针</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E5%88%A4%E6%96%AD%E4%BD%99%E6%95%B0\"><span class=\"toc-text\">避免判断余数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">位运算</span></a></li></ol></li></ol>","author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"PythonLearning","uid":"16dddd2808895ffe203f5dab69ce83b4","slug":"PythonLearning","date":"2020-09-05T02:57:00.000Z","updated":"2022-11-08T07:57:11.799Z","comments":true,"path":"api/articles/PythonLearning.json","keywords":null,"cover":"/post/PythonLearning/cover.jpg","text":"PythonLearning记录一下Python的学习，方便以后复习，如果能帮到其他人就更好了 IOinputleft,right = map(int,input().split(\" \")) #以list的形式存储 l = list(map(int,input().split(\"...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"10 mins."},"categories":[{"name":"learning","slug":"learning","count":5,"path":"api/categories/learning.json"}],"tags":[{"name":"Python","slug":"Python","count":1,"path":"api/tags/Python.json"}],"author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}