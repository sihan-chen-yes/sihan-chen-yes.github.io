{"title":"CppLearning","uid":"043ea5846f4ce7e1aaad5107c0f5a6a3","slug":"CppLearning","date":"2022-11-03T02:55:58.000Z","updated":"2022-11-03T03:01:06.859Z","comments":true,"path":"api/articles/CppLearning.json","keywords":null,"cover":"/post/CppLearning/cover.jpg","content":"<h1 id=\"C-Learning\"><a href=\"#C-Learning\" class=\"headerlink\" title=\"C++Learning\"></a>C++Learning</h1><p>记录一下Cpp的学习，方便以后复习，如果能帮到其他人就更好了</p>\n<hr>\n<h2 id=\"1-基本语法\"><a href=\"#1-基本语法\" class=\"headerlink\" title=\"1.基本语法\"></a>1.基本语法</h2><h3 id=\"1-命名空间\"><a href=\"#1-命名空间\" class=\"headerlink\" title=\"1.命名空间\"></a>1.命名空间</h3><p>在C&#x2F;C++中，变量、函数和类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染。</p>\n<h4 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h4><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">namespace name1 &#123;\n  int a &#x3D; 5;\n  int add(int b, int c)&#123;\n    return b + c;\n  &#125;\n  namespace name2 &#123;\n    int a &#x3D; 3;\n    int sub(int b,int c) &#123;\n      return b - c;\n    &#125;\n  &#125;\n    &#x2F;&#x2F;函数\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可嵌套定义，如果有多个同名的命名空间会自动合并</p>\n<h4 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h4><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">using namespace name1;\n&#x2F;&#x2F;命名空间全部导入\nusing name1::a;\n&#x2F;&#x2F;此种声明下命名空间name1下的变量a就能直接使用\nusing name1::name2::b;\nint main() &#123;\n  printf(&quot;%d\\n&quot;,a);\n  return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当导入的命名空间中有<strong>重复的变量或者函数</strong>时会报错</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">using namespace std;\n&#x2F;&#x2F;之后写cout cin都可以直接写而不用 std::cin std::cout\n&#x2F;&#x2F;不提前导入的话之后每次使用都得带上命名空间名字和双冒号\n&#x2F;&#x2F;告诉编辑器使用命名空间<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"范围解析运算符\"><a href=\"#范围解析运算符\" class=\"headerlink\" title=\"范围解析运算符:\"></a>范围解析运算符:</h4><p>::</p>\n<h3 id=\"2-关键词\"><a href=\"#2-关键词\" class=\"headerlink\" title=\"2.关键词\"></a>2.关键词</h3><p>volatile：提醒编译器该变量所在内存可能会因为其他因素改变，每次使用需要从内存中重新取值</p>\n<p>explicit： 禁止隐式转换</p>\n<p>mutable：对象中的const函数不能改变对象成员，但是对于mutable声明的成员变量可以在const函数里面改变</p>\n<h2 id=\"2-基本数据类型\"><a href=\"#2-基本数据类型\" class=\"headerlink\" title=\"2.基本数据类型\"></a>2.基本数据类型</h2><table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">布尔型</td>\n<td align=\"left\">bool</td>\n</tr>\n<tr>\n<td align=\"left\">字符型</td>\n<td align=\"left\">char</td>\n</tr>\n<tr>\n<td align=\"left\">整型</td>\n<td align=\"left\">int</td>\n</tr>\n<tr>\n<td align=\"left\">浮点型</td>\n<td align=\"left\">float</td>\n</tr>\n<tr>\n<td align=\"left\">双浮点型</td>\n<td align=\"left\">double</td>\n</tr>\n<tr>\n<td align=\"left\">无类型</td>\n<td align=\"left\">void</td>\n</tr>\n<tr>\n<td align=\"left\">宽字符型</td>\n<td align=\"left\">wchar_t</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">typedef short int wchar_t;\n&#x2F;&#x2F;2B<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>修饰类型：</p>\n<ul>\n<li>signed</li>\n<li>unsigned</li>\n<li>long</li>\n</ul>\n<p>long int &#x3D;&#x3D; 4B short int &#x3D;&#x3D; 2B double &#x3D; 8B long double &#x3D; 16B</p>\n<ul>\n<li>short</li>\n</ul>\n<p>Const:不可更改</p>\n<p>Volatile:不要优化 每次使用时从内存上拿取最新的值</p>\n<p>restrict:？？？？？</p>\n<h2 id=\"3-typedef\"><a href=\"#3-typedef\" class=\"headerlink\" title=\"3.typedef\"></a>3.typedef</h2><p>用法：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef type newname\n&#x2F;&#x2F;将已有的type名定义为新的name<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"4-枚举\"><a href=\"#4-枚举\" class=\"headerlink\" title=\"4.枚举\"></a>4.枚举</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">enum 枚举名&#123; \n     标识符[&#x3D;整型常数], \n     标识符[&#x3D;整型常数], \n... \n    标识符[&#x3D;整型常数]\n&#125; 枚举变量;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如果枚举变量在定义的时候没有赋值，默认从0开始</p>\n<p>使用</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">color c1,c2;\nc1 &#x3D; blue;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"5-声明和初始化\"><a href=\"#5-声明和初始化\" class=\"headerlink\" title=\"5.声明和初始化\"></a>5.声明和初始化</h2><p>只有声明了编译过程才能进行</p>\n<p>初始化与否不影响编译</p>\n<p>（函数和变量）</p>\n<p>当局部变量和全局变量名字相同时，优先使用局部变量（具有更高的优先级）</p>\n<p>全局变量会自动初始化</p>\n<p><strong>变量</strong>：</p>\n<ul>\n<li>静态变量：</li>\n</ul>\n<p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 <strong>::</strong> 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>\n<p>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。<br>普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class foo &#123;\n    static void foo() &#123;\n        &#x2F;&#x2F;body\n    &#125;\n&#125;;\nint main() &#123;\n    foo::foo();\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>实例变量</li>\n<li>全局变量</li>\n<li>局部变量</li>\n</ul>\n<h2 id=\"6-define-const\"><a href=\"#6-define-const\" class=\"headerlink\" title=\"6.define const\"></a>6.define const</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#define a 1\ncont int b &#x3D; 1;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"7-存储类\"><a href=\"#7-存储类\" class=\"headerlink\" title=\"7.存储类\"></a>7.存储类</h2><ul>\n<li><p>register：意味着变量可能存储在寄存器中，多用于计数器，可大大加速</p>\n</li>\n<li><p>static：存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁</p>\n<p>1.在函数中对修饰局部变量可以在函数调用之间保持局部变量的值</p>\n<p>2.修饰类的静态属性</p>\n<p>3.修饰全局变量，作用域限制在声明他的文件里</p>\n</li>\n<li><p>extern：使一个文件中定义的变量或者函数可以在另一个文件中使用</p>\n</li>\n<li><p>mutable：</p>\n</li>\n<li><p>Thread_local:</p>\n</li>\n</ul>\n<h2 id=\"8-运算符\"><a href=\"#8-运算符\" class=\"headerlink\" title=\"8.运算符\"></a>8.运算符</h2><ul>\n<li>算数运算符</li>\n<li>关系运算符</li>\n<li>逻辑运算符</li>\n<li>位运算符</li>\n<li>赋值运算符（含有等号的运算符）</li>\n<li>杂项运算符</li>\n</ul>\n<h2 id=\"9-函数\"><a href=\"#9-函数\" class=\"headerlink\" title=\"9.函数\"></a>9.函数</h2><h3 id=\"1-函数传参\"><a href=\"#1-函数传参\" class=\"headerlink\" title=\"1.函数传参\"></a>1.函数传参</h3><ul>\n<li>传值调用</li>\n<li>指针调用</li>\n<li>引用调用</li>\n</ul>\n<h3 id=\"2-参数默认值\"><a href=\"#2-参数默认值\" class=\"headerlink\" title=\"2.参数默认值\"></a>2.参数默认值</h3><p>类似python</p>\n<h3 id=\"3-lambda函数与表达式\"><a href=\"#3-lambda函数与表达式\" class=\"headerlink\" title=\"3.lambda函数与表达式\"></a>3.lambda函数与表达式</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">[capture](parameters)-&gt;return-type&#123;body&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"10-库函数\"><a href=\"#10-库函数\" class=\"headerlink\" title=\"10.库函数\"></a>10.库函数</h2><h3 id=\"1-随机数\"><a href=\"#1-随机数\" class=\"headerlink\" title=\"1.随机数\"></a>1.随机数</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">srand(2);\n&#x2F;&#x2F;随机数种子\nint a &#x3D; rand();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-time\"><a href=\"#2-time\" class=\"headerlink\" title=\"2.time\"></a>2.time</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">srand(time(NULL));\n&#x2F;&#x2F;随机数种子<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-setw\"><a href=\"#3-setw\" class=\"headerlink\" title=\"3.setw\"></a>3.setw</h3><p>setw(n)函数只对紧接着的输出产生作用 n表示宽度</p>\n<h3 id=\"4-setfill\"><a href=\"#4-setfill\" class=\"headerlink\" title=\"4.setfill\"></a>4.setfill</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">setfill(char c)\n&#x2F;&#x2F;用字符来填充空白<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"5-字符串函数\"><a href=\"#5-字符串函数\" class=\"headerlink\" title=\"5.字符串函数\"></a>5.字符串函数</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">strcpy(s1,s2)\n&#x2F;&#x2F;s2复制到s1中 不管原来s1是什么内容直接覆盖\nstrlen(s1)\n&#x2F;&#x2F;返回s1长度 这里的长度不包括&#39;\\0&#39;\nstrcmp(s1,s2)\n&#x2F;&#x2F;若s1 &gt; s2则返回正数 相等则返回0 反之则返回负数 对于string类型的字符串不能使用\nstrchr(s1,ch);\n&#x2F;&#x2F;返回指针指向s1中ch第一次出现的位置 从左开始\nstrcat(s1,s2)\n&#x2F;&#x2F;将s2接在s1后面 注意只能对char name[]的字符数组使用 对于string类型的字符串（C++新增）可以直接使用 &#39;+&#39;连接\nstrstr(s1,s2)\n&#x2F;&#x2F;返回一个指针表示s2在s1中的匹配 如果没有匹配则返回<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">char s1[] &#x3D; &quot;abc&quot;;\ncout &lt;&lt; s1 &lt;&lt; endl;\n&#x2F;&#x2F;打印字符串指针 就是从该位置开始打印字符串\ns1 &#x3D; s2;\n&#x2F;&#x2F;不管是string还是char s[]都可以直接改变指针引用 <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"11-指针\"><a href=\"#11-指针\" class=\"headerlink\" title=\"11.指针\"></a>11.指针</h2><p><strong>数组是常量指针</strong></p>\n<h2 id=\"12-引用类型\"><a href=\"#12-引用类型\" class=\"headerlink\" title=\"12.引用类型\"></a>12.引用类型</h2><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>\n<ul>\n<li>不存在空引用。引用必须连接到一块合法的内存。</li>\n<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>\n<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>\n</ul>\n<p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">int a &#x3D; 5;\nint &amp;b &#x3D; a;\ncout &lt;&lt; a &lt;&lt;endl;\n&#x2F;&#x2F;5\ncout &lt;&lt; b &lt;&lt; endl;\n&#x2F;&#x2F;5\na &#x3D;&#x3D; b;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"13-字符流\"><a href=\"#13-字符流\" class=\"headerlink\" title=\"13.字符流\"></a>13.字符流</h2><p>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做<strong>输入操作</strong>。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做<strong>输出操作</strong>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">头文件</th>\n<th align=\"left\">函数和描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><iostream></iostream></td>\n<td align=\"left\">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>\n</tr>\n<tr>\n<td align=\"left\"><iomanip></iomanip></td>\n<td align=\"left\">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I&#x2F;O 有用的服务。</td>\n</tr>\n<tr>\n<td align=\"left\"><fstream></fstream></td>\n<td align=\"left\">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td>\n</tr>\n</tbody></table>\n<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">string name;\ncin &gt;&gt; name;&#x2F;&#x2F;标准输入流\ncout &lt;&lt; name &lt;&lt; endl;&#x2F;&#x2F;标准输出流\ncerr &lt;&lt; &quot;wrong&quot;;&#x2F;&#x2F;标准错误流\nclog &lt;&lt; &quot;done&quot;;&#x2F;&#x2F;标准日志流<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>预定义的对象 <strong>cerr</strong> 是 <strong>iostream</strong> 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 <strong>cerr</strong> 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>\n<p> <strong>clog</strong> 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</p>\n<h2 id=\"14-结构\"><a href=\"#14-结构\" class=\"headerlink\" title=\"14.结构\"></a>14.结构</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">struct type_name &#123;\n    member_type1 member_name1;\n    member_type2 member_name2;\n    member_type3 member_name3;\n&#125;;\n&#x2F;*or\ntypedef struct type_name &#123;\n    member_type1 member_name1;\n    member_type2 member_name2;\n    member_type3 member_name3;\n&#125;object_names;*&#x2F;\ntype_name name1,name2;\ncout &lt;&lt; name1.member_name1 &lt;&lt; endl;\ntype_name *ptrname;\nptrname &#x3D; &amp;name2;\ncout &lt;&lt; name2-&gt;member_name1 &lt;&lt; endl;\n\ntypedef long int *pint32;\n \npint32 x, y, z;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"15-类与对象\"><a href=\"#15-类与对象\" class=\"headerlink\" title=\"15.类与对象\"></a>15.类与对象</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class name &#123;\n  modifier:\n    type name1;\n    type name2;\n  modifier:\n    returntype func(type para);\n  &#x2F;&#x2F; func signature\n  modifier:\n  \treturntype func(type para) &#123;\n      &#x2F;&#x2F;body also ok!\n    &#125;\n&#125;;\ntype name::func(type para) &#123;\n  &#x2F;&#x2F;func body\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意与java的区别与联系</p>\n<ul>\n<li>相同的修饰符可以只写一次</li>\n<li>方法在class域里只写头也行 带上方法体也行</li>\n<li>当参数名和属性成员名相同时，成员名加上this以达到区分</li>\n<li>没有任何修饰符时默认<strong>private</strong></li>\n</ul>\n<p>成员函数可以定义在类定义内部，或者单独使用<strong>范围解析运算符 ::</strong> 来定义。在类定义中定义的成员函数把函数声明为<strong>内联</strong>的，即便没有使用 inline 标识符。</p>\n<p>注意C++里面类的实例化有两种方法：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class foo &#123;\n    &#x2F;&#x2F;class\n&#125;;\nint main() &#123;\n    foo foo1;&#x2F;&#x2F;类似结构体\n    &#x2F;&#x2F;这种实例化方法把对象建立在栈上 自动调用构造函数和析构函数\n    foo *foo1 &#x3D; new foo;&#x2F;&#x2F;类似结构体指针\n    &#x2F;&#x2F;这种实例化方式是类指针 建立在堆上 不会自动回收 要手动delete 否则发生内存泄漏\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>注意this指针和类指针的区别</p>\n<h3 id=\"构造函数：\"><a href=\"#构造函数：\" class=\"headerlink\" title=\"构造函数：\"></a>构造函数：</h3><p>默认public</p>\n<p>使用初始化列表来初始化字段：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">C::C( double a, double b, double c): X(a), Y(b), Z(c)\n&#123;  .... &#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"析构函数：\"><a href=\"#析构函数：\" class=\"headerlink\" title=\"析构函数：\"></a>析构函数：</h3><p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class foo &#123;\n    public:\n\t\tfoo() &#123;\n            &#x2F;&#x2F;body\n        &#125;\n    \t~foo() &#123;\n            &#x2F;&#x2F;body\n        &#125;\n&#125;;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"拷贝构造函数：\"><a href=\"#拷贝构造函数：\" class=\"headerlink\" title=\"拷贝构造函数：\"></a>拷贝构造函数：</h3><p><strong>拷贝构造函数</strong>是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>\n<ul>\n<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>\n<li>复制对象把它作为参数传递给函数。</li>\n<li>复制对象，并从函数返回这个对象。</li>\n</ul>\n<h2 id=\"16-友元函数\"><a href=\"#16-友元函数\" class=\"headerlink\" title=\"16.友元函数\"></a>16.友元函数</h2><ol>\n<li>C++中引入友元函数，是为在该类中提供一个对外（除了他自己意外）访问的窗口;</li>\n<li>这个友元函数他不属于该类的成员函数，他是定义在类外的普通函数，只是在类中声明该函数可以直接访问类中的private或者protected成员。</li>\n<li>将数据和处理数据的函数封装在一起，构成类，实现了数据的隐藏，无疑是面向对象程序设计的一大优点。但是有时候封装不是绝对的。</li>\n<li>友元函数提供了不同类或对象的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通俗的说，友元关系就是一个类主动声明哪些类或函数是它的朋友，进而给它们提供对本类的访问特性。也就是说，通过友元关系，一个普通函数或者类的成员函数可以访问封装于另外一个类中的数据。</li>\n<li>从一定程度上讲，友元是对数据隐藏和封装的破坏，但是为了数据共享，提高程序的效率和可读性，很多情况下这种小的破坏是必要的。</li>\n<li>在一个类中，利用关键字friend将其它函数或类声明为友元。如果友元是一般函数或类的成员函数，称为友元函数。如果友元是一个类，则称为友元类。友元类的所有成员函数都自动称为友元函数。</li>\n<li>成员函数有this指针，而友元函数没有this指针。</li>\n<li>友元函数是不能被继承的，就像父亲的朋友未必是儿子的朋友。</li>\n</ol>\n<p>1.类中通过使用关键字friend 来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。</p>\n<p>2.一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。</p>\n<p>3.友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。</p>\n<p>4.友元函数在调用上同一般函数一样，不必通过对对象进行引用。</p>\n<h2 id=\"17-内联函数\"><a href=\"#17-内联函数\" class=\"headerlink\" title=\"17.内联函数\"></a>17.内联函数</h2><p>C++ <strong>内联函数</strong>是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p>\n<p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>\n<p>如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 <strong>inline</strong>，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。</p>\n<p>在类定义中的定义的函数都是内联函数，即使没有使用 <strong>inline</strong> 说明符。</p>\n<h2 id=\"18-继承\"><a href=\"#18-继承\" class=\"headerlink\" title=\"18.继承\"></a>18.继承</h2><p>三种继承：</p>\n<ul>\n<li>1.<strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</li>\n<li>2.<strong>protected 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</li>\n<li>3.<strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</li>\n</ul>\n<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">访问</th>\n<th align=\"left\">public</th>\n<th align=\"left\">protected</th>\n<th align=\"left\">private</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">同一个类</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">yes</td>\n</tr>\n<tr>\n<td align=\"left\">派生类</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">no</td>\n</tr>\n<tr>\n<td align=\"left\">外部的类</td>\n<td align=\"left\">yes</td>\n<td align=\"left\">no</td>\n<td align=\"left\">no</td>\n</tr>\n</tbody></table>\n<p>C++支持多继承，具体使用方法是：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class foo1:access-specifier classname....&lt;list&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"19-重载\"><a href=\"#19-重载\" class=\"headerlink\" title=\"19.重载\"></a>19.重载</h2><h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>\n<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>\n<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>\n<p>函数的签名是由函数的参数和函数的名字决定的与返回值无关</p>\n<h3 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">class Box &#123;\n    public:\n    \tBox operator+(const Box&amp;b) &#123;\n             Box box;\n             box.length &#x3D; this-&gt;length + b.length;\n             box.breadth &#x3D; this-&gt;breadth + b.breadth;\n             box.height &#x3D; this-&gt;height + b.height;\n             return box;\n        &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"可重载运算符\"><a href=\"#可重载运算符\" class=\"headerlink\" title=\"可重载运算符\"></a>可重载运算符</h3><table>\n<thead>\n<tr>\n<th>双目算术运算符</th>\n<th>+ (加)，-(减)，*(乘)，&#x2F;(除)，% (取模)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>关系运算符</td>\n<td>&#x3D;&#x3D;(等于)，!&#x3D; (不等于)，&lt; (小于)，&gt; (大于)，&lt;&#x3D;(小于等于)，&gt;&#x3D;(大于等于)</td>\n</tr>\n<tr>\n<td>逻辑运算符</td>\n<td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>\n</tr>\n<tr>\n<td>单目运算符</td>\n<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>\n</tr>\n<tr>\n<td>自增自减运算符</td>\n<td>++(自增)，–(自减)</td>\n</tr>\n<tr>\n<td>位运算符</td>\n<td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>\n</tr>\n<tr>\n<td>赋值运算符</td>\n<td>&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; , % &#x3D; , &amp;&#x3D;, |&#x3D;, ^&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&#x3D;</td>\n</tr>\n<tr>\n<td>空间申请与释放</td>\n<td>new, delete, new[ ] , delete[]</td>\n</tr>\n<tr>\n<td>其他运算符</td>\n<td><strong>()</strong>(函数调用)，**-&gt;<strong>(成员访问)，</strong>,<strong>(逗号)，</strong>[]**(下标)</td>\n</tr>\n</tbody></table>\n<h3 id=\"不可重载运算符\"><a href=\"#不可重载运算符\" class=\"headerlink\" title=\"不可重载运算符\"></a>不可重载运算符</h3><ul>\n<li>**.**：成员访问运算符</li>\n<li><strong>.*</strong>, **-&gt;***：成员指针访问运算符</li>\n<li>**::**：域运算符</li>\n<li><strong>sizeof</strong>：长度运算符</li>\n<li>**?:**：条件运算符</li>\n<li>**#**： 预处理符号</li>\n</ul>\n<h3 id=\"虚函数：\"><a href=\"#虚函数：\" class=\"headerlink\" title=\"虚函数：\"></a>虚函数：</h3><p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>\n<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>\n<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>\n<h3 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h3><p>要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>\n<p>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “&#x3D; 0” 来指定的.</p>\n<p>设计<strong>抽象类</strong>（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用。如果试图实例化一个抽象类的对象，会导致编译错误。</p>\n<p>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。</p>\n<p>可用于实例化对象的类被称为<strong>具体类</strong>。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">virtual int area() &#x3D; 0;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"20-文件和流\"><a href=\"#20-文件和流\" class=\"headerlink\" title=\"20.文件和流\"></a>20.文件和流</h2><table>\n<thead>\n<tr>\n<th align=\"left\">模式标志</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ios::app</td>\n<td align=\"left\">追加模式。所有写入都追加到文件末尾。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::ate</td>\n<td align=\"left\">文件打开后定位到文件末尾。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::in</td>\n<td align=\"left\">打开文件用于读取。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::out</td>\n<td align=\"left\">打开文件用于写入。</td>\n</tr>\n<tr>\n<td align=\"left\">ios::trunc</td>\n<td align=\"left\">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>\n</tr>\n</tbody></table>\n<h3 id=\"打开文件\"><a href=\"#打开文件\" class=\"headerlink\" title=\"打开文件\"></a>打开文件</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">void open(const char *filename, ios::openmode mode);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"关闭文件\"><a href=\"#关闭文件\" class=\"headerlink\" title=\"关闭文件\"></a>关闭文件</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">void close();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"写入文件\"><a href=\"#写入文件\" class=\"headerlink\" title=\"写入文件\"></a>写入文件</h3><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p>\n<h3 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h3><p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p>\n<p><strong>hint</strong>：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">int main() &#123;\n    ofstream file;\n    file.open(&quot;file.txt&quot;,ios::app);\n    file &lt;&lt; &quot;fuck&quot;;\n    fstream infile;\n    infile.open(&quot;file.txt&quot;,ios::in);\n    string s &#x3D; &quot;&quot;;\n    infile &gt;&gt; s;\n    cout &lt;&lt; s;\n    file.close();\n&#125;\n&#x2F;&#x2F;需要重新以读模式打开文件<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"文件位置指针\"><a href=\"#文件位置指针\" class=\"headerlink\" title=\"文件位置指针\"></a>文件位置指针</h3><p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（”seek get”）和关于 ostream 的 <strong>seekp</strong>（”seek put”）。</p>\n<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>\n<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">int main() &#123;\n    fstream outFile;\n    outFile.open(&quot;file.txt&quot;,ios::trunc);\n    outFile.seekp(4);\n    cout &lt;&lt; outFile.tellp() &lt;&lt; endl;\n    outFile &lt;&lt; &quot;foofoofoo&quot;;\n    outFile.close();\n    ifstream inFile;\n    inFile.open(&quot;file.txt&quot;,ios::in);\n    string s;\n    inFile.seekg(-1,ios::end);\n    cout &lt;&lt; inFile.tellg() &lt;&lt; endl;\n    inFile &gt;&gt; s;\n    cout &lt;&lt; s &lt;&lt; endl;\n    inFile.close();\n    return 0;\n&#125;\n&#x2F;&#x2F;C++读写指针是分开的\n&#x2F;&#x2F;输出：\n-1\n12\no\n  foofoofoo\n  &#x2F;&#x2F;tellp tellg\n  &#x2F;&#x2F;seekp seekg\n  &#x2F;&#x2F;ios::beg ios::cur ios::end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"21-异常处理\"><a href=\"#21-异常处理\" class=\"headerlink\" title=\"21.异常处理\"></a>21.异常处理</h2><table>\n<thead>\n<tr>\n<th align=\"left\">异常</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>std::exception</strong></td>\n<td align=\"left\">该异常是所有标准 C++ 异常的父类。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_alloc</td>\n<td align=\"left\">该异常可以通过 <strong>new</strong> 抛出。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_cast</td>\n<td align=\"left\">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_exception</td>\n<td align=\"left\">这在处理 C++ 程序中无法预期的异常时非常有用。</td>\n</tr>\n<tr>\n<td align=\"left\">std::bad_typeid</td>\n<td align=\"left\">该异常可以通过 <strong>typeid</strong> 抛出。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>std::logic_error</strong></td>\n<td align=\"left\">理论上可以通过读取代码来检测到的异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::domain_error</td>\n<td align=\"left\">当使用了一个无效的数学域时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::invalid_argument</td>\n<td align=\"left\">当使用了无效的参数时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::length_error</td>\n<td align=\"left\">当创建了太长的 std::string 时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::out_of_range</td>\n<td align=\"left\">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href></a>。</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>std::runtime_error</strong></td>\n<td align=\"left\">理论上不可以通过读取代码来检测到的异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::overflow_error</td>\n<td align=\"left\">当发生数学上溢时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::range_error</td>\n<td align=\"left\">当尝试存储超出范围的值时，会抛出该异常。</td>\n</tr>\n<tr>\n<td align=\"left\">std::underflow_error</td>\n<td align=\"left\">当发生数学下溢时，会抛出该异常。</td>\n</tr>\n</tbody></table>\n<p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因</p>\n<p>例子：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">struct MyException : public exception\n&#123;\n  const char * what () const throw ()\n  &#123;\n    return &quot;C++ Exception&quot;;\n  &#125;\n&#125;;\n \nint main()\n&#123;\n  try\n  &#123;\n    throw MyException();\n  &#125;\n  catch(MyException&amp; e)\n  &#123;\n    std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;\n  &#125;\n  catch(std::exception&amp; e)\n  &#123;\n    &#x2F;&#x2F;其他的错误\n  &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"22-动态内存\"><a href=\"#22-动态内存\" class=\"headerlink\" title=\"22.动态内存\"></a>22.动态内存</h2><ul>\n<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>\n<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>\n</ul>\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">new data-type;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">double *ptr;\nptr &#x3D; new double;\n*ptr &#x3D; 1.2;\ncout &lt;&lt; *ptr;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">delete ptr;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>数组申请和释放的例子：</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n \nint main()\n&#123;   \n    int i,j,k;   &#x2F;&#x2F; p[2][3][4]\n    \n    int ***p;\n    p &#x3D; new int **[2]; \n    for(i&#x3D;0; i&lt;2; i++) \n    &#123; \n        p[i]&#x3D;new int *[3]; \n        for(j&#x3D;0; j&lt;3; j++) \n            p[i][j]&#x3D;new int[4]; \n    &#125;\n    \n    &#x2F;&#x2F;输出 p[i][j][k] 三维数据\n    for(i&#x3D;0; i&lt;2; i++)   \n    &#123;\n        for(j&#x3D;0; j&lt;3; j++)   \n        &#123; \n            for(k&#x3D;0;k&lt;4;k++)\n            &#123; \n                p[i][j][k]&#x3D;i+j+k;\n                cout&lt;&lt;p[i][j][k]&lt;&lt;&quot; &quot;;\n            &#125;\n            cout&lt;&lt;endl;\n        &#125;\n        cout&lt;&lt;endl;\n    &#125;\n    \n    &#x2F;&#x2F; 释放内存\n    for(i&#x3D;0; i&lt;2; i++) \n    &#123;\n        for(j&#x3D;0; j&lt;3; j++) \n        &#123;   \n            delete [] p[i][j];   \n        &#125;   \n    &#125;       \n    for(i&#x3D;0; i&lt;2; i++)   \n    &#123;       \n        delete [] p[i];   \n    &#125;   \n    delete [] p;  \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"23-模版\"><a href=\"#23-模版\" class=\"headerlink\" title=\"23.模版\"></a>23.模版</h2><h3 id=\"函数模版\"><a href=\"#函数模版\" class=\"headerlink\" title=\"函数模版\"></a>函数模版</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">template &lt;typename T&gt;\nT funcname (T a, T b) &#123;\n  &#x2F;&#x2F;body\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"类模版\"><a href=\"#类模版\" class=\"headerlink\" title=\"类模版\"></a>类模版</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">template &lt;class T&gt;\nclass Stack &#123; \n  private: \n    vector&lt;T&gt; elems;     &#x2F;&#x2F; 元素 \n \n  public: \n    void push(T const&amp;);  &#x2F;&#x2F; 入栈\n    void pop();               &#x2F;&#x2F; 出栈\n    T top() const;            &#x2F;&#x2F; 返回栈顶元素\n    bool empty() const&#123;       &#x2F;&#x2F; 如果为空则返回真。\n        return elems.empty(); \n    &#125; \n&#125;; <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"24-预处理器\"><a href=\"#24-预处理器\" class=\"headerlink\" title=\"24.预处理器\"></a>24.预处理器</h2><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>\n<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。</p>\n<h3 id=\"define\"><a href=\"#define\" class=\"headerlink\" title=\"define\"></a>define</h3><ul>\n<li><p>宏常量</p>\n</li>\n<li><p>宏函数</p>\n</li>\n</ul>\n<h3 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#ifdef\n&#x2F;&#x2F;body\n#endif\n#if\n&#x2F;&#x2F;body\n#endif<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"和-运算符\"><a href=\"#和-运算符\" class=\"headerlink\" title=\"#和##运算符\"></a>#和##运算符</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#define MKSTR( x ) #x\n&#x2F;&#x2F;用于转化为字符串\n#define concat(a, b) a ## b\n&#x2F;&#x2F;连接ab变量名成为新的变量名<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"25-信号处理\"><a href=\"#25-信号处理\" class=\"headerlink\" title=\"25.信号处理\"></a>25.信号处理</h2><p>信号定义在csignal库中</p>\n<p>信号是由操作系统传给进程的中断，会提早终止一个程序。</p>\n<p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。</p>\n<h3 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h3><table>\n<thead>\n<tr>\n<th align=\"left\">信号</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">SIGABRT</td>\n<td align=\"left\">程序的异常终止，如调用 <strong>abort</strong>。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGFPE</td>\n<td align=\"left\">错误的算术运算，比如除以零或导致溢出的操作。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGILL</td>\n<td align=\"left\">检测非法指令。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGINT</td>\n<td align=\"left\">程序终止(interrupt)信号。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGSEGV</td>\n<td align=\"left\">非法访问内存。</td>\n</tr>\n<tr>\n<td align=\"left\">SIGTERM</td>\n<td align=\"left\">发送到程序的终止请求。</td>\n</tr>\n</tbody></table>\n<h3 id=\"signal\"><a href=\"#signal\" class=\"headerlink\" title=\"signal\"></a>signal</h3><p>将信号和相应需要执行的操作绑定，当出现对应信号时执行相应的操作</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;csignal&gt;\nsignal(registered signal, signal handler)\n&#x2F;&#x2F;signal handler是自己写的函数\nint raise (signal sig);\n\nvoid signalHandler( int signum )\n&#123;\n    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\\n&quot;;\n \n    &#x2F;&#x2F; 清理并关闭\n    &#x2F;&#x2F; 终止程序  \n \n   exit(signum);  \n&#125;\nint main ()\n&#123;\n    &#x2F;&#x2F; 注册信号 SIGINT 和信号处理程序\n    signal(SIGINT, signalHandler);  \n \n    while(1)&#123;\n       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;\n       sleep(1);\n    &#125;\n \n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"raise\"><a href=\"#raise\" class=\"headerlink\" title=\"raise\"></a>raise</h3><p>抛出对应的信号</p>\n<h2 id=\"26-多线程\"><a href=\"#26-多线程\" class=\"headerlink\" title=\"26.多线程\"></a>26.多线程</h2><p>先埋坑</p>\n<h2 id=\"27-web编程\"><a href=\"#27-web编程\" class=\"headerlink\" title=\"27.web编程\"></a>27.web编程</h2><p>先埋坑</p>\n<h2 id=\"28-STL\"><a href=\"#28-STL\" class=\"headerlink\" title=\"28.STL\"></a>28.STL</h2><table>\n<thead>\n<tr>\n<th align=\"left\">组件</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">容器（Containers）</td>\n<td align=\"left\">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>\n</tr>\n<tr>\n<td align=\"left\">算法（Algorithms）</td>\n<td align=\"left\">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>\n</tr>\n<tr>\n<td align=\"left\">迭代器（iterators）</td>\n<td align=\"left\">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>\n</tr>\n</tbody></table>\n<h3 id=\"vec\"><a href=\"#vec\" class=\"headerlink\" title=\"vec\"></a>vec</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">int main() &#123;\n  vector&lt;int&gt; vec;\n  vec.push_back();\n  &#x2F;&#x2F;类似于python append 从尾部加入\n  vector&lt;int&gt;::iterator iterator &#x3D; vec.begin();\n  &#x2F;&#x2F;返回指向开头的迭代器\n  while (iterator !&#x3D; vec.end()) &#123;\n    &#x2F;&#x2F;当指针还没到队尾\n    cout &lt;&lt; *iterator++ &lt;&lt; endl;\n  &#125;\n  &#x2F;&#x2F;迭代器指针访问 \n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","text":"C++Learning记录一下Cpp的学习，方便以后复习，如果能帮到其他人就更好了 1.基本语法1.命名空间在C&#x2F;C++中，变量、函数和类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"learning","slug":"learning","count":5,"path":"api/categories/learning.json"}],"tags":[{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-Learning\"><span class=\"toc-text\">C++Learning</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">1.基本语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4\"><span class=\"toc-text\">1.命名空间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%EF%BC%9A\"><span class=\"toc-text\">定义：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">使用：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8C%83%E5%9B%B4%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">范围解析运算符:</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%85%B3%E9%94%AE%E8%AF%8D\"><span class=\"toc-text\">2.关键词</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.基本数据类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-typedef\"><span class=\"toc-text\">3.typedef</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">4.枚举</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">5.声明和初始化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-define-const\"><span class=\"toc-text\">6.define const</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%AD%98%E5%82%A8%E7%B1%BB\"><span class=\"toc-text\">7.存储类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">8.运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">9.函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82\"><span class=\"toc-text\">1.函数传参</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC\"><span class=\"toc-text\">2.参数默认值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-lambda%E5%87%BD%E6%95%B0%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">3.lambda函数与表达式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-%E5%BA%93%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">10.库函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%9A%8F%E6%9C%BA%E6%95%B0\"><span class=\"toc-text\">1.随机数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-time\"><span class=\"toc-text\">2.time</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-setw\"><span class=\"toc-text\">3.setw</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-setfill\"><span class=\"toc-text\">4.setfill</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">5.字符串函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-%E6%8C%87%E9%92%88\"><span class=\"toc-text\">11.指针</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">12.引用类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-%E5%AD%97%E7%AC%A6%E6%B5%81\"><span class=\"toc-text\">13.字符流</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">14.结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">15.类与对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">构造函数：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">析构函数：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">拷贝构造函数：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#16-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">16.友元函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#17-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">17.内联函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#18-%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">18.继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#19-%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">19.重载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">函数重载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">运算符重载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">可重载运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%8F%AF%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">不可重载运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">虚函数：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">纯虚函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#20-%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81\"><span class=\"toc-text\">20.文件和流</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">打开文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">关闭文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">写入文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">读取文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE%E6%8C%87%E9%92%88\"><span class=\"toc-text\">文件位置指针</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#21-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">21.异常处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#22-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98\"><span class=\"toc-text\">22.动态内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new\"><span class=\"toc-text\">new</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#delete\"><span class=\"toc-text\">delete</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#23-%E6%A8%A1%E7%89%88\"><span class=\"toc-text\">23.模版</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88\"><span class=\"toc-text\">函数模版</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E6%A8%A1%E7%89%88\"><span class=\"toc-text\">类模版</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#24-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8\"><span class=\"toc-text\">24.预处理器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#define\"><span class=\"toc-text\">define</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">条件编译</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%92%8C-%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">#和##运算符</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#25-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86\"><span class=\"toc-text\">25.信号处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%A1%E5%8F%B7\"><span class=\"toc-text\">信号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#signal\"><span class=\"toc-text\">signal</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#raise\"><span class=\"toc-text\">raise</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#26-%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">26.多线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#27-web%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">27.web编程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#28-STL\"><span class=\"toc-text\">28.STL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vec\"><span class=\"toc-text\">vec</span></a></li></ol></li></ol></li></ol>","author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaLearning","uid":"9b79bd1397114c7816318b0d6a9c055c","slug":"JavaLearning","date":"2022-11-03T02:56:52.000Z","updated":"2022-11-03T03:14:38.891Z","comments":true,"path":"api/articles/JavaLearning.json","keywords":null,"cover":"/post/JavaLearning/cover.jpg","text":"JavaLearning记录一下Java的学习，方便以后复习，如果能帮到其他人就更好了 detail匿名类：没有class关键词 只能实例化一个对象 内部类 类变量 实例变量 局部变量:循环体中的变量作用域仅限于该循环体 可变参数: 类中没有初始化的成员变量自动初始化为0，引用为...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"learning","slug":"learning","count":5,"path":"api/categories/learning.json"}],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"}],"author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"leetcode","uid":"1cac424653694fd0abd1397c14df4e06","slug":"leetcode","date":"2022-11-03T02:41:45.000Z","updated":"2022-11-03T02:54:57.726Z","comments":true,"path":"api/articles/leetcode.json","keywords":null,"cover":"/post/leetcode/cover.jpg","text":"leetcode本文主要用来记录自己刷lc的成长过程， 希望大家都能收获理想的offer 😊 input size 时间复杂度 常见算法 1~10 n! 排列 15~20 2^n 组合 10~50 n^4 100~200 n^3 1000~2000 n^2 DP 图问题 10^6...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[{"name":"learning","slug":"learning","count":5,"path":"api/categories/learning.json"}],"tags":[{"name":"leetcode","slug":"leetcode","count":1,"path":"api/tags/leetcode.json"}],"author":{"name":"Sihan Chen","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"Had I not seen the sun, I could have borne the shade","socials":{"github":"https://github.com/sihan-chen-yes","twitter":"","stackoverflow":"https://stackoverflow.com/users/15780533/sihan","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}